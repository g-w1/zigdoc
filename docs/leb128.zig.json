[{"doc_comment":"Read a single unsigned LEB128 value from the given reader as type T,\nor error.Overflow if the value cannot fit.","pl":"fn readULEB128(comptime T: type, reader: anytype) !T","src":10,"more_decls":null}{"doc_comment":"Write a single unsigned integer as unsigned LEB128 to the given writer.","pl":"fn writeULEB128(writer: anytype, uint_value: anytype) !void","src":40,"more_decls":null}{"doc_comment":"Read a single signed LEB128 value from the given reader as type T,\nor error.Overflow if the value cannot fit.","pl":"fn readILEB128(comptime T: type, reader: anytype) !T","src":59,"more_decls":null}{"doc_comment":"Write a single signed integer as signed LEB128 to the given writer.","pl":"fn writeILEB128(writer: anytype, int_value: anytype) !void","src":108,"more_decls":null}{"doc_comment":"This is an \"advanced\" function. It allows one to use a fixed amount of memory to store a\nULEB128. This defeats the entire purpose of using this data encoding; it will no longer use\nfewer bytes to store smaller numbers. The advantage of using a fixed width is that it makes\nfields have a predictable size and so depending on the use case this tradeoff can be worthwhile.\nAn example use case of this is in emitting DWARF info where one wants to make a ULEB128 field\n\"relocatable\", meaning that it becomes possible to later go back and patch the number to be a\ndifferent value without shifting all the following code.","pl":"fn writeUnsignedFixed(comptime l: usize, ptr: *[l]u8, int: std.meta.Int(.unsigned, l * 7)) void","src":136,"more_decls":null}]