[{"pl":"fn getAutoHashFn(comptime K: type) (fn (K) u64)","src":18,"more_decls":null}{"pl":"fn getAutoEqlFn(comptime K: type) (fn (K, K) bool)","src":43,"more_decls":null}{"pl":"pub fn AutoHashMap(comptime K: type, comptime V: type) type {\n    return HashMap(K, V, getAutoHashFn(K), getAutoEqlFn(K), default_max_load_percentage);\n}","src":51,"more_decls":null}{"pl":"pub fn AutoHashMapUnmanaged(comptime K: type, comptime V: type) type {\n    return HashMapUnmanaged(K, V, getAutoHashFn(K), getAutoEqlFn(K), default_max_load_percentage);\n}","src":55,"more_decls":null}{"doc_comment":"Builtin hashmap for strings as keys.","pl":"pub fn StringHashMap(comptime V: type) type {\n    return HashMap([]const u8, V, hashString, eqlString, default_max_load_percentage);\n}","src":60,"more_decls":null}{"pl":"pub fn StringHashMapUnmanaged(comptime V: type) type {\n    return HashMapUnmanaged([]const u8, V, hashString, eqlString, default_max_load_percentage);\n}","src":64,"more_decls":null}{"pl":"pub fn eqlString(a: []const u8, b: []const u8) bool {\n    return mem.eql(u8, a, b);\n}","src":68,"more_decls":null}{"pl":"pub fn hashString(s: []const u8) u64 {\n    return std.hash.Wyhash.hash(0, s);\n}","src":72,"more_decls":null}{"doc_comment":"General purpose hash table.\nNo order is guaranteed and any modification invalidates live iterators.\nIt provides fast operations (lookup, insertion, deletion) with quite high\nload factors (up to 80% by default) for a low memory usage.\nFor a hash map that can be initialized directly that does not store an Allocator\nfield, see `HashMapUnmanaged`.\nIf iterating over the table entries is a strong usecase and needs to be fast,\nprefer the alternative `std.ArrayHashMap`.","pl":"fn HashMap(\n    comptime K: type,\n    comptime V: type,\n    comptime hashFn: fn (key: K) u64,\n    comptime eqlFn: fn (a: K, b: K) bool,\n    comptime max_load_percentage: u64,\n) type","sub_container_type":"struct ","src":89,"more_decls":{"pl":"unmanaged: Unmanaged","src":97,"more_decls":null}{"pl":"allocator: *Allocator","src":98,"more_decls":null}{"pl":"pub fn init(allocator: *Allocator) Self {\n    return .{\n        .unmanaged = .{},\n        .allocator = allocator,\n    };\n}","src":109,"more_decls":null}{"pl":"pub fn deinit(self: *Self) void {\n    self.unmanaged.deinit(self.allocator);\n    self.* = undefined;\n}","src":116,"more_decls":null}{"pl":"pub fn clearRetainingCapacity(self: *Self) void {\n    return self.unmanaged.clearRetainingCapacity();\n}","src":121,"more_decls":null}{"pl":"pub fn clearAndFree(self: *Self) void {\n    return self.unmanaged.clearAndFree(self.allocator);\n}","src":125,"more_decls":null}{"pl":"pub fn count(self: Self) Size {\n    return self.unmanaged.count();\n}","src":129,"more_decls":null}{"pl":"pub fn iterator(self: *const Self) Iterator {\n    return self.unmanaged.iterator();\n}","src":133,"more_decls":null}{"doc_comment":"If key exists this function cannot fail.\nIf there is an existing item with `key`, then the result\n`Entry` pointer points to it, and found_existing is true.\nOtherwise, puts a new item with undefined value, and\nthe `Entry` pointer points to it. Caller should then initialize\nthe value (but not the key).","pl":"pub fn getOrPut(self: *Self, key: K) !GetOrPutResult {\n    return self.unmanaged.getOrPut(self.allocator, key);\n}","src":143,"more_decls":null}{"doc_comment":"If there is an existing item with `key`, then the result\n`Entry` pointer points to it, and found_existing is true.\nOtherwise, puts a new item with undefined value, and\nthe `Entry` pointer points to it. Caller should then initialize\nthe value (but not the key).\nIf a new entry needs to be stored, this function asserts there\nis enough capacity to store it.","pl":"pub fn getOrPutAssumeCapacity(self: *Self, key: K) GetOrPutResult {\n    return self.unmanaged.getOrPutAssumeCapacity(key);\n}","src":154,"more_decls":null}{"pl":"pub fn getOrPutValue(self: *Self, key: K, value: V) !*Entry {\n    return self.unmanaged.getOrPutValue(self.allocator, key, value);\n}","src":158,"more_decls":null}{"doc_comment":"Increases capacity, guaranteeing that insertions up until the\n`expected_count` will not cause an allocation, and therefore cannot fail.","pl":"pub fn ensureCapacity(self: *Self, expected_count: Size) !void {\n    return self.unmanaged.ensureCapacity(self.allocator, expected_count);\n}","src":164,"more_decls":null}{"doc_comment":"Returns the number of total elements which may be present before it is\nno longer guaranteed that no allocations will be performed.","pl":"pub fn capacity(self: *Self) Size {\n    return self.unmanaged.capacity();\n}","src":170,"more_decls":null}{"doc_comment":"Clobbers any existing data. To detect if a put would clobber\nexisting data, see `getOrPut`.","pl":"pub fn put(self: *Self, key: K, value: V) !void {\n    return self.unmanaged.put(self.allocator, key, value);\n}","src":176,"more_decls":null}{"doc_comment":"Inserts a key-value pair into the hash map, asserting that no previous\nentry with the same key is already present","pl":"pub fn putNoClobber(self: *Self, key: K, value: V) !void {\n    return self.unmanaged.putNoClobber(self.allocator, key, value);\n}","src":182,"more_decls":null}{"doc_comment":"Asserts there is enough capacity to store the new key-value pair.\nClobbers any existing data. To detect if a put would clobber\nexisting data, see `getOrPutAssumeCapacity`.","pl":"pub fn putAssumeCapacity(self: *Self, key: K, value: V) void {\n    return self.unmanaged.putAssumeCapacity(key, value);\n}","src":189,"more_decls":null}{"doc_comment":"Asserts there is enough capacity to store the new key-value pair.\nAsserts that it does not clobber any existing data.\nTo detect if a put would clobber existing data, see `getOrPutAssumeCapacity`.","pl":"pub fn putAssumeCapacityNoClobber(self: *Self, key: K, value: V) void {\n    return self.unmanaged.putAssumeCapacityNoClobber(key, value);\n}","src":196,"more_decls":null}{"doc_comment":"Inserts a new `Entry` into the hash map, returning the previous one, if any.","pl":"pub fn fetchPut(self: *Self, key: K, value: V) !?Entry {\n    return self.unmanaged.fetchPut(self.allocator, key, value);\n}","src":201,"more_decls":null}{"doc_comment":"Inserts a new `Entry` into the hash map, returning the previous one, if any.\nIf insertion happuns, asserts there is enough capacity without allocating.","pl":"pub fn fetchPutAssumeCapacity(self: *Self, key: K, value: V) ?Entry {\n    return self.unmanaged.fetchPutAssumeCapacity(key, value);\n}","src":207,"more_decls":null}{"pl":"pub fn get(self: Self, key: K) ?V {\n    return self.unmanaged.get(key);\n}","src":211,"more_decls":null}{"pl":"pub fn getEntry(self: Self, key: K) ?*Entry {\n    return self.unmanaged.getEntry(key);\n}","src":215,"more_decls":null}{"pl":"pub fn contains(self: Self, key: K) bool {\n    return self.unmanaged.contains(key);\n}","src":219,"more_decls":null}{"doc_comment":"If there is an `Entry` with a matching key, it is deleted from\nthe hash map, and then returned from this function.","pl":"pub fn remove(self: *Self, key: K) ?Entry {\n    return self.unmanaged.remove(key);\n}","src":225,"more_decls":null}{"doc_comment":"Asserts there is an `Entry` with matching key, deletes it from the hash map,\nand discards it.","pl":"pub fn removeAssertDiscard(self: *Self, key: K) void {\n    return self.unmanaged.removeAssertDiscard(key);\n}","src":231,"more_decls":null}{"pl":"pub fn clone(self: Self) !Self {\n    var other = try self.unmanaged.clone(self.allocator);\n    return other.promote(self.allocator);\n}","src":235,"more_decls":null}{"pl":"const Unmanaged = HashMapUnmanaged(K, V, hashFn, eqlFn, max_load_percentage)","src":100,"more_decls":null}{"pl":"const Entry = Unmanaged.Entry","src":101,"more_decls":null}{"pl":"const Hash = Unmanaged.Hash","src":102,"more_decls":null}{"pl":"const Iterator = Unmanaged.Iterator","src":103,"more_decls":null}{"pl":"const Size = Unmanaged.Size","src":104,"more_decls":null}{"pl":"const GetOrPutResult = Unmanaged.GetOrPutResult","src":105,"more_decls":null}}{"doc_comment":"A HashMap based on open addressing and linear probing.\nA lookup or modification typically occurs only 2 cache misses.\nNo order is guaranteed and any modification invalidates live iterators.\nIt achieves good performance with quite high load factors (by default,\ngrow is triggered at 80% full) and only one byte of overhead per element.\nThe struct itself is only 16 bytes for a small footprint. This comes at\nthe price of handling size with u32, which should be reasonnable enough\nfor almost all uses.\nDeletions are achieved with tombstones.","pl":"fn HashMapUnmanaged(\n    comptime K: type,\n    comptime V: type,\n    hashFn: fn (key: K) u64,\n    eqlFn: fn (a: K, b: K) bool,\n    comptime max_load_percentage: u64,\n) type","sub_container_type":"struct ","src":251,"more_decls":{"doc_comment":"Pointer to the metadata.","pl":"metadata: ?[*]Metadata = null","src":271,"more_decls":null}{"doc_comment":"Current number of elements in the hashmap.","pl":"size: Size = 0","src":274,"more_decls":null}{"doc_comment":"Number of available slots before a grow is needed to satisfy the\n`max_load_percentage`.","pl":"available: Size = 0","src":280,"more_decls":null}{"pl":"pub const Entry = struct ","src":293,"more_decls":{"pl":"key: K","src":294,"more_decls":null}{"pl":"value: V","src":295,"more_decls":null}}{"pl":"pub const GetOrPutResult = struct ","src":382,"more_decls":{"pl":"entry: *Entry","src":383,"more_decls":null}{"pl":"found_existing: bool","src":384,"more_decls":null}}{"pl":"pub fn promote(self: Self, allocator: *Allocator) Managed {\n    return .{\n        .unmanaged = self,\n        .allocator = allocator,\n    };\n}","src":389,"more_decls":null}{"pl":"pub fn init(allocator: *Allocator) Self {\n    return .{};\n}","src":400,"more_decls":null}{"pl":"pub fn deinit(self: *Self, allocator: *Allocator) void {\n    self.deallocate(allocator);\n    self.* = undefined;\n}","src":404,"more_decls":null}{"pl":"pub fn ensureCapacity(self: *Self, allocator: *Allocator, new_size: Size) !void {\n    if (new_size > self.size)\n        try self.growIfNeeded(allocator, new_size - self.size);\n}","src":435,"more_decls":null}{"pl":"fn clearRetainingCapacity(self: *Self) void","src":440,"more_decls":null}{"pl":"pub fn clearAndFree(self: *Self, allocator: *Allocator) void {\n    self.deallocate(allocator);\n    self.size = 0;\n    self.available = 0;\n}","src":448,"more_decls":null}{"pl":"pub fn count(self: *const Self) Size {\n    return self.size;\n}","src":454,"more_decls":null}{"pl":"pub fn capacity(self: *const Self) Size {\n    if (self.metadata == null) return 0;\n\n    return self.header().capacity;\n}","src":466,"more_decls":null}{"pl":"pub fn iterator(self: *const Self) Iterator {\n    return .{ .hm = self };\n}","src":472,"more_decls":null}{"doc_comment":"Insert an entry in the map. Assumes it is not already present.","pl":"pub fn putNoClobber(self: *Self, allocator: *Allocator, key: K, value: V) !void {\n    assert(!self.contains(key));\n    try self.growIfNeeded(allocator, 1);\n\n    self.putAssumeCapacityNoClobber(key, value);\n}","src":477,"more_decls":null}{"doc_comment":"Asserts there is enough capacity to store the new key-value pair.\nClobbers any existing data. To detect if a put would clobber\nexisting data, see `getOrPutAssumeCapacity`.","pl":"pub fn putAssumeCapacity(self: *Self, key: K, value: V) void {\n    const gop = self.getOrPutAssumeCapacity(key);\n    gop.entry.value = value;\n}","src":487,"more_decls":null}{"doc_comment":"Insert an entry in the map. Assumes it is not already present,\nand that no allocation is needed.","pl":"fn putAssumeCapacityNoClobber(self: *Self, key: K, value: V) void","src":494,"more_decls":null}{"doc_comment":"Inserts a new `Entry` into the hash map, returning the previous one, if any.","pl":"fn fetchPut(self: *Self, allocator: *Allocator, key: K, value: V) !?Entry","src":520,"more_decls":null}{"doc_comment":"Inserts a new `Entry` into the hash map, returning the previous one, if any.\nIf insertion happens, asserts there is enough capacity without allocating.","pl":"fn fetchPutAssumeCapacity(self: *Self, key: K, value: V) ?Entry","src":532,"more_decls":null}{"pl":"fn getEntry(self: Self, key: K) ?*Entry","src":542,"more_decls":null}{"doc_comment":"Insert an entry if the associated key is not already present, otherwise update preexisting value.","pl":"pub fn put(self: *Self, allocator: *Allocator, key: K, value: V) !void {\n    const result = try self.getOrPut(allocator, key);\n    result.entry.value = value;\n}","src":568,"more_decls":null}{"doc_comment":"Get an optional pointer to the value associated with key, if present.","pl":"fn get(self: Self, key: K) ?V","src":574,"more_decls":null}{"pl":"pub fn getOrPut(self: *Self, allocator: *Allocator, key: K) !GetOrPutResult {\n    try self.growIfNeeded(allocator, 1);\n\n    return self.getOrPutAssumeCapacity(key);\n}","src":599,"more_decls":null}{"pl":"fn getOrPutAssumeCapacity(self: *Self, key: K) GetOrPutResult","src":605,"more_decls":null}{"pl":"pub fn getOrPutValue(self: *Self, allocator: *Allocator, key: K, value: V) !*Entry {\n    const res = try self.getOrPut(allocator, key);\n    if (!res.found_existing) res.entry.value = value;\n    return res.entry;\n}","src":644,"more_decls":null}{"doc_comment":"Return true if there is a value associated with key in the map.","pl":"pub fn contains(self: *const Self, key: K) bool {\n    return self.get(key) != null;\n}","src":651,"more_decls":null}{"doc_comment":"If there is an `Entry` with a matching key, it is deleted from\nthe hash map, and then returned from this function.","pl":"fn remove(self: *Self, key: K) ?Entry","src":657,"more_decls":null}{"doc_comment":"Asserts there is an `Entry` with matching key, deletes it from the hash map,\nand discards it.","pl":"fn removeAssertDiscard(self: *Self, key: K) void","src":686,"more_decls":null}{"pl":"fn clone(self: Self, allocator: *Allocator) !Self","src":730,"more_decls":null}{"pl":"const Managed = HashMap(K, V, hashFn, eqlFn, max_load_percentage)","src":387,"more_decls":null}}{"doc_comment":"Deprecated use `default_max_load_percentage`","pl":"const DefaultMaxLoadPercentage = default_max_load_percentage","src":77,"more_decls":null}{"pl":"const default_max_load_percentage = 80","src":79,"more_decls":null}]