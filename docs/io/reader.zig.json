[{"pl":"fn Reader(\n    comptime Context: type,\n    comptime ReadError: type,\n    /// Returns the number of bytes read. It may be less than buffer.len.\n    /// If the number of bytes read is 0, it means end of stream.\n    /// End of stream is not an error condition.\n    comptime readFn: fn (context: Context, buffer: []u8) ReadError!usize,\n) type","sub_container_type":"struct ","src":12,"more_decls":{"pl":"context: Context","src":23,"more_decls":null}{"doc_comment":"Optional parameters for `skipBytes`","pl":"pub const SkipBytesOptions = struct ","src":269,"more_decls":{"pl":"buf_size: usize = 512","src":270,"more_decls":null}}{"doc_comment":"Returns the number of bytes read. It may be less than buffer.len.\nIf the number of bytes read is 0, it means end of stream.\nEnd of stream is not an error condition.","pl":"pub fn read(self: Self, buffer: []u8) Error!usize {\n    return readFn(self.context, buffer);\n}","src":30,"more_decls":null}{"doc_comment":"Returns the number of bytes read. If the number read is smaller than `buffer.len`, it\nmeans the stream reached the end. Reaching the end of a stream is not an error\ncondition.","pl":"fn readAll(self: Self, buffer: []u8) Error!usize","src":37,"more_decls":null}{"doc_comment":"If the number read would be smaller than `buf.len`, `error.EndOfStream` is returned instead.","pl":"pub fn readNoEof(self: Self, buf: []u8) !void {\n    const amt_read = try self.readAll(buf);\n    if (amt_read < buf.len) return error.EndOfStream;\n}","src":48,"more_decls":null}{"doc_comment":"Appends to the `std.ArrayList` contents by reading from the stream until end of stream is found.\nIf the number of bytes appended would exceed `max_append_size`, `error.StreamTooLong` is returned\nand the `std.ArrayList` has exactly `max_append_size` bytes appended.","pl":"pub fn readAllArrayList(self: Self, array_list: *std.ArrayList(u8), max_append_size: usize) !void {\n    return self.readAllArrayListAligned(null, array_list, max_append_size);\n}","src":58,"more_decls":null}{"pl":"fn readAllArrayListAligned(\n    self: Self,\n    comptime alignment: ?u29,\n    array_list: *std.ArrayListAligned(u8, alignment),\n    max_append_size: usize,\n) !void","src":62,"more_decls":null}{"doc_comment":"Allocates enough memory to hold all the contents of the stream. If the allocated\nmemory would be greater than `max_size`, returns `error.StreamTooLong`.\nCaller owns returned memory.\nIf this function returns an error, the contents from the stream read so far are lost.","pl":"pub fn readAllAlloc(self: Self, allocator: *mem.Allocator, max_size: usize) ![]u8 {\n    var array_list = std.ArrayList(u8).init(allocator);\n    defer array_list.deinit();\n    try self.readAllArrayList(&array_list, max_size);\n    return array_list.toOwnedSlice();\n}","src":96,"more_decls":null}{"doc_comment":"Replaces the `std.ArrayList` contents by reading from the stream until `delimiter` is found.\nDoes not include the delimiter in the result.\nIf the `std.ArrayList` length would exceed `max_size`, `error.StreamTooLong` is returned and the\n`std.ArrayList` is populated with `max_size` bytes from the stream.","pl":"fn readUntilDelimiterArrayList(\n    self: Self,\n    array_list: *std.ArrayList(u8),\n    delimiter: u8,\n    max_size: usize,\n) !void","src":107,"more_decls":null}{"doc_comment":"Allocates enough memory to read until `delimiter`. If the allocated\nmemory would be greater than `max_size`, returns `error.StreamTooLong`.\nCaller owns returned memory.\nIf this function returns an error, the contents from the stream read so far are lost.","pl":"fn readUntilDelimiterAlloc(\n    self: Self,\n    allocator: *mem.Allocator,\n    delimiter: u8,\n    max_size: usize,\n) ![]u8","src":133,"more_decls":null}{"doc_comment":"Allocates enough memory to read until `delimiter` or end-of-stream.\nIf the allocated memory would be greater than `max_size`, returns\n`error.StreamTooLong`. If end-of-stream is found, returns the rest\nof the stream. If this function is called again after that, returns\nnull.\nCaller owns returned memory.\nIf this function returns an error, the contents from the stream read so far are lost.","pl":"fn readUntilDelimiterOrEofAlloc(\n    self: Self,\n    allocator: *mem.Allocator,\n    delimiter: u8,\n    max_size: usize,\n) !?[]u8","src":152,"more_decls":null}{"doc_comment":"Reads from the stream until specified byte is found. If the buffer is not\nlarge enough to hold the entire contents, `error.StreamTooLong` is returned.\nIf end-of-stream is found, returns the rest of the stream. If this\nfunction is called again after that, returns null.\nReturns a slice of the stream data, with ptr equal to `buf.ptr`. The\ndelimiter byte is not included in the returned slice.","pl":"fn readUntilDelimiterOrEof(self: Self, buf: []u8, delimiter: u8) !?[]u8","src":177,"more_decls":null}{"doc_comment":"Reads from the stream until specified byte is found, discarding all data,\nincluding the delimiter.\nIf end-of-stream is found, this function succeeds.","pl":"fn skipUntilDelimiterOrEof(self: Self, delimiter: u8) !void","src":202,"more_decls":null}{"doc_comment":"Reads 1 byte from the stream or returns `error.EndOfStream`.","pl":"pub fn readByte(self: Self) !u8 {\n    var result: [1]u8 = undefined;\n    const amt_read = try self.read(result[0..]);\n    if (amt_read < 1) return error.EndOfStream;\n    return result[0];\n}","src":213,"more_decls":null}{"doc_comment":"Same as `readByte` except the returned byte is signed.","pl":"pub fn readByteSigned(self: Self) !i8 {\n    return @bitCast(i8, try self.readByte());\n}","src":221,"more_decls":null}{"doc_comment":"Reads exactly `num_bytes` bytes and returns as an array.\n`num_bytes` must be comptime-known","pl":"pub fn readBytesNoEof(self: Self, comptime num_bytes: usize) ![num_bytes]u8 {\n    var bytes: [num_bytes]u8 = undefined;\n    try self.readNoEof(&bytes);\n    return bytes;\n}","src":227,"more_decls":null}{"doc_comment":"Reads a native-endian integer","pl":"pub fn readIntNative(self: Self, comptime T: type) !T {\n    const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);\n    return mem.readIntNative(T, &bytes);\n}","src":234,"more_decls":null}{"doc_comment":"Reads a foreign-endian integer","pl":"pub fn readIntForeign(self: Self, comptime T: type) !T {\n    const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);\n    return mem.readIntForeign(T, &bytes);\n}","src":240,"more_decls":null}{"pl":"pub fn readIntLittle(self: Self, comptime T: type) !T {\n    const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);\n    return mem.readIntLittle(T, &bytes);\n}","src":245,"more_decls":null}{"pl":"pub fn readIntBig(self: Self, comptime T: type) !T {\n    const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);\n    return mem.readIntBig(T, &bytes);\n}","src":250,"more_decls":null}{"pl":"pub fn readInt(self: Self, comptime T: type, endian: builtin.Endian) !T {\n    const bytes = try self.readBytesNoEof((@typeInfo(T).Int.bits + 7) / 8);\n    return mem.readInt(T, &bytes, endian);\n}","src":255,"more_decls":null}{"pl":"fn readVarInt(self: Self, comptime ReturnType: type, endian: builtin.Endian, size: usize) !ReturnType","src":260,"more_decls":null}{"doc_comment":"Reads `num_bytes` bytes from the stream and discards them","pl":"fn skipBytes(self: Self, num_bytes: u64, comptime options: SkipBytesOptions) !void","src":275,"more_decls":null}{"doc_comment":"Reads `slice.len` bytes from the stream and returns if they are the same as the passed slice","pl":"fn isBytes(self: Self, slice: []const u8) !bool","src":287,"more_decls":null}{"pl":"fn readStruct(self: Self, comptime T: type) !T","src":298,"more_decls":null}{"doc_comment":"Reads an integer with the same size as the given enum's tag type. If the integer matches\nan enum tag, casts the integer to the enum tag and returns it. Otherwise, returns an error.\nTODO optimization taking advantage of most fields being in order","pl":"fn readEnum(self: Self, comptime Enum: type, endian: builtin.Endian) !Enum","src":309,"more_decls":null}{"pl":"const Error = ReadError","src":21,"more_decls":null}{"pl":"const readAllBuffer = @compileError(\"deprecated; use readAllArrayList()\")","src":53,"more_decls":null}}]