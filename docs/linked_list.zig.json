[{"doc_comment":"A singly-linked list is headed by a single forward pointer. The elements\nare singly linked for minimum space and pointer manipulation overhead at\nthe expense of O(n) removal for arbitrary elements. New elements can be\nadded to the list after an existing element or at the head of the list.\nA singly-linked list may only be traversed in the forward direction.\nSingly-linked lists are ideal for applications with large datasets and\nfew or no removals or for implementing a LIFO queue.","pl":"fn SinglyLinkedList(comptime T: type) type","sub_container_type":"struct ","src":19,"more_decls":{"pl":"first: ?*Node = null","src":72,"more_decls":null}{"doc_comment":"Node inside the linked list wrapping the actual data.","pl":"pub const Node = struct ","src":24,"more_decls":{"pl":"next: ?*Node = null","src":25,"more_decls":null}{"pl":"data: T","src":26,"more_decls":null}{"doc_comment":"Insert a new node after the current one.\n\nArguments:\nnew_node: Pointer to the new node to insert.","pl":"pub fn insertAfter(node: *Node, new_node: *Node) void {\n    new_node.next = node.next;\n    node.next = new_node;\n}","src":34,"more_decls":null}{"doc_comment":"Remove a node from the list.\n\nArguments:\nnode: Pointer to the node to be removed.\nReturns:\nnode removed","pl":"pub fn removeNext(node: *Node) ?*Node {\n    const next_node = node.next orelse return null;\n    node.next = next_node.next;\n    return next_node;\n}","src":45,"more_decls":null}{"doc_comment":"Iterate over the singly-linked list from this node, until the final node is found.\nThis operation is O(N).","pl":"pub fn findLast(node: *Node) *Node {\n    var it = node;\n    while (true) {\n        it = it.next orelse return it;\n    }\n}","src":53,"more_decls":null}{"doc_comment":"Iterate over each next node, returning the count of all nodes except the starting one.\nThis operation is O(N).","pl":"fn countChildren(node: *const Node) usize","src":62,"more_decls":null}{"pl":"const Data = T","src":28,"more_decls":null}}{"doc_comment":"Insert a new node at the head.\n\nArguments:\nnew_node: Pointer to the new node to insert.","pl":"pub fn prepend(list: *Self, new_node: *Node) void {\n    new_node.next = list.first;\n    list.first = new_node;\n}","src":78,"more_decls":null}{"doc_comment":"Remove a node from the list.\n\nArguments:\nnode: Pointer to the node to be removed.","pl":"fn remove(list: *Self, node: *Node) void","src":87,"more_decls":null}{"doc_comment":"Remove and return the first node in the list.\n\nReturns:\nA pointer to the first node in the list.","pl":"pub fn popFirst(list: *Self) ?*Node {\n    const first = list.first orelse return null;\n    list.first = first.next;\n    return first;\n}","src":103,"more_decls":null}{"doc_comment":"Iterate over all nodes, returning the count.\nThis operation is O(N).","pl":"fn len(list: Self) usize","src":111,"more_decls":null}}{"doc_comment":"A tail queue is headed by a pair of pointers, one to the head of the\nlist and the other to the tail of the list. The elements are doubly\nlinked so that an arbitrary element can be removed without a need to\ntraverse the list. New elements can be added to the list before or\nafter an existing element, at the head of the list, or at the end of\nthe list. A tail queue may be traversed in either direction.","pl":"fn TailQueue(comptime T: type) type","sub_container_type":"struct ","src":166,"more_decls":{"pl":"first: ?*Node = null","src":177,"more_decls":null}{"pl":"last: ?*Node = null","src":178,"more_decls":null}{"pl":"len: usize = 0","src":179,"more_decls":null}{"doc_comment":"Node inside the linked list wrapping the actual data.","pl":"pub const Node = struct ","src":171,"more_decls":{"pl":"prev: ?*Node = null","src":172,"more_decls":null}{"pl":"next: ?*Node = null","src":173,"more_decls":null}{"pl":"data: T","src":174,"more_decls":null}}{"doc_comment":"Insert a new node after an existing one.\n\nArguments:\nnode: Pointer to a node in the list.\nnew_node: Pointer to the new node to insert.","pl":"fn insertAfter(list: *Self, node: *Node, new_node: *Node) void","src":186,"more_decls":null}{"doc_comment":"Insert a new node before an existing one.\n\nArguments:\nnode: Pointer to a node in the list.\nnew_node: Pointer to the new node to insert.","pl":"fn insertBefore(list: *Self, node: *Node, new_node: *Node) void","src":207,"more_decls":null}{"doc_comment":"Concatenate list2 onto the end of list1, removing all entries from the former.\n\nArguments:\nlist1: the list to concatenate onto\nlist2: the list to be concatenated","pl":"fn concatByMoving(list1: *Self, list2: *Self) void","src":228,"more_decls":null}{"doc_comment":"Insert a new node at the end of the list.\n\nArguments:\nnew_node: Pointer to the new node to insert.","pl":"fn append(list: *Self, new_node: *Node) void","src":249,"more_decls":null}{"doc_comment":"Insert a new node at the beginning of the list.\n\nArguments:\nnew_node: Pointer to the new node to insert.","pl":"fn prepend(list: *Self, new_node: *Node) void","src":263,"more_decls":null}{"doc_comment":"Remove a node from the list.\n\nArguments:\nnode: Pointer to the node to be removed.","pl":"fn remove(list: *Self, node: *Node) void","src":282,"more_decls":null}{"doc_comment":"Remove and return the last node in the list.\n\nReturns:\nA pointer to the last node in the list.","pl":"pub fn pop(list: *Self) ?*Node {\n    const last = list.last orelse return null;\n    list.remove(last);\n    return last;\n}","src":307,"more_decls":null}{"doc_comment":"Remove and return the first node in the list.\n\nReturns:\nA pointer to the first node in the list.","pl":"pub fn popFirst(list: *Self) ?*Node {\n    const first = list.first orelse return null;\n    list.remove(first);\n    return first;\n}","src":317,"more_decls":null}}]