[{"doc_comment":"Utf8View iterates the code points of a utf-8 encoded string.\n\n```\nvar utf8 = (try std.unicode.Utf8View.init(\"hi there\")).iterator();\nwhile (utf8.nextCodepointSlice()) |codepoint| {\nstd.debug.warn(\"got codepoint {}\\n\", .{codepoint});\n}\n```","pl":"pub const Utf8View = struct ","src":227,"more_decls":{"pl":"bytes: []const u8","src":228,"more_decls":null}{"pl":"fn init(s: []const u8) !Utf8View","src":230,"more_decls":null}{"pl":"pub fn initUnchecked(s: []const u8) Utf8View {\n    return Utf8View{ .bytes = s };\n}","src":238,"more_decls":null}{"doc_comment":"TODO: https://github.com/ziglang/zig/issues/425","pl":"fn initComptime(comptime s: []const u8) Utf8View","src":243,"more_decls":null}{"pl":"pub fn iterator(s: Utf8View) Utf8Iterator {\n    return Utf8Iterator{\n        .bytes = s.bytes,\n        .i = 0,\n    };\n}","src":254,"more_decls":null}}{"pl":"pub const Utf8Iterator = struct ","src":262,"more_decls":{"pl":"bytes: []const u8","src":263,"more_decls":null}{"pl":"i: usize","src":264,"more_decls":null}{"pl":"fn nextCodepointSlice(it: *Utf8Iterator) ?[]const u8","src":266,"more_decls":null}{"pl":"fn nextCodepoint(it: *Utf8Iterator) ?u21","src":276,"more_decls":null}{"doc_comment":"Look ahead at the next n codepoints without advancing the iterator.\nIf fewer than n codepoints are available, then return the remainder of the string.","pl":"fn peek(it: *Utf8Iterator, n: usize) []const u8","src":290,"more_decls":null}}{"pl":"pub const Utf16LeIterator = struct ","src":305,"more_decls":{"pl":"bytes: []const u8","src":306,"more_decls":null}{"pl":"i: usize","src":307,"more_decls":null}{"pl":"pub fn init(s: []const u16) Utf16LeIterator {\n    return Utf16LeIterator{\n        .bytes = mem.sliceAsBytes(s),\n        .i = 0,\n    };\n}","src":309,"more_decls":null}{"pl":"fn nextCodepoint(it: *Utf16LeIterator) !?u21","src":316,"more_decls":null}}{"doc_comment":"Returns how many bytes the UTF-8 representation would require\nfor the given codepoint.","pl":"fn utf8CodepointSequenceLength(c: u21) !u3","src":13,"more_decls":null}{"doc_comment":"Given the first byte of a UTF-8 codepoint,\nreturns a number 1-4 indicating the total length of the codepoint in bytes.\nIf this byte does not match the form of a UTF-8 start byte, returns Utf8InvalidStartByte.","pl":"fn utf8ByteSequenceLength(first_byte: u8) !u3","src":24,"more_decls":null}{"doc_comment":"Encodes the given codepoint into a UTF-8 byte sequence.\nc: the codepoint.\nout: the out buffer to write to. Must have a len >= utf8CodepointSequenceLength(c).\nErrors: if c cannot be encoded in UTF-8.\nReturns: the number of bytes written to out.","pl":"fn utf8Encode(c: u21, out: []u8) !u3","src":40,"more_decls":null}{"doc_comment":"Decodes the UTF-8 codepoint encoded in the given slice of bytes.\nbytes.len must be equal to utf8ByteSequenceLength(bytes[0]) catch unreachable.\nIf you already know the length at comptime, you can call one of\nutf8Decode2,utf8Decode3,utf8Decode4 directly instead of this function.","pl":"fn utf8Decode(bytes: []const u8) Utf8DecodeError!u21","src":76,"more_decls":null}{"pl":"fn utf8Decode2(bytes: []const u8) Utf8Decode2Error!u21","src":90,"more_decls":null}{"pl":"fn utf8Decode3(bytes: []const u8) Utf8Decode3Error!u21","src":109,"more_decls":null}{"pl":"fn utf8Decode4(bytes: []const u8) Utf8Decode4Error!u21","src":133,"more_decls":null}{"doc_comment":"Returns true if the given unicode codepoint can be encoded in UTF-8.","pl":"fn utf8ValidCodepoint(value: u21) bool","src":157,"more_decls":null}{"doc_comment":"Returns the length of a supplied UTF-8 string literal in terms of unicode\ncodepoints.\nAsserts that the data is valid UTF-8.","pl":"fn utf8CountCodepoints(s: []const u8) !usize","src":168,"more_decls":null}{"pl":"fn utf8ValidateSlice(s: []const u8) bool","src":200,"more_decls":null}{"doc_comment":"Caller must free returned memory.","pl":"fn utf16leToUtf8Alloc(allocator: *mem.Allocator, utf16le: []const u16) ![]u8","src":560,"more_decls":null}{"doc_comment":"Caller must free returned memory.","pl":"fn utf16leToUtf8AllocZ(allocator: *mem.Allocator, utf16le: []const u16) ![:0]u8","src":577,"more_decls":null}{"doc_comment":"Asserts that the output buffer is big enough.\nReturns end byte index into utf8.","pl":"fn utf16leToUtf8(utf8: []u8, utf16le: []const u16) !usize","src":599,"more_decls":null}{"pl":"fn utf8ToUtf16LeWithNull(allocator: *mem.Allocator, utf8: []const u8) ![:0]u16","src":664,"more_decls":null}{"doc_comment":"Returns index of next character. If exact fit, returned index equals output slice length.\nAssumes there is enough space for the output.","pl":"fn utf8ToUtf16Le(utf16le: []u16, utf8: []const u8) !usize","src":692,"more_decls":null}{"doc_comment":"Converts a UTF-8 string literal into a UTF-16LE string literal.","pl":"fn utf8ToUtf16LeStringLiteral(comptime utf8: []const u8) *const [calcUtf16LeLen(utf8):0]u16","src":745,"more_decls":null}]