[{"doc_comment":"A scalar in unpacked reprentation","pl":"pub const Scalar = struct ","src":100,"more_decls":{"pl":"limbs: Limbs = undefined","src":102,"more_decls":null}{"doc_comment":"Unpack a 32-byte representation of a scalar","pl":"pub fn fromBytes(bytes: [32]u8) Scalar {\n    return ScalarDouble.fromBytes32(bytes).reduce(5);\n}","src":105,"more_decls":null}{"doc_comment":"Pack a scalar into bytes","pl":"fn toBytes(expanded: *const Scalar) [32]u8","src":110,"more_decls":null}{"doc_comment":"Return x+y (mod l)","pl":"fn add(x: Scalar, y: Scalar) Scalar","src":121,"more_decls":null}{"doc_comment":"Return x*r (mod l)","pl":"fn mul(x: Scalar, y: Scalar) Scalar","src":178,"more_decls":null}}{"doc_comment":"Reject a scalar whose encoding is not canonical.","pl":"fn rejectNonCanonical(s: [32]u8) Error!void","src":21,"more_decls":null}{"doc_comment":"Reduce a scalar to the field size.","pl":"pub fn reduce(s: [32]u8) [32]u8 {\n    return Scalar.fromBytes(s).toBytes();\n}","src":38,"more_decls":null}{"doc_comment":"Reduce a 64-bytes scalar to the field size.","pl":"pub fn reduce64(s: [64]u8) [32]u8 {\n    return ScalarDouble.fromBytes64(s).toBytes();\n}","src":43,"more_decls":null}{"doc_comment":"Perform the X25519 \"clamping\" operation.\nThe scalar is then guaranteed to be a multiple of the cofactor.","pl":"pub fn clamp(s: *[32]u8) callconv(.Inline) void {\n    s[0] &= 248;\n    s[31] = (s[31] & 127) | 64;\n}","src":49,"more_decls":null}{"doc_comment":"Return a*b (mod L)","pl":"pub fn mul(a: [32]u8, b: [32]u8) [32]u8 {\n    return Scalar.fromBytes(a).mul(Scalar.fromBytes(b)).toBytes();\n}","src":55,"more_decls":null}{"doc_comment":"Return a*b+c (mod L)","pl":"pub fn mulAdd(a: [32]u8, b: [32]u8, c: [32]u8) [32]u8 {\n    return Scalar.fromBytes(a).mul(Scalar.fromBytes(b)).add(Scalar.fromBytes(c)).toBytes();\n}","src":60,"more_decls":null}{"doc_comment":"Return a*8 (mod L)","pl":"fn mul8(s: [32]u8) [32]u8","src":65,"more_decls":null}{"doc_comment":"Return a+b (mod L)","pl":"pub fn add(a: [32]u8, b: [32]u8) [32]u8 {\n    return Scalar.fromBytes(a).add(Scalar.fromBytes(b)).toBytes();\n}","src":74,"more_decls":null}{"doc_comment":"Return -s (mod L)","pl":"fn neg(s: [32]u8) [32]u8","src":79,"more_decls":null}{"doc_comment":"Return (a-b) (mod L)","pl":"pub fn sub(a: [32]u8, b: [32]u8) [32]u8 {\n    return add(a, neg(b));\n}","src":95,"more_decls":null}{"doc_comment":"2^252 + 27742317777372353535851937790883648493","pl":"const field_size = [32]u8{\n    0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // 2^252+27742317777372353535851937790883648493\n}","src":10,"more_decls":null}{"doc_comment":"A compressed scalar","pl":"const CompressedScalar = [32]u8","src":15,"more_decls":null}{"doc_comment":"Zero","pl":"const zero = [_]u8{0} ** 32","src":18,"more_decls":null}]