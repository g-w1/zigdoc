[{"pl":"pub const Fe = struct ","src":10,"more_decls":{"pl":"limbs: [5]u64","src":11,"more_decls":null}{"doc_comment":"Return true if the field element is zero","pl":"pub fn isZero(fe: Fe) callconv(.Inline) bool {\n    var reduced = fe;\n    reduced.reduce();\n    const limbs = reduced.limbs;\n    return (limbs[0] | limbs[1] | limbs[2] | limbs[3] | limbs[4]) == 0;\n}","src":55,"more_decls":null}{"doc_comment":"Return true if both field elements are equivalent","pl":"pub fn equivalent(a: Fe, b: Fe) callconv(.Inline) bool {\n    return a.sub(b).isZero();\n}","src":63,"more_decls":null}{"doc_comment":"Unpack a field element","pl":"fn fromBytes(s: [32]u8) Fe","src":68,"more_decls":null}{"doc_comment":"Pack a field element","pl":"fn toBytes(fe: Fe) [32]u8","src":80,"more_decls":null}{"doc_comment":"Map a 64-bit big endian string into a field element","pl":"fn fromBytes64(s: [64]u8) Fe","src":93,"more_decls":null}{"doc_comment":"Reject non-canonical encodings of an element, possibly ignoring the top bit","pl":"fn rejectNonCanonical(s: [32]u8, comptime ignore_extra_bit: bool) Error!void","src":115,"more_decls":null}{"doc_comment":"Add a field element","pl":"fn add(a: Fe, b: Fe) callconv(.Inline) Fe","src":167,"more_decls":null}{"doc_comment":"Substract a field elememnt","pl":"fn sub(a: Fe, b: Fe) callconv(.Inline) Fe","src":177,"more_decls":null}{"doc_comment":"Negate a field element","pl":"pub fn neg(a: Fe) callconv(.Inline) Fe {\n    return zero.sub(a);\n}","src":196,"more_decls":null}{"doc_comment":"Return true if a field element is negative","pl":"pub fn isNegative(a: Fe) callconv(.Inline) bool {\n    return (a.toBytes()[0] & 1) != 0;\n}","src":201,"more_decls":null}{"doc_comment":"Conditonally replace a field element with `a` if `c` is positive","pl":"fn cMov(fe: *Fe, a: Fe, c: u64) callconv(.Inline) void","src":206,"more_decls":null}{"doc_comment":"Conditionally swap two pairs of field elements if `c` is positive","pl":"fn cSwap2(a0: *Fe, b0: *Fe, a1: *Fe, b1: *Fe, c: u64) void","src":224,"more_decls":null}{"doc_comment":"Multiply two field elements","pl":"fn mul(a: Fe, b: Fe) callconv(.Inline) Fe","src":268,"more_decls":null}{"doc_comment":"Square a field element","pl":"pub fn sq(a: Fe) callconv(.Inline) Fe {\n    return _sq(a, false);\n}","src":320,"more_decls":null}{"doc_comment":"Square and double a field element","pl":"pub fn sq2(a: Fe) callconv(.Inline) Fe {\n    return _sq(a, true);\n}","src":325,"more_decls":null}{"doc_comment":"Multiply a field element with a small (32-bit) integer","pl":"fn mul32(a: Fe, comptime n: u32) callconv(.Inline) Fe","src":330,"more_decls":null}{"doc_comment":"Compute the inverse of a field element","pl":"fn invert(a: Fe) Fe","src":355,"more_decls":null}{"doc_comment":"Return a^((p-5)/8) = a^(2^252-3)\nUsed to compute square roots since we have p=5 (mod 8); see Cohen and Frey.","pl":"fn pow2523(a: Fe) Fe","src":370,"more_decls":null}{"doc_comment":"Return the absolute value of a field element","pl":"pub fn abs(a: Fe) Fe {\n    var r = a;\n    r.cMov(a.neg(), @boolToInt(a.isNegative()));\n    return r;\n}","src":382,"more_decls":null}{"doc_comment":"Return true if the field element is a square","pl":"fn isSquare(a: Fe) bool","src":389,"more_decls":null}{"doc_comment":"Compute the square root of `x2`, returning `error.NotSquare` if `x2` was not a square","pl":"fn sqrt(x2: Fe) Error!Fe","src":415,"more_decls":null}{"doc_comment":"0","pl":"const zero = Fe{ .limbs = .{ 0, 0, 0, 0, 0 } }","src":16,"more_decls":null}{"doc_comment":"1","pl":"const one = Fe{ .limbs = .{ 1, 0, 0, 0, 0 } }","src":19,"more_decls":null}{"doc_comment":"sqrt(-1)","pl":"const sqrtm1 = Fe{ .limbs = .{ 1718705420411056, 234908883556509, 2233514472574048, 2117202627021982, 765476049583133 } }","src":22,"more_decls":null}{"doc_comment":"The Curve25519 base point","pl":"const curve25519BasePoint = Fe{ .limbs = .{ 9, 0, 0, 0, 0 } }","src":25,"more_decls":null}{"doc_comment":"Edwards25519 d = 37095705934669439343138083508754565189542113879843219016388785533085940283555","pl":"const edwards25519d = Fe{ .limbs = .{ 929955233495203, 466365720129213, 1662059464998953, 2033849074728123, 1442794654840575 } }","src":28,"more_decls":null}{"doc_comment":"Edwards25519 2d","pl":"const edwards25519d2 = Fe{ .limbs = .{ 1859910466990425, 932731440258426, 1072319116312658, 1815898335770999, 633789495995903 } }","src":31,"more_decls":null}{"doc_comment":"Edwards25519 1/sqrt(a-d)","pl":"const edwards25519sqrtamd = Fe{ .limbs = .{ 278908739862762, 821645201101625, 8113234426968, 1777959178193151, 2118520810568447 } }","src":34,"more_decls":null}{"doc_comment":"Edwards25519 1-d^2","pl":"const edwards25519eonemsqd = Fe{ .limbs = .{ 1136626929484150, 1998550399581263, 496427632559748, 118527312129759, 45110755273534 } }","src":37,"more_decls":null}{"doc_comment":"Edwards25519 (d-1)^2","pl":"const edwards25519sqdmone = Fe{ .limbs = .{ 1507062230895904, 1572317787530805, 683053064812840, 317374165784489, 1572899562415810 } }","src":40,"more_decls":null}{"doc_comment":"Edwards25519 sqrt(ad-1) with a = -1 (mod p)","pl":"const edwards25519sqrtadm1 = Fe{ .limbs = .{ 2241493124984347, 425987919032274, 2207028919301688, 1220490630685848, 974799131293748 } }","src":43,"more_decls":null}{"doc_comment":"Edwards25519 A, as a single limb","pl":"const edwards25519a_32: u32 = 486662","src":46,"more_decls":null}{"doc_comment":"Edwards25519 A","pl":"const edwards25519a = Fe{ .limbs = .{ @as(u64, edwards25519a_32), 0, 0, 0, 0 } }","src":49,"more_decls":null}{"doc_comment":"Edwards25519 sqrt(A-2)","pl":"const edwards25519sqrtam2 = Fe{ .limbs = .{ 1693982333959686, 608509411481997, 2235573344831311, 947681270984193, 266558006233600 } }","src":52,"more_decls":null}}]