[{"doc_comment":"Group operations over Edwards25519.","pl":"pub const Edwards25519 = struct ","src":12,"more_decls":{"pl":"x: Fe","src":20,"more_decls":null}{"pl":"y: Fe","src":21,"more_decls":null}{"pl":"z: Fe","src":22,"more_decls":null}{"pl":"t: Fe","src":23,"more_decls":null}{"pl":"is_base: bool = false","src":25,"more_decls":null}{"doc_comment":"Decode an Edwards25519 point from its compressed (Y+sign) coordinates.","pl":"fn fromBytes(s: [encoded_length]u8) Error!Edwards25519","src":28,"more_decls":null}{"doc_comment":"Encode an Edwards25519 point.","pl":"pub fn toBytes(p: Edwards25519) [encoded_length]u8 {\n    const zi = p.z.invert();\n    var s = p.y.mul(zi).toBytes();\n    s[31] ^= @as(u8, @boolToInt(p.x.mul(zi).isNegative())) << 7;\n    return s;\n}","src":50,"more_decls":null}{"doc_comment":"Check that the encoding of a point is canonical.","pl":"pub fn rejectNonCanonical(s: [32]u8) Error!void {\n    return Fe.rejectNonCanonical(s, true);\n}","src":58,"more_decls":null}{"doc_comment":"Reject the neutral element.","pl":"pub fn rejectIdentity(p: Edwards25519) Error!void {\n    if (p.x.isZero()) {\n        return error.IdentityElement;\n    }\n}","src":83,"more_decls":null}{"doc_comment":"Multiply a point by the cofactor","pl":"pub fn clearCofactor(p: Edwards25519) Edwards25519 {\n    return p.dbl().dbl().dbl();\n}","src":90,"more_decls":null}{"doc_comment":"Flip the sign of the X coordinate.","pl":"pub fn neg(p: Edwards25519) callconv(.Inline) Edwards25519 {\n    return .{ .x = p.x.neg(), .y = p.y, .z = p.z, .t = p.t.neg() };\n}","src":95,"more_decls":null}{"doc_comment":"Double an Edwards25519 point.","pl":"fn dbl(p: Edwards25519) Edwards25519","src":100,"more_decls":null}{"doc_comment":"Add two Edwards25519 points.","pl":"fn add(p: Edwards25519, q: Edwards25519) Edwards25519","src":117,"more_decls":null}{"doc_comment":"Substract two Edwards25519 points.","pl":"pub fn sub(p: Edwards25519, q: Edwards25519) Edwards25519 {\n    return p.add(q.neg());\n}","src":136,"more_decls":null}{"doc_comment":"Multiply an Edwards25519 point by a scalar without clamping it.\nReturn error.WeakPublicKey if the resulting point is\nthe identity element.","pl":"fn mul(p: Edwards25519, s: [32]u8) Error!Edwards25519","src":237,"more_decls":null}{"doc_comment":"Multiply an Edwards25519 point by a *PUBLIC* scalar *IN VARIABLE TIME*\nThis can be used for signature verification.","pl":"fn mulPublic(p: Edwards25519, s: [32]u8) Error!Edwards25519","src":248,"more_decls":null}{"doc_comment":"Multiscalar multiplication *IN VARIABLE TIME* for public data\nComputes ps0*ss0 + ps1*ss1 + ps2*ss2... faster than doing many of these operations individually","pl":"fn mulMulti(comptime count: usize, ps: [count]Edwards25519, ss: [count][32]u8) Error!Edwards25519","src":260,"more_decls":null}{"doc_comment":"Multiply an Edwards25519 point by a scalar after \"clamping\" it.\nClamping forces the scalar to be a multiple of the cofactor in\norder to prevent small subgroups attacks.\nThis is strongly recommended for DH operations.\nReturn error.WeakPublicKey if the resulting point is\nthe identity element.","pl":"pub fn clampedMul(p: Edwards25519, s: [32]u8) Error!Edwards25519 {\n    var t: [32]u8 = s;\n    scalar.clamp(&t);\n    return mul(p, t);\n}","src":299,"more_decls":null}{"doc_comment":"Elligator2 map - Returns Montgomery affine coordinates","pl":"fn elligator2(r: Fe) struct { x: Fe, y: Fe, not_square: bool }","src":335,"more_decls":null}{"doc_comment":"Map a 64-bit hash into an Edwards25519 point","pl":"fn fromHash(h: [64]u8) Edwards25519","src":357,"more_decls":null}{"doc_comment":"Hash a context `ctx` and a string `s` into an Edwards25519 point\n\nThis function implements the edwards25519_XMD:SHA-512_ELL2_RO_ and edwards25519_XMD:SHA-512_ELL2_NU_\nmethods from the \"Hashing to Elliptic Curves\" standard document.\n\nAlthough not strictly required by the standard, it is recommended to avoid NUL characters in\nthe context in order to be compatible with other implementations.","pl":"fn fromString(comptime random_oracle: bool, ctx: []const u8, s: []const u8) Edwards25519","src":424,"more_decls":null}{"doc_comment":"Map a 32 bit uniform bit string into an edwards25519 point","pl":"fn fromUniform(r: [32]u8) Edwards25519","src":434,"more_decls":null}{"doc_comment":"The underlying prime field.","pl":"const Fe = @import(\"field.zig\").Fe","src":14,"more_decls":null}{"doc_comment":"Field arithmetic mod the order of the main subgroup.","pl":"const scalar = @import(\"scalar.zig\")","src":16,"more_decls":null}{"doc_comment":"Length in bytes of a compressed representation of a point.","pl":"const encoded_length: usize = 32","src":18,"more_decls":null}{"doc_comment":"The edwards25519 base point.","pl":"const basePoint = Edwards25519{\n        .x = Fe{ .limbs = .{ 3990542415680775, 3398198340507945, 4322667446711068, 2814063955482877, 2839572215813860 } },\n        .y = Fe{ .limbs = .{ 1801439850948184, 1351079888211148, 450359962737049, 900719925474099, 1801439850948198 } },\n        .z = Fe.one,\n        .t = Fe{ .limbs = .{ 1841354044333475, 16398895984059, 755974180946558, 900171276175154, 1821297809914039 } },\n        .is_base = true,\n    }","src":63,"more_decls":null}{"doc_comment":"The edwards25519 neutral element.","pl":"const neutralElement = Edwards25519{\n        .x = Fe{ .limbs = .{ 2251799813685229, 2251799813685247, 2251799813685247, 2251799813685247, 2251799813685247 } },\n        .y = Fe{ .limbs = .{ 1507481815385608, 2223447444246085, 1083941587175919, 2059929906842505, 1581435440146976 } },\n        .z = Fe{ .limbs = .{ 1507481815385608, 2223447444246085, 1083941587175919, 2059929906842505, 1581435440146976 } },\n        .t = Fe{ .limbs = .{ 2251799813685229, 2251799813685247, 2251799813685247, 2251799813685247, 2251799813685247 } },\n        .is_base = false,\n    }","src":72,"more_decls":null}}]