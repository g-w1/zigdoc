[{"doc_comment":"Group operations over Curve25519.","pl":"pub const Curve25519 = struct ","src":9,"more_decls":{"pl":"x: Fe","src":15,"more_decls":null}{"doc_comment":"Decode a Curve25519 point from its compressed (X) coordinates.","pl":"pub fn fromBytes(s: [32]u8) callconv(.Inline) Curve25519 {\n    return .{ .x = Fe.fromBytes(s) };\n}","src":18,"more_decls":null}{"doc_comment":"Encode a Curve25519 point.","pl":"pub fn toBytes(p: Curve25519) callconv(.Inline) [32]u8 {\n    return p.x.toBytes();\n}","src":23,"more_decls":null}{"doc_comment":"Check that the encoding of a Curve25519 point is canonical.","pl":"pub fn rejectNonCanonical(s: [32]u8) Error!void {\n    return Fe.rejectNonCanonical(s, false);\n}","src":31,"more_decls":null}{"doc_comment":"Reject the neutral element.","pl":"pub fn rejectIdentity(p: Curve25519) Error!void {\n    if (p.x.isZero()) {\n        return error.IdentityElement;\n    }\n}","src":36,"more_decls":null}{"doc_comment":"Multiply a point by the cofactor","pl":"pub fn clearCofactor(p: Edwards25519) Edwards25519 {\n    return p.dbl().dbl().dbl();\n}","src":43,"more_decls":null}{"doc_comment":"Multiply a Curve25519 point by a scalar after \"clamping\" it.\nClamping forces the scalar to be a multiple of the cofactor in\norder to prevent small subgroups attacks. This is the standard\nway to use Curve25519 for a DH operation.\nReturn error.IdentityElement if the resulting point is\nthe identity element.","pl":"pub fn clampedMul(p: Curve25519, s: [32]u8) Error!Curve25519 {\n    var t: [32]u8 = s;\n    scalar.clamp(&t);\n    return try ladder(p, t, 255);\n}","src":88,"more_decls":null}{"doc_comment":"Multiply a Curve25519 point by a scalar without clamping it.\nReturn error.IdentityElement if the resulting point is\nthe identity element or error.WeakPublicKey if the public\nkey is a low-order point.","pl":"pub fn mul(p: Curve25519, s: [32]u8) Error!Curve25519 {\n    const cofactor = [_]u8{8} ++ [_]u8{0} ** 31;\n    _ = ladder(p, cofactor, 4) catch |_| return error.WeakPublicKey;\n    return try ladder(p, s, 256);\n}","src":98,"more_decls":null}{"doc_comment":"Compute the Curve25519 equivalent to an Edwards25519 point.","pl":"pub fn fromEdwards25519(p: std.crypto.ecc.Edwards25519) Error!Curve25519 {\n    try p.clearCofactor().rejectIdentity();\n    const one = std.crypto.ecc.Edwards25519.Fe.one;\n    const x = one.add(p.y).mul(one.sub(p.y).invert()); // xMont=(1+yEd)/(1-yEd)\n    return Curve25519{ .x = x };\n}","src":105,"more_decls":null}{"doc_comment":"The underlying prime field.","pl":"const Fe = @import(\"field.zig\").Fe","src":11,"more_decls":null}{"doc_comment":"Field arithmetic mod the order of the main subgroup.","pl":"const scalar = @import(\"scalar.zig\")","src":13,"more_decls":null}{"doc_comment":"The Curve25519 base point.","pl":"const basePoint = Curve25519{ .x = Fe.curve25519BasePoint }","src":28,"more_decls":null}}]