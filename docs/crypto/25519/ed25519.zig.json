[{"doc_comment":"Ed25519 (EdDSA) signatures.","pl":"pub const Ed25519 = struct ","src":14,"more_decls":{"doc_comment":"An Ed25519 key pair.","pl":"pub const KeyPair = struct ","src":29,"more_decls":{"doc_comment":"Public part.","pl":"public_key: [public_length]u8","src":31,"more_decls":null}{"doc_comment":"Secret part. What we expose as a secret key is, under the hood, the concatenation of the seed and the public key.","pl":"secret_key: [secret_length]u8","src":33,"more_decls":null}{"doc_comment":"Derive a key pair from an optional secret seed.\n\nAs in RFC 8032, an Ed25519 public key is generated by hashing\nthe secret key using the SHA-512 function, and interpreting the\nbit-swapped, clamped lower-half of the output as the secret scalar.\n\nFor this reason, an EdDSA secret key is commonly called a seed,\nfrom which the actual secret is derived.","pl":"fn create(seed: ?[seed_length]u8) Error!KeyPair","src":43,"more_decls":null}{"doc_comment":"Create a KeyPair from a secret key.","pl":"pub fn fromSecretKey(secret_key: [secret_length]u8) KeyPair {\n    return KeyPair{\n        .secret_key = secret_key,\n        .public_key = secret_key[seed_length..].*,\n    };\n}","src":63,"more_decls":null}}{"doc_comment":"A (signature, message, public_key) tuple for batch verification","pl":"pub const BatchElement = struct ","src":141,"more_decls":{"pl":"sig: [signature_length]u8","src":142,"more_decls":null}{"pl":"msg: []const u8","src":143,"more_decls":null}{"pl":"public_key: [public_length]u8","src":144,"more_decls":null}}{"doc_comment":"Sign a message using a key pair, and optional random noise.\nHaving noise creates non-standard, non-deterministic signatures,\nbut has been proven to increase resilience against fault attacks.","pl":"fn sign(msg: []const u8, key_pair: KeyPair, noise: ?[noise_length]u8) Error![signature_length]u8","src":74,"more_decls":null}{"doc_comment":"Verify an Ed25519 signature given a message and a public key.\nReturns error.SignatureVerificationFailed is the signature verification failed.","pl":"fn verify(sig: [signature_length]u8, msg: []const u8, public_key: [public_length]u8) Error!void","src":115,"more_decls":null}{"doc_comment":"Verify several signatures in a single operation, much faster than verifying signatures one-by-one","pl":"fn verifyBatch(comptime count: usize, signature_batch: [count]BatchElement) Error!void","src":148,"more_decls":null}{"doc_comment":"The underlying elliptic curve.","pl":"const Curve = @import(\"edwards25519.zig\").Edwards25519","src":16,"more_decls":null}{"doc_comment":"Length (in bytes) of a seed required to create a key pair.","pl":"const seed_length = 32","src":18,"more_decls":null}{"doc_comment":"Length (in bytes) of a compressed secret key.","pl":"const secret_length = 64","src":20,"more_decls":null}{"doc_comment":"Length (in bytes) of a compressed public key.","pl":"const public_length = 32","src":22,"more_decls":null}{"doc_comment":"Length (in bytes) of a signature.","pl":"const signature_length = 64","src":24,"more_decls":null}{"doc_comment":"Length (in bytes) of optional random bytes, for non-deterministic signatures.","pl":"const noise_length = 32","src":26,"more_decls":null}}]