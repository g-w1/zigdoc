[{"doc_comment":"A single AES block.","pl":"pub const Block = struct ","src":14,"more_decls":{"doc_comment":"Internal representation of a block.","pl":"repr: BlockVec","src":18,"more_decls":null}{"doc_comment":"Perform operations on multiple blocks in parallel.","pl":"pub const parallel = struct ","src":101,"more_decls":{"doc_comment":"Encrypt multiple blocks in parallel, each their own round key.","pl":"fn encryptParallel(comptime count: usize, blocks: [count]Block, round_keys: [count]Block) callconv(.Inline) [count]Block","src":116,"more_decls":null}{"doc_comment":"Decrypt multiple blocks in parallel, each their own round key.","pl":"fn decryptParallel(comptime count: usize, blocks: [count]Block, round_keys: [count]Block) callconv(.Inline) [count]Block","src":126,"more_decls":null}{"doc_comment":"Encrypt multiple blocks in parallel with the same round key.","pl":"fn encryptWide(comptime count: usize, blocks: [count]Block, round_key: Block) callconv(.Inline) [count]Block","src":136,"more_decls":null}{"doc_comment":"Decrypt multiple blocks in parallel with the same round key.","pl":"fn decryptWide(comptime count: usize, blocks: [count]Block, round_key: Block) callconv(.Inline) [count]Block","src":146,"more_decls":null}{"doc_comment":"Encrypt multiple blocks in parallel with the same last round key.","pl":"fn encryptLastWide(comptime count: usize, blocks: [count]Block, round_key: Block) callconv(.Inline) [count]Block","src":156,"more_decls":null}{"doc_comment":"Decrypt multiple blocks in parallel with the same last round key.","pl":"fn decryptLastWide(comptime count: usize, blocks: [count]Block, round_key: Block) callconv(.Inline) [count]Block","src":166,"more_decls":null}{"doc_comment":"The recommended number of AES encryption/decryption to perform in parallel for the chosen implementation.","pl":"const optimal_parallel_blocks = switch (std.Target.current.cpu.model) {\n            &cpu.westmere => 6,\n            &cpu.sandybridge, &cpu.ivybridge => 8,\n            &cpu.haswell, &cpu.broadwell => 7,\n            &cpu.cannonlake, &cpu.skylake, &cpu.skylake_avx512 => 4,\n            &cpu.icelake_client, &cpu.icelake_server => 6,\n            &cpu.znver1, &cpu.znver2 => 8,\n            else => 8,\n        }","src":105,"more_decls":null}}{"doc_comment":"Convert a byte sequence into an internal representation.","pl":"pub fn fromBytes(bytes: *const [16]u8) callconv(.Inline) Block {\n    const repr = mem.bytesToValue(BlockVec, bytes);\n    return Block{ .repr = repr };\n}","src":21,"more_decls":null}{"doc_comment":"Convert the internal representation of a block into a byte sequence.","pl":"pub fn toBytes(block: Block) callconv(.Inline) [16]u8 {\n    return mem.toBytes(block.repr);\n}","src":27,"more_decls":null}{"doc_comment":"XOR the block with a byte sequence.","pl":"pub fn xorBytes(block: Block, bytes: *const [16]u8) callconv(.Inline) [16]u8 {\n    const x = block.repr ^ fromBytes(bytes).repr;\n    return mem.toBytes(x);\n}","src":32,"more_decls":null}{"doc_comment":"Encrypt a block with a round key.","pl":"fn encrypt(block: Block, round_key: Block) callconv(.Inline) Block","src":38,"more_decls":null}{"doc_comment":"Encrypt a block with the last round key.","pl":"fn encryptLast(block: Block, round_key: Block) callconv(.Inline) Block","src":50,"more_decls":null}{"doc_comment":"Decrypt a block with a round key.","pl":"fn decrypt(block: Block, inv_round_key: Block) callconv(.Inline) Block","src":62,"more_decls":null}{"doc_comment":"Decrypt a block with the last round key.","pl":"fn decryptLast(block: Block, inv_round_key: Block) callconv(.Inline) Block","src":74,"more_decls":null}{"doc_comment":"Apply the bitwise XOR operation to the content of two blocks.","pl":"pub fn xorBlocks(block1: Block, block2: Block) callconv(.Inline) Block {\n    return Block{ .repr = block1.repr ^ block2.repr };\n}","src":86,"more_decls":null}{"doc_comment":"Apply the bitwise AND operation to the content of two blocks.","pl":"pub fn andBlocks(block1: Block, block2: Block) callconv(.Inline) Block {\n    return Block{ .repr = block1.repr & block2.repr };\n}","src":91,"more_decls":null}{"doc_comment":"Apply the bitwise OR operation to the content of two blocks.","pl":"pub fn orBlocks(block1: Block, block2: Block) callconv(.Inline) Block {\n    return Block{ .repr = block1.repr | block2.repr };\n}","src":96,"more_decls":null}{"pl":"const block_length: usize = 16","src":15,"more_decls":null}}{"doc_comment":"AES-128 with the standard key schedule.","pl":"pub const Aes128 = struct ","src":401,"more_decls":{"doc_comment":"Create a new context for encryption.","pl":"pub fn initEnc(key: [key_bits / 8]u8) AesEncryptCtx(Aes128) {\n    return AesEncryptCtx(Aes128).init(key);\n}","src":407,"more_decls":null}{"doc_comment":"Create a new context for decryption.","pl":"pub fn initDec(key: [key_bits / 8]u8) AesDecryptCtx(Aes128) {\n    return AesDecryptCtx(Aes128).init(key);\n}","src":412,"more_decls":null}{"pl":"const key_bits: usize = 128","src":402,"more_decls":null}{"pl":"const rounds = ((key_bits - 64) / 32 + 8)","src":403,"more_decls":null}{"pl":"const block = Block","src":404,"more_decls":null}}{"doc_comment":"AES-256 with the standard key schedule.","pl":"pub const Aes256 = struct ","src":418,"more_decls":{"doc_comment":"Create a new context for encryption.","pl":"pub fn initEnc(key: [key_bits / 8]u8) AesEncryptCtx(Aes256) {\n    return AesEncryptCtx(Aes256).init(key);\n}","src":424,"more_decls":null}{"doc_comment":"Create a new context for decryption.","pl":"pub fn initDec(key: [key_bits / 8]u8) AesDecryptCtx(Aes256) {\n    return AesDecryptCtx(Aes256).init(key);\n}","src":429,"more_decls":null}{"pl":"const key_bits: usize = 256","src":419,"more_decls":null}{"pl":"const rounds = ((key_bits - 64) / 32 + 8)","src":420,"more_decls":null}{"pl":"const block = Block","src":421,"more_decls":null}}{"doc_comment":"A context to perform encryption using the standard AES key schedule.","pl":"fn AesEncryptCtx(comptime Aes: type) type","sub_container_type":"struct ","src":255,"more_decls":{"pl":"key_schedule: KeySchedule(Aes)","src":263,"more_decls":null}{"doc_comment":"Create a new encryption context with the given key.","pl":"fn init(key: [Aes.key_bits / 8]u8) Self","src":266,"more_decls":null}{"doc_comment":"Encrypt a single block.","pl":"fn encrypt(ctx: Self, dst: *[16]u8, src: *const [16]u8) void","src":280,"more_decls":null}{"doc_comment":"Encrypt+XOR a single block.","pl":"fn xor(ctx: Self, dst: *[16]u8, src: *const [16]u8, counter: [16]u8) void","src":292,"more_decls":null}{"doc_comment":"Encrypt multiple blocks, possibly leveraging parallelization.","pl":"fn encryptWide(ctx: Self, comptime count: usize, dst: *[16 * count]u8, src: *const [16 * count]u8) void","src":304,"more_decls":null}{"doc_comment":"Encrypt+XOR multiple blocks, possibly leveraging parallelization.","pl":"fn xorWide(ctx: Self, comptime count: usize, dst: *[16 * count]u8, src: *const [16 * count]u8, counters: [16 * count]u8) void","src":323,"more_decls":null}{"pl":"const block = Aes.block","src":261,"more_decls":null}{"pl":"const block_length = block.block_length","src":262,"more_decls":null}}{"doc_comment":"A context to perform decryption using the standard AES key schedule.","pl":"fn AesDecryptCtx(comptime Aes: type) type","sub_container_type":"struct ","src":344,"more_decls":{"pl":"key_schedule: KeySchedule(Aes)","src":352,"more_decls":null}{"doc_comment":"Create a decryption context from an existing encryption context.","pl":"pub fn initFromEnc(ctx: AesEncryptCtx(Aes)) Self {\n    return Self{\n        .key_schedule = ctx.key_schedule.invert(),\n    };\n}","src":355,"more_decls":null}{"doc_comment":"Create a new decryption context with the given key.","pl":"pub fn init(key: [Aes.key_bits / 8]u8) Self {\n    const enc_ctx = AesEncryptCtx(Aes).init(key);\n    return initFromEnc(enc_ctx);\n}","src":362,"more_decls":null}{"doc_comment":"Decrypt a single block.","pl":"fn decrypt(ctx: Self, dst: *[16]u8, src: *const [16]u8) void","src":368,"more_decls":null}{"doc_comment":"Decrypt multiple blocks, possibly leveraging parallelization.","pl":"fn decryptWide(ctx: Self, comptime count: usize, dst: *[16 * count]u8, src: *const [16 * count]u8) void","src":380,"more_decls":null}{"pl":"const block = Aes.block","src":350,"more_decls":null}{"pl":"const block_length = block.block_length","src":351,"more_decls":null}}]