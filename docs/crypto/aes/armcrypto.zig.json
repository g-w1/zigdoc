[{"doc_comment":"A single AES block.","pl":"pub const Block = struct ","src":14,"more_decls":{"doc_comment":"Internal representation of a block.","pl":"repr: BlockVec","src":18,"more_decls":null}{"doc_comment":"Perform operations on multiple blocks in parallel.","pl":"pub const parallel = struct ","src":117,"more_decls":{"doc_comment":"Encrypt multiple blocks in parallel, each their own round key.","pl":"fn encryptParallel(comptime count: usize, blocks: [count]Block, round_keys: [count]Block) callconv(.Inline) [count]Block","src":122,"more_decls":null}{"doc_comment":"Decrypt multiple blocks in parallel, each their own round key.","pl":"fn decryptParallel(comptime count: usize, blocks: [count]Block, round_keys: [count]Block) callconv(.Inline) [count]Block","src":132,"more_decls":null}{"doc_comment":"Encrypt multiple blocks in parallel with the same round key.","pl":"fn encryptWide(comptime count: usize, blocks: [count]Block, round_key: Block) callconv(.Inline) [count]Block","src":142,"more_decls":null}{"doc_comment":"Decrypt multiple blocks in parallel with the same round key.","pl":"fn decryptWide(comptime count: usize, blocks: [count]Block, round_key: Block) callconv(.Inline) [count]Block","src":152,"more_decls":null}{"doc_comment":"Encrypt multiple blocks in parallel with the same last round key.","pl":"fn encryptLastWide(comptime count: usize, blocks: [count]Block, round_key: Block) callconv(.Inline) [count]Block","src":162,"more_decls":null}{"doc_comment":"Decrypt multiple blocks in parallel with the same last round key.","pl":"fn decryptLastWide(comptime count: usize, blocks: [count]Block, round_key: Block) callconv(.Inline) [count]Block","src":172,"more_decls":null}{"doc_comment":"The recommended number of AES encryption/decryption to perform in parallel for the chosen implementation.","pl":"const optimal_parallel_blocks = 8","src":119,"more_decls":null}}{"doc_comment":"Convert a byte sequence into an internal representation.","pl":"pub fn fromBytes(bytes: *const [16]u8) callconv(.Inline) Block {\n    const repr = mem.bytesToValue(BlockVec, bytes);\n    return Block{ .repr = repr };\n}","src":21,"more_decls":null}{"doc_comment":"Convert the internal representation of a block into a byte sequence.","pl":"pub fn toBytes(block: Block) callconv(.Inline) [16]u8 {\n    return mem.toBytes(block.repr);\n}","src":27,"more_decls":null}{"doc_comment":"XOR the block with a byte sequence.","pl":"pub fn xorBytes(block: Block, bytes: *const [16]u8) callconv(.Inline) [16]u8 {\n    const x = block.repr ^ fromBytes(bytes).repr;\n    return mem.toBytes(x);\n}","src":32,"more_decls":null}{"doc_comment":"Encrypt a block with a round key.","pl":"fn encrypt(block: Block, round_key: Block) callconv(.Inline) Block","src":40,"more_decls":null}{"doc_comment":"Encrypt a block with the last round key.","pl":"fn encryptLast(block: Block, round_key: Block) callconv(.Inline) Block","src":56,"more_decls":null}{"doc_comment":"Decrypt a block with a round key.","pl":"fn decrypt(block: Block, inv_round_key: Block) callconv(.Inline) Block","src":71,"more_decls":null}{"doc_comment":"Decrypt a block with the last round key.","pl":"fn decryptLast(block: Block, inv_round_key: Block) callconv(.Inline) Block","src":87,"more_decls":null}{"doc_comment":"Apply the bitwise XOR operation to the content of two blocks.","pl":"pub fn xorBlocks(block1: Block, block2: Block) callconv(.Inline) Block {\n    return Block{ .repr = block1.repr ^ block2.repr };\n}","src":102,"more_decls":null}{"doc_comment":"Apply the bitwise AND operation to the content of two blocks.","pl":"pub fn andBlocks(block1: Block, block2: Block) callconv(.Inline) Block {\n    return Block{ .repr = block1.repr & block2.repr };\n}","src":107,"more_decls":null}{"doc_comment":"Apply the bitwise OR operation to the content of two blocks.","pl":"pub fn orBlocks(block1: Block, block2: Block) callconv(.Inline) Block {\n    return Block{ .repr = block1.repr | block2.repr };\n}","src":112,"more_decls":null}{"pl":"const block_length: usize = 16","src":15,"more_decls":null}}{"doc_comment":"AES-128 with the standard key schedule.","pl":"pub const Aes128 = struct ","src":452,"more_decls":{"doc_comment":"Create a new context for encryption.","pl":"pub fn initEnc(key: [key_bits / 8]u8) AesEncryptCtx(Aes128) {\n    return AesEncryptCtx(Aes128).init(key);\n}","src":458,"more_decls":null}{"doc_comment":"Create a new context for decryption.","pl":"pub fn initDec(key: [key_bits / 8]u8) AesDecryptCtx(Aes128) {\n    return AesDecryptCtx(Aes128).init(key);\n}","src":463,"more_decls":null}{"pl":"const key_bits: usize = 128","src":453,"more_decls":null}{"pl":"const rounds = ((key_bits - 64) / 32 + 8)","src":454,"more_decls":null}{"pl":"const block = Block","src":455,"more_decls":null}}{"doc_comment":"AES-256 with the standard key schedule.","pl":"pub const Aes256 = struct ","src":469,"more_decls":{"doc_comment":"Create a new context for encryption.","pl":"pub fn initEnc(key: [key_bits / 8]u8) AesEncryptCtx(Aes256) {\n    return AesEncryptCtx(Aes256).init(key);\n}","src":475,"more_decls":null}{"doc_comment":"Create a new context for decryption.","pl":"pub fn initDec(key: [key_bits / 8]u8) AesDecryptCtx(Aes256) {\n    return AesDecryptCtx(Aes256).init(key);\n}","src":480,"more_decls":null}{"pl":"const key_bits: usize = 256","src":470,"more_decls":null}{"pl":"const rounds = ((key_bits - 64) / 32 + 8)","src":471,"more_decls":null}{"pl":"const block = Block","src":472,"more_decls":null}}{"doc_comment":"A context to perform encryption using the standard AES key schedule.","pl":"fn AesEncryptCtx(comptime Aes: type) type","sub_container_type":"struct ","src":306,"more_decls":{"pl":"key_schedule: KeySchedule(Aes)","src":314,"more_decls":null}{"doc_comment":"Create a new encryption context with the given key.","pl":"fn init(key: [Aes.key_bits / 8]u8) Self","src":317,"more_decls":null}{"doc_comment":"Encrypt a single block.","pl":"fn encrypt(ctx: Self, dst: *[16]u8, src: *const [16]u8) void","src":331,"more_decls":null}{"doc_comment":"Encrypt+XOR a single block.","pl":"fn xor(ctx: Self, dst: *[16]u8, src: *const [16]u8, counter: [16]u8) void","src":343,"more_decls":null}{"doc_comment":"Encrypt multiple blocks, possibly leveraging parallelization.","pl":"fn encryptWide(ctx: Self, comptime count: usize, dst: *[16 * count]u8, src: *const [16 * count]u8) void","src":355,"more_decls":null}{"doc_comment":"Encrypt+XOR multiple blocks, possibly leveraging parallelization.","pl":"fn xorWide(ctx: Self, comptime count: usize, dst: *[16 * count]u8, src: *const [16 * count]u8, counters: [16 * count]u8) void","src":374,"more_decls":null}{"pl":"const block = Aes.block","src":312,"more_decls":null}{"pl":"const block_length = block.block_length","src":313,"more_decls":null}}{"doc_comment":"A context to perform decryption using the standard AES key schedule.","pl":"fn AesDecryptCtx(comptime Aes: type) type","sub_container_type":"struct ","src":395,"more_decls":{"pl":"key_schedule: KeySchedule(Aes)","src":403,"more_decls":null}{"doc_comment":"Create a decryption context from an existing encryption context.","pl":"pub fn initFromEnc(ctx: AesEncryptCtx(Aes)) Self {\n    return Self{\n        .key_schedule = ctx.key_schedule.invert(),\n    };\n}","src":406,"more_decls":null}{"doc_comment":"Create a new decryption context with the given key.","pl":"pub fn init(key: [Aes.key_bits / 8]u8) Self {\n    const enc_ctx = AesEncryptCtx(Aes).init(key);\n    return initFromEnc(enc_ctx);\n}","src":413,"more_decls":null}{"doc_comment":"Decrypt a single block.","pl":"fn decrypt(ctx: Self, dst: *[16]u8, src: *const [16]u8) void","src":419,"more_decls":null}{"doc_comment":"Decrypt multiple blocks, possibly leveraging parallelization.","pl":"fn decryptWide(ctx: Self, comptime count: usize, dst: *[16 * count]u8, src: *const [16 * count]u8) void","src":431,"more_decls":null}{"pl":"const block = Aes.block","src":401,"more_decls":null}{"pl":"const block_length = block.block_length","src":402,"more_decls":null}}]