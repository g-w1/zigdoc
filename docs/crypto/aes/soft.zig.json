[{"doc_comment":"A single AES block.","pl":"pub const Block = struct ","src":13,"more_decls":{"doc_comment":"Internal representation of a block.","pl":"repr: BlockVec align(16)","src":17,"more_decls":null}{"doc_comment":"Perform operations on multiple blocks in parallel.","pl":"pub const parallel = struct ","src":158,"more_decls":{"doc_comment":"Encrypt multiple blocks in parallel, each their own round key.","pl":"fn encryptParallel(comptime count: usize, blocks: [count]Block, round_keys: [count]Block) [count]Block","src":163,"more_decls":null}{"doc_comment":"Decrypt multiple blocks in parallel, each their own round key.","pl":"fn decryptParallel(comptime count: usize, blocks: [count]Block, round_keys: [count]Block) [count]Block","src":173,"more_decls":null}{"doc_comment":"Encrypt multiple blocks in parallel with the same round key.","pl":"fn encryptWide(comptime count: usize, blocks: [count]Block, round_key: Block) [count]Block","src":183,"more_decls":null}{"doc_comment":"Decrypt multiple blocks in parallel with the same round key.","pl":"fn decryptWide(comptime count: usize, blocks: [count]Block, round_key: Block) [count]Block","src":193,"more_decls":null}{"doc_comment":"Encrypt multiple blocks in parallel with the same last round key.","pl":"fn encryptLastWide(comptime count: usize, blocks: [count]Block, round_key: Block) [count]Block","src":203,"more_decls":null}{"doc_comment":"Decrypt multiple blocks in parallel with the same last round key.","pl":"fn decryptLastWide(comptime count: usize, blocks: [count]Block, round_key: Block) [count]Block","src":213,"more_decls":null}{"doc_comment":"The recommended number of AES encryption/decryption to perform in parallel for the chosen implementation.","pl":"const optimal_parallel_blocks = 1","src":160,"more_decls":null}}{"doc_comment":"Convert a byte sequence into an internal representation.","pl":"fn fromBytes(bytes: *const [16]u8) callconv(.Inline) Block","src":20,"more_decls":null}{"doc_comment":"Convert the internal representation of a block into a byte sequence.","pl":"fn toBytes(block: Block) callconv(.Inline) [16]u8","src":29,"more_decls":null}{"doc_comment":"XOR the block with a byte sequence.","pl":"fn xorBytes(block: Block, bytes: *const [16]u8) callconv(.Inline) [16]u8","src":39,"more_decls":null}{"doc_comment":"Encrypt a block with a round key.","pl":"fn encrypt(block: Block, round_key: Block) callconv(.Inline) Block","src":50,"more_decls":null}{"doc_comment":"Encrypt a block with the last round key.","pl":"fn encryptLast(block: Block, round_key: Block) callconv(.Inline) Block","src":67,"more_decls":null}{"doc_comment":"Decrypt a block with a round key.","pl":"fn decrypt(block: Block, round_key: Block) callconv(.Inline) Block","src":89,"more_decls":null}{"doc_comment":"Decrypt a block with the last round key.","pl":"fn decryptLast(block: Block, round_key: Block) callconv(.Inline) Block","src":106,"more_decls":null}{"doc_comment":"Apply the bitwise XOR operation to the content of two blocks.","pl":"fn xorBlocks(block1: Block, block2: Block) callconv(.Inline) Block","src":128,"more_decls":null}{"doc_comment":"Apply the bitwise AND operation to the content of two blocks.","pl":"fn andBlocks(block1: Block, block2: Block) callconv(.Inline) Block","src":138,"more_decls":null}{"doc_comment":"Apply the bitwise OR operation to the content of two blocks.","pl":"fn orBlocks(block1: Block, block2: Block) callconv(.Inline) Block","src":148,"more_decls":null}{"pl":"const block_length: usize = 16","src":14,"more_decls":null}}{"doc_comment":"AES-128 with the standard key schedule.","pl":"pub const Aes128 = struct ","src":391,"more_decls":{"doc_comment":"Create a new context for encryption.","pl":"pub fn initEnc(key: [key_bits / 8]u8) AesEncryptCtx(Aes128) {\n    return AesEncryptCtx(Aes128).init(key);\n}","src":397,"more_decls":null}{"doc_comment":"Create a new context for decryption.","pl":"pub fn initDec(key: [key_bits / 8]u8) AesDecryptCtx(Aes128) {\n    return AesDecryptCtx(Aes128).init(key);\n}","src":402,"more_decls":null}{"pl":"const key_bits: usize = 128","src":392,"more_decls":null}{"pl":"const rounds = ((key_bits - 64) / 32 + 8)","src":393,"more_decls":null}{"pl":"const block = Block","src":394,"more_decls":null}}{"doc_comment":"AES-256 with the standard key schedule.","pl":"pub const Aes256 = struct ","src":408,"more_decls":{"doc_comment":"Create a new context for encryption.","pl":"pub fn initEnc(key: [key_bits / 8]u8) AesEncryptCtx(Aes256) {\n    return AesEncryptCtx(Aes256).init(key);\n}","src":414,"more_decls":null}{"doc_comment":"Create a new context for decryption.","pl":"pub fn initDec(key: [key_bits / 8]u8) AesDecryptCtx(Aes256) {\n    return AesDecryptCtx(Aes256).init(key);\n}","src":419,"more_decls":null}{"pl":"const key_bits: usize = 256","src":409,"more_decls":null}{"pl":"const rounds = ((key_bits - 64) / 32 + 8)","src":410,"more_decls":null}{"pl":"const block = Block","src":411,"more_decls":null}}{"doc_comment":"A context to perform encryption using the standard AES key schedule.","pl":"fn AesEncryptCtx(comptime Aes: type) type","sub_container_type":"struct ","src":284,"more_decls":{"pl":"key_schedule: KeySchedule(Aes)","src":292,"more_decls":null}{"doc_comment":"Create a new encryption context with the given key.","pl":"pub fn init(key: [Aes.key_bits / 8]u8) Self {\n    const key_schedule = KeySchedule(Aes).expandKey(key);\n    return Self{\n        .key_schedule = key_schedule,\n    };\n}","src":295,"more_decls":null}{"doc_comment":"Encrypt a single block.","pl":"fn encrypt(ctx: Self, dst: *[16]u8, src: *const [16]u8) void","src":303,"more_decls":null}{"doc_comment":"Encrypt+XOR a single block.","pl":"fn xor(ctx: Self, dst: *[16]u8, src: *const [16]u8, counter: [16]u8) void","src":315,"more_decls":null}{"doc_comment":"Encrypt multiple blocks, possibly leveraging parallelization.","pl":"pub fn encryptWide(ctx: Self, comptime count: usize, dst: *[16 * count]u8, src: *const [16 * count]u8) void {\n    var i: usize = 0;\n    while (i < count) : (i += 1) {\n        ctx.encrypt(dst[16 * i .. 16 * i + 16][0..16], src[16 * i .. 16 * i + 16][0..16]);\n    }\n}","src":327,"more_decls":null}{"doc_comment":"Encrypt+XOR multiple blocks, possibly leveraging parallelization.","pl":"pub fn xorWide(ctx: Self, comptime count: usize, dst: *[16 * count]u8, src: *const [16 * count]u8, counters: [16 * count]u8) void {\n    var i: usize = 0;\n    while (i < count) : (i += 1) {\n        ctx.xor(dst[16 * i .. 16 * i + 16][0..16], src[16 * i .. 16 * i + 16][0..16], counters[16 * i .. 16 * i + 16][0..16].*);\n    }\n}","src":335,"more_decls":null}{"pl":"const block = Aes.block","src":290,"more_decls":null}{"pl":"const block_length = block.block_length","src":291,"more_decls":null}}{"doc_comment":"A context to perform decryption using the standard AES key schedule.","pl":"fn AesDecryptCtx(comptime Aes: type) type","sub_container_type":"struct ","src":345,"more_decls":{"pl":"key_schedule: KeySchedule(Aes)","src":353,"more_decls":null}{"doc_comment":"Create a decryption context from an existing encryption context.","pl":"pub fn initFromEnc(ctx: AesEncryptCtx(Aes)) Self {\n    return Self{\n        .key_schedule = ctx.key_schedule.invert(),\n    };\n}","src":356,"more_decls":null}{"doc_comment":"Create a new decryption context with the given key.","pl":"pub fn init(key: [Aes.key_bits / 8]u8) Self {\n    const enc_ctx = AesEncryptCtx(Aes).init(key);\n    return initFromEnc(enc_ctx);\n}","src":363,"more_decls":null}{"doc_comment":"Decrypt a single block.","pl":"fn decrypt(ctx: Self, dst: *[16]u8, src: *const [16]u8) void","src":369,"more_decls":null}{"doc_comment":"Decrypt multiple blocks, possibly leveraging parallelization.","pl":"pub fn decryptWide(ctx: Self, comptime count: usize, dst: *[16 * count]u8, src: *const [16 * count]u8) void {\n    var i: usize = 0;\n    while (i < count) : (i += 1) {\n        ctx.decrypt(dst[16 * i .. 16 * i + 16][0..16], src[16 * i .. 16 * i + 16][0..16]);\n    }\n}","src":381,"more_decls":null}{"pl":"const block = Aes.block","src":351,"more_decls":null}{"pl":"const block_length = block.block_length","src":352,"more_decls":null}}]