[{"pl":"pub const State = struct ","src":24,"more_decls":{"pl":"data: [BLOCKBYTES / 4]u32 align(16)","src":28,"more_decls":null}{"pl":"fn init(initial_state: [State.BLOCKBYTES]u8) Self","src":32,"more_decls":null}{"doc_comment":"TODO follow the span() convention instead of having this and `toSliceConst`","pl":"pub fn toSlice(self: *Self) *[BLOCKBYTES]u8 {\n    return mem.asBytes(&self.data);\n}","src":42,"more_decls":null}{"doc_comment":"TODO follow the span() convention instead of having this and `toSlice`","pl":"pub fn toSliceConst(self: *const Self) *const [BLOCKBYTES]u8 {\n    return mem.asBytes(&self.data);\n}","src":47,"more_decls":null}{"pl":"fn squeeze(self: *Self, out: []u8) void","src":167,"more_decls":null}{"pl":"const BLOCKBYTES = 48","src":25,"more_decls":null}{"pl":"const RATE = 16","src":26,"more_decls":null}{"pl":"const permute = if (std.Target.current.cpu.arch == .x86_64) impl: {\n        break :impl permute_vectorized;\n    } else if (std.builtin.mode == .ReleaseSmall) impl: {\n        break :impl permute_small;\n    } else impl: {\n        break :impl permute_unrolled;\n    }","src":159,"more_decls":null}}{"pl":"pub const Hash = struct ","src":210,"more_decls":{"pl":"state: State","src":211,"more_decls":null}{"pl":"buf_off: usize","src":212,"more_decls":null}{"pl":"pub const Options = struct ","src":216,"more_decls":}{"pl":"pub fn init(options: Options) Self {\n    return Self{\n        .state = State{ .data = [_]u32{0} ** (State.BLOCKBYTES / 4) },\n        .buf_off = 0,\n    };\n}","src":220,"more_decls":null}{"doc_comment":"Also known as 'absorb'","pl":"fn update(self: *Self, data: []const u8) void","src":228,"more_decls":null}{"doc_comment":"Finish the current hashing operation, writing the hash to `out`\n\nFrom 4.9 \"Application to hashing\"\nBy default, Gimli-Hash provides a fixed-length output of 32 bytes\n(the concatenation of two 16-byte blocks).  However, Gimli-Hash can\nbe used as an “extendable one-way function” (XOF).","pl":"fn final(self: *Self, out: []u8) void","src":252,"more_decls":null}{"pl":"const block_length = State.RATE","src":214,"more_decls":null}{"pl":"const digest_length = 32","src":215,"more_decls":null}}{"pl":"pub const Aead = struct ","src":295,"more_decls":{"doc_comment":"c: ciphertext: output buffer should be of size m.len\ntag: authentication tag: output MAC\nm: message\nad: Associated Data\nnpub: public nonce\nk: private key","pl":"fn encrypt(c: []u8, tag: *[tag_length]u8, m: []const u8, ad: []const u8, npub: [nonce_length]u8, k: [key_length]u8) void","src":349,"more_decls":null}{"doc_comment":"m: message: output buffer should be of size c.len\nc: ciphertext\ntag: authentication tag\nad: Associated Data\nnpub: public nonce\nk: private key\nNOTE: the check of the authentication tag is currently not done in constant time","pl":"fn decrypt(m: []u8, c: []const u8, tag: [tag_length]u8, ad: []const u8, npub: [nonce_length]u8, k: [key_length]u8) Error!void","src":395,"more_decls":null}{"pl":"const tag_length = State.RATE","src":296,"more_decls":null}{"pl":"const nonce_length = 16","src":297,"more_decls":null}{"pl":"const key_length = 32","src":298,"more_decls":null}}{"pl":"pub fn hash(out: []u8, in: []const u8, options: Hash.Options) void {\n    var st = Hash.init(options);\n    st.update(in);\n    st.final(out);\n}","src":264,"more_decls":null}]