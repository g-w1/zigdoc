[{"doc_comment":"SipHash function with 64-bit output.\n\nRecommended parameters are:\n- (c_rounds=4, d_rounds=8) for conservative security; regular hash functions such as BLAKE2 or BLAKE3 are usually a better alternative.\n- (c_rounds=2, d_rounds=4) standard parameters.\n- (c_rounds=1, d_rounds=3) reduced-round function. Faster, no known implications on its practical security level.\n- (c_rounds=1, d_rounds=2) fastest option, but the output may be distinguishable from random data with related keys or non-uniform input - not suitable as a PRF.\n\nSipHash is not a traditional hash function. If the input includes untrusted content, a secret key is absolutely necessary.\nAnd due to its small output size, collisions in SipHash64 can be found with an exhaustive search.","pl":"pub fn SipHash64(comptime c_rounds: usize, comptime d_rounds: usize) type {\n    return SipHash(u64, c_rounds, d_rounds);\n}","src":29,"more_decls":null}{"doc_comment":"SipHash function with 128-bit output.\n\nRecommended parameters are:\n- (c_rounds=4, d_rounds=8) for conservative security; regular hash functions such as BLAKE2 or BLAKE3 are usually a better alternative.\n- (c_rounds=2, d_rounds=4) standard parameters.\n- (c_rounds=1, d_rounds=4) reduced-round function. Recommended to hash very short, similar strings, when a 128-bit PRF output is still required.\n- (c_rounds=1, d_rounds=3) reduced-round function. Faster, no known implications on its practical security level.\n- (c_rounds=1, d_rounds=2) fastest option, but the output may be distinguishable from random data with related keys or non-uniform input - not suitable as a PRF.\n\nSipHash is not a traditional hash function. If the input includes untrusted content, a secret key is absolutely necessary.","pl":"pub fn SipHash128(comptime c_rounds: usize, comptime d_rounds: usize) type {\n    return SipHash(u128, c_rounds, d_rounds);\n}","src":43,"more_decls":null}]