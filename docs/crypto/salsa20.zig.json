[{"doc_comment":"The Salsa20 stream cipher.","pl":"pub const Salsa20 = struct ","src":328,"more_decls":{"doc_comment":"Add the output of the Salsa20 stream cipher to `in` and stores the result into `out`.\nWARNING: This function doesn't provide authenticated encryption.\nUsing the AEAD or one of the `box` versions is usually preferred.","pl":"fn xor(out: []u8, in: []const u8, counter: u64, key: [key_length]u8, nonce: [nonce_length]u8) void","src":337,"more_decls":null}{"doc_comment":"Nonce length in bytes.","pl":"const nonce_length = 8","src":330,"more_decls":null}{"doc_comment":"Key length in bytes.","pl":"const key_length = 32","src":332,"more_decls":null}}{"doc_comment":"The XSalsa20 stream cipher.","pl":"pub const XSalsa20 = struct ","src":350,"more_decls":{"doc_comment":"Add the output of the XSalsa20 stream cipher to `in` and stores the result into `out`.\nWARNING: This function doesn't provide authenticated encryption.\nUsing the AEAD or one of the `box` versions is usually preferred.","pl":"pub fn xor(out: []u8, in: []const u8, counter: u64, key: [key_length]u8, nonce: [nonce_length]u8) void {\n    const extended = extend(key, nonce);\n    Salsa20.xor(out, in, counter, extended.key, extended.nonce);\n}","src":359,"more_decls":null}{"doc_comment":"Nonce length in bytes.","pl":"const nonce_length = 24","src":352,"more_decls":null}{"doc_comment":"Key length in bytes.","pl":"const key_length = 32","src":354,"more_decls":null}}{"doc_comment":"The XSalsa20 stream cipher, combined with the Poly1305 MAC","pl":"pub const XSalsa20Poly1305 = struct ","src":366,"more_decls":{"doc_comment":"c: ciphertext: output buffer should be of size m.len\ntag: authentication tag: output MAC\nm: message\nad: Associated Data\nnpub: public nonce\nk: private key","pl":"fn encrypt(c: []u8, tag: *[tag_length]u8, m: []const u8, ad: []const u8, npub: [nonce_length]u8, k: [key_length]u8) void","src":380,"more_decls":null}{"doc_comment":"m: message: output buffer should be of size c.len\nc: ciphertext\ntag: authentication tag\nad: Associated Data\nnpub: public nonce\nk: private key","pl":"fn decrypt(m: []u8, c: []const u8, tag: [tag_length]u8, ad: []const u8, npub: [nonce_length]u8, k: [key_length]u8) Error!void","src":401,"more_decls":null}{"doc_comment":"Authentication tag length in bytes.","pl":"const tag_length = Poly1305.mac_length","src":368,"more_decls":null}{"doc_comment":"Nonce length in bytes.","pl":"const nonce_length = XSalsa20.nonce_length","src":370,"more_decls":null}{"doc_comment":"Key length in bytes.","pl":"const key_length = XSalsa20.key_length","src":372,"more_decls":null}}{"doc_comment":"NaCl-compatible secretbox API.\n\nA secretbox contains both an encrypted message and an authentication tag to verify that it hasn't been tampered with.\nA secret key shared by all the recipients must be already known in order to use this API.\n\nNonces are 192-bit large and can safely be chosen with a random number generator.","pl":"pub const SecretBox = struct ","src":432,"more_decls":{"doc_comment":"Encrypt and authenticate `m` using a nonce `npub` and a key `k`.\n`c` must be exactly `tag_length` longer than `m`, as it will store both the ciphertext and the authentication tag.","pl":"pub fn seal(c: []u8, m: []const u8, npub: [nonce_length]u8, k: [key_length]u8) void {\n    debug.assert(c.len == tag_length + m.len);\n    XSalsa20Poly1305.encrypt(c[tag_length..], c[0..tag_length], m, \"\", npub, k);\n}","src":442,"more_decls":null}{"doc_comment":"Verify and decrypt `c` using a nonce `npub` and a key `k`.\n`m` must be exactly `tag_length` smaller than `c`, as `c` includes an authentication tag in addition to the encrypted message.","pl":"fn open(m: []u8, c: []const u8, npub: [nonce_length]u8, k: [key_length]u8) Error!void","src":449,"more_decls":null}{"doc_comment":"Key length in bytes.","pl":"const key_length = XSalsa20Poly1305.key_length","src":434,"more_decls":null}{"doc_comment":"Nonce length in bytes.","pl":"const nonce_length = XSalsa20Poly1305.nonce_length","src":436,"more_decls":null}{"doc_comment":"Authentication tag length in bytes.","pl":"const tag_length = XSalsa20Poly1305.tag_length","src":438,"more_decls":null}}{"doc_comment":"NaCl-compatible box API.\n\nA secretbox contains both an encrypted message and an authentication tag to verify that it hasn't been tampered with.\nThis construction uses public-key cryptography. A shared secret doesn't have to be known in advance by both parties.\nInstead, a message is encrypted using a sender's secret key and a recipient's public key,\nand is decrypted using the recipient's secret key and the sender's public key.\n\nNonces are 192-bit large and can safely be chosen with a random number generator.","pl":"pub const Box = struct ","src":466,"more_decls":{"doc_comment":"Compute a secret suitable for `secretbox` given a recipent's public key and a sender's secret key.","pl":"pub fn createSharedSecret(public_key: [public_length]u8, secret_key: [secret_length]u8) Error![shared_length]u8 {\n    const p = try X25519.scalarmult(secret_key, public_key);\n    const zero = [_]u8{0} ** 16;\n    return Salsa20Impl.hsalsa20(zero, p);\n}","src":484,"more_decls":null}{"doc_comment":"Encrypt and authenticate a message using a recipient's public key `public_key` and a sender's `secret_key`.","pl":"pub fn seal(c: []u8, m: []const u8, npub: [nonce_length]u8, public_key: [public_length]u8, secret_key: [secret_length]u8) Error!void {\n    const shared_key = try createSharedSecret(public_key, secret_key);\n    return SecretBox.seal(c, m, npub, shared_key);\n}","src":491,"more_decls":null}{"doc_comment":"Verify and decrypt a message using a recipient's secret key `public_key` and a sender's `public_key`.","pl":"pub fn open(m: []u8, c: []const u8, npub: [nonce_length]u8, public_key: [public_length]u8, secret_key: [secret_length]u8) Error!void {\n    const shared_key = try createSharedSecret(public_key, secret_key);\n    return SecretBox.open(m, c, npub, shared_key);\n}","src":497,"more_decls":null}{"doc_comment":"Public key length in bytes.","pl":"const public_length = X25519.public_length","src":468,"more_decls":null}{"doc_comment":"Secret key length in bytes.","pl":"const secret_length = X25519.secret_length","src":470,"more_decls":null}{"doc_comment":"Shared key length in bytes.","pl":"const shared_length = XSalsa20Poly1305.key_length","src":472,"more_decls":null}{"doc_comment":"Seed (for key pair creation) length in bytes.","pl":"const seed_length = X25519.seed_length","src":474,"more_decls":null}{"doc_comment":"Nonce length in bytes.","pl":"const nonce_length = XSalsa20Poly1305.nonce_length","src":476,"more_decls":null}{"doc_comment":"Authentication tag length in bytes.","pl":"const tag_length = XSalsa20Poly1305.tag_length","src":478,"more_decls":null}{"doc_comment":"A key pair.","pl":"const KeyPair = X25519.KeyPair","src":481,"more_decls":null}}{"doc_comment":"libsodium-compatible sealed boxes\n\nSealed boxes are designed to anonymously send messages to a recipient given their public key.\nOnly the recipient can decrypt these messages, using their private key.\nWhile the recipient can verify the integrity of the message, it cannot verify the identity of the sender.\n\nA message is encrypted using an ephemeral key pair, whose secret part is destroyed right after the encryption process.","pl":"pub const SealedBox = struct ","src":510,"more_decls":{"doc_comment":"Encrypt a message `m` for a recipient whose public key is `public_key`.\n`c` must be `seal_length` bytes larger than `m`, so that the required metadata can be added.","pl":"fn seal(c: []u8, m: []const u8, public_key: [public_length]u8) Error!void","src":530,"more_decls":null}{"doc_comment":"Decrypt a message using a key pair.\n`m` must be exactly `seal_length` bytes smaller than `c`, as `c` also includes metadata.","pl":"fn open(m: []u8, c: []const u8, keypair: KeyPair) Error!void","src":541,"more_decls":null}{"pl":"const public_length = Box.public_length","src":511,"more_decls":null}{"pl":"const secret_length = Box.secret_length","src":512,"more_decls":null}{"pl":"const seed_length = Box.seed_length","src":513,"more_decls":null}{"pl":"const seal_length = Box.public_length + Box.tag_length","src":514,"more_decls":null}{"doc_comment":"A key pair.","pl":"const KeyPair = Box.KeyPair","src":517,"more_decls":null}}]