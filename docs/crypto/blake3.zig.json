[{"doc_comment":"An incremental hasher that can accept any number of writes.","pl":"pub const Blake3 = struct ","src":361,"more_decls":{"pl":"chunk_state: ChunkState","src":365,"more_decls":null}{"pl":"key: [8]u32","src":366,"more_decls":null}{"pl":"cv_stack: [54][8]u32 = undefined","src":367,"more_decls":null}{"pl":"cv_stack_len: u8 = 0","src":368,"more_decls":null}{"pl":"flags: u8","src":369,"more_decls":null}{"pl":"pub const Options = struct ","src":362,"more_decls":{"pl":"key: ?[digest_length]u8 = null ","src":362,"more_decls":null}}{"pl":"pub const KdfOptions = struct ","src":363,"more_decls":}{"doc_comment":"Construct a new `Blake3` for the hash function, with an optional key","pl":"fn init(options: Options) Blake3","src":384,"more_decls":null}{"doc_comment":"Construct a new `Blake3` for the key derivation function. The context\nstring should be hardcoded, globally unique, and application-specific.","pl":"fn initKdf(context: []const u8, options: KdfOptions) Blake3","src":395,"more_decls":null}{"pl":"pub fn hash(in: []const u8, out: []u8, options: Options) void {\n    var hasher = Blake3.init(options);\n    hasher.update(in);\n    hasher.final(out);\n}","src":404,"more_decls":null}{"doc_comment":"Add input to the hash state. This can be called any number of times.","pl":"fn update(self: *Blake3, input_slice: []const u8) void","src":439,"more_decls":null}{"doc_comment":"Finalize the hash and write any number of output bytes.","pl":"fn final(self: *const Blake3, out_slice: []u8) void","src":460,"more_decls":null}{"pl":"const block_length = BLOCK_LEN","src":371,"more_decls":null}{"pl":"const digest_length = OUT_LEN","src":372,"more_decls":null}{"pl":"const key_length = KEY_LEN","src":373,"more_decls":null}}]