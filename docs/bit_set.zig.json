[{"doc_comment":"A bit set with runtime known size, backed by an allocated slice\nof usize.  The allocator must be tracked externally by the user.","pl":"pub const DynamicBitSetUnmanaged = struct ","src":453,"more_decls":{"doc_comment":"The number of valid items in this bit set","pl":"bit_length: usize = 0","src":463,"more_decls":null}{"doc_comment":"The bit masks, ordered with lower indices first.\nPadding bits at the end must be zeroed.","pl":"masks: [*]MaskInt = empty_masks_ptr","src":467,"more_decls":null}{"doc_comment":"Creates a bit set with no elements present.\nIf bit_length is not zero, deinit must eventually be called.","pl":"pub fn initEmpty(bit_length: usize, allocator: *Allocator) !Self {\n    var self = Self{};\n    try self.resize(bit_length, false, allocator);\n    return self;\n}","src":482,"more_decls":null}{"doc_comment":"Creates a bit set with all elements present.\nIf bit_length is not zero, deinit must eventually be called.","pl":"pub fn initFull(bit_length: usize, allocator: *Allocator) !Self {\n    var self = Self{};\n    try self.resize(bit_length, true, allocator);\n    return self;\n}","src":490,"more_decls":null}{"doc_comment":"Resizes to a new bit_length.  If the new length is larger\nthan the old length, fills any added bits with `fill`.\nIf new_len is not zero, deinit must eventually be called.","pl":"fn resize(self: *@This(), new_len: usize, fill: bool, allocator: *Allocator) !void","src":499,"more_decls":null}{"doc_comment":"deinitializes the array and releases its memory.\nThe passed allocator must be the same one used for\ninit* or resize in the past.","pl":"pub fn deinit(self: *Self, allocator: *Allocator) void {\n    self.resize(0, false, allocator) catch unreachable;\n}","src":562,"more_decls":null}{"doc_comment":"Creates a duplicate of this bit set, using the new allocator.","pl":"fn clone(self: *const Self, new_allocator: *Allocator) !Self","src":567,"more_decls":null}{"doc_comment":"Returns the number of bits in this bit set","pl":"pub fn capacity(self: Self) callconv(.Inline) usize {\n    return self.bit_length;\n}","src":576,"more_decls":null}{"doc_comment":"Returns true if the bit at the specified index\nis present in the set, false otherwise.","pl":"pub fn isSet(self: Self, index: usize) bool {\n    assert(index < self.bit_length);\n    return (self.masks[maskIndex(index)] & maskBit(index)) != 0;\n}","src":582,"more_decls":null}{"doc_comment":"Returns the total number of set bits in this bit set.","pl":"fn count(self: Self) usize","src":588,"more_decls":null}{"doc_comment":"Changes the value of the specified bit of the bit\nset to match the passed boolean.","pl":"fn setValue(self: *Self, index: usize, value: bool) void","src":600,"more_decls":null}{"doc_comment":"Adds a specific bit to the bit set","pl":"pub fn set(self: *Self, index: usize) void {\n    assert(index < self.bit_length);\n    self.masks[maskIndex(index)] |= maskBit(index);\n}","src":609,"more_decls":null}{"doc_comment":"Removes a specific bit from the bit set","pl":"pub fn unset(self: *Self, index: usize) void {\n    assert(index < self.bit_length);\n    self.masks[maskIndex(index)] &= ~maskBit(index);\n}","src":615,"more_decls":null}{"doc_comment":"Flips a specific bit in the bit set","pl":"pub fn toggle(self: *Self, index: usize) void {\n    assert(index < self.bit_length);\n    self.masks[maskIndex(index)] ^= maskBit(index);\n}","src":621,"more_decls":null}{"doc_comment":"Flips all bits in this bit set which are present\nin the toggles bit set.  Both sets must have the\nsame bit_length.","pl":"fn toggleSet(self: *Self, toggles: Self) void","src":629,"more_decls":null}{"doc_comment":"Flips every bit in the bit set.","pl":"fn toggleAll(self: *Self) void","src":638,"more_decls":null}{"doc_comment":"Performs a union of two bit sets, and stores the\nresult in the first one.  Bits in the result are\nset if the corresponding bits were set in either input.\nThe two sets must both be the same bit_length.","pl":"fn setUnion(self: *Self, other: Self) void","src":657,"more_decls":null}{"doc_comment":"Performs an intersection of two bit sets, and stores\nthe result in the first one.  Bits in the result are\nset if the corresponding bits were set in both inputs.\nThe two sets must both be the same bit_length.","pl":"fn setIntersection(self: *Self, other: Self) void","src":669,"more_decls":null}{"doc_comment":"Finds the index of the first set bit.\nIf no bits are set, returns null.","pl":"fn findFirstSet(self: Self) ?usize","src":679,"more_decls":null}{"doc_comment":"Finds the index of the first set bit, and unsets it.\nIf no bits are set, returns null.","pl":"fn toggleFirstSet(self: *Self) ?usize","src":692,"more_decls":null}{"doc_comment":"Iterates through the items in the set, according to the options.\nThe default options (.{}) will iterate indices of set bits in\nascending order.  Modifications to the underlying bit set may\nor may not be observed by the iterator.  Resizing the underlying\nbit set invalidates the iterator.","pl":"pub fn iterator(self: *const Self, comptime options: IteratorOptions) Iterator(options) {\n    const num_masks = numMasks(self.bit_length);\n    const padding_bits = num_masks * @bitSizeOf(MaskInt) - self.bit_length;\n    const last_item_mask = (~@as(MaskInt, 0)) >> @intCast(ShiftInt, padding_bits);\n    return Iterator(options).init(self.masks[0..num_masks], last_item_mask);\n}","src":710,"more_decls":null}{"pl":"pub fn Iterator(comptime options: IteratorOptions) type {\n    return BitSetIterator(MaskInt, options);\n}","src":717,"more_decls":null}{"doc_comment":"The integer type used to represent a mask in this bit set","pl":"const MaskInt = usize","src":457,"more_decls":null}{"doc_comment":"The integer type used to shift a mask in this bit set","pl":"const ShiftInt = std.math.Log2Int(MaskInt)","src":460,"more_decls":null}}{"doc_comment":"A bit set with runtime known size, backed by an allocated slice\nof usize.  Thin wrapper around DynamicBitSetUnmanaged which keeps\ntrack of the allocator instance.","pl":"pub const DynamicBitSet = struct ","src":738,"more_decls":{"doc_comment":"The allocator used by this bit set","pl":"allocator: *Allocator","src":748,"more_decls":null}{"doc_comment":"The number of valid items in this bit set","pl":"unmanaged: DynamicBitSetUnmanaged = .{}","src":751,"more_decls":null}{"doc_comment":"Creates a bit set with no elements present.","pl":"pub fn initEmpty(bit_length: usize, allocator: *Allocator) !Self {\n    return Self{\n        .unmanaged = try DynamicBitSetUnmanaged.initEmpty(bit_length, allocator),\n        .allocator = allocator,\n    };\n}","src":754,"more_decls":null}{"doc_comment":"Creates a bit set with all elements present.","pl":"pub fn initFull(bit_length: usize, allocator: *Allocator) !Self {\n    return Self{\n        .unmanaged = try DynamicBitSetUnmanaged.initFull(bit_length, allocator),\n        .allocator = allocator,\n    };\n}","src":762,"more_decls":null}{"doc_comment":"Resizes to a new length.  If the new length is larger\nthan the old length, fills any added bits with `fill`.","pl":"pub fn resize(self: *@This(), new_len: usize, fill: bool) !void {\n    try self.unmanaged.resize(new_len, fill, self.allocator);\n}","src":771,"more_decls":null}{"doc_comment":"deinitializes the array and releases its memory.\nThe passed allocator must be the same one used for\ninit* or resize in the past.","pl":"pub fn deinit(self: *Self) void {\n    self.unmanaged.deinit(self.allocator);\n}","src":778,"more_decls":null}{"doc_comment":"Creates a duplicate of this bit set, using the new allocator.","pl":"pub fn clone(self: *const Self, new_allocator: *Allocator) !Self {\n    return Self{\n        .unmanaged = try self.unmanaged.clone(new_allocator),\n        .allocator = new_allocator,\n    };\n}","src":783,"more_decls":null}{"doc_comment":"Returns the number of bits in this bit set","pl":"pub fn capacity(self: Self) callconv(.Inline) usize {\n    return self.unmanaged.capacity();\n}","src":791,"more_decls":null}{"doc_comment":"Returns true if the bit at the specified index\nis present in the set, false otherwise.","pl":"pub fn isSet(self: Self, index: usize) bool {\n    return self.unmanaged.isSet(index);\n}","src":797,"more_decls":null}{"doc_comment":"Returns the total number of set bits in this bit set.","pl":"pub fn count(self: Self) usize {\n    return self.unmanaged.count();\n}","src":802,"more_decls":null}{"doc_comment":"Changes the value of the specified bit of the bit\nset to match the passed boolean.","pl":"pub fn setValue(self: *Self, index: usize, value: bool) void {\n    self.unmanaged.setValue(index, value);\n}","src":808,"more_decls":null}{"doc_comment":"Adds a specific bit to the bit set","pl":"pub fn set(self: *Self, index: usize) void {\n    self.unmanaged.set(index);\n}","src":813,"more_decls":null}{"doc_comment":"Removes a specific bit from the bit set","pl":"pub fn unset(self: *Self, index: usize) void {\n    self.unmanaged.unset(index);\n}","src":818,"more_decls":null}{"doc_comment":"Flips a specific bit in the bit set","pl":"pub fn toggle(self: *Self, index: usize) void {\n    self.unmanaged.toggle(index);\n}","src":823,"more_decls":null}{"doc_comment":"Flips all bits in this bit set which are present\nin the toggles bit set.  Both sets must have the\nsame bit_length.","pl":"pub fn toggleSet(self: *Self, toggles: Self) void {\n    self.unmanaged.toggleSet(toggles.unmanaged);\n}","src":830,"more_decls":null}{"doc_comment":"Flips every bit in the bit set.","pl":"pub fn toggleAll(self: *Self) void {\n    self.unmanaged.toggleAll();\n}","src":835,"more_decls":null}{"doc_comment":"Performs a union of two bit sets, and stores the\nresult in the first one.  Bits in the result are\nset if the corresponding bits were set in either input.\nThe two sets must both be the same bit_length.","pl":"pub fn setUnion(self: *Self, other: Self) void {\n    self.unmanaged.setUnion(other.unmanaged);\n}","src":843,"more_decls":null}{"doc_comment":"Performs an intersection of two bit sets, and stores\nthe result in the first one.  Bits in the result are\nset if the corresponding bits were set in both inputs.\nThe two sets must both be the same bit_length.","pl":"pub fn setIntersection(self: *Self, other: Self) void {\n    self.unmanaged.setIntersection(other.unmanaged);\n}","src":851,"more_decls":null}{"doc_comment":"Finds the index of the first set bit.\nIf no bits are set, returns null.","pl":"pub fn findFirstSet(self: Self) ?usize {\n    return self.unmanaged.findFirstSet();\n}","src":857,"more_decls":null}{"doc_comment":"Finds the index of the first set bit, and unsets it.\nIf no bits are set, returns null.","pl":"pub fn toggleFirstSet(self: *Self) ?usize {\n    return self.unmanaged.toggleFirstSet();\n}","src":863,"more_decls":null}{"doc_comment":"Iterates through the items in the set, according to the options.\nThe default options (.{}) will iterate indices of set bits in\nascending order.  Modifications to the underlying bit set may\nor may not be observed by the iterator.  Resizing the underlying\nbit set invalidates the iterator.","pl":"pub fn iterator(self: *Self, comptime options: IteratorOptions) Iterator(options) {\n    return self.unmanaged.iterator(options);\n}","src":872,"more_decls":null}{"doc_comment":"The integer type used to represent a mask in this bit set","pl":"const MaskInt = usize","src":742,"more_decls":null}{"doc_comment":"The integer type used to shift a mask in this bit set","pl":"const ShiftInt = std.math.Log2Int(MaskInt)","src":745,"more_decls":null}{"pl":"const Iterator = DynamicBitSetUnmanaged.Iterator","src":876,"more_decls":null}}{"doc_comment":"Options for configuring an iterator over a bit set","pl":"pub const IteratorOptions = struct ","src":880,"more_decls":{"doc_comment":"determines which bits should be visited","pl":"kind: Type = .set","src":882,"more_decls":null}{"doc_comment":"determines the order in which bit indices should be visited","pl":"direction: Direction = .forward","src":884,"more_decls":null}{"pl":"pub const Type = enum ","src":886,"more_decls":{"doc_comment":"visit indexes of set bits","pl":"set","src":888,"more_decls":null}{"doc_comment":"visit indexes of unset bits","pl":"unset","src":890,"more_decls":null}}{"pl":"pub const Direction = enum ","src":893,"more_decls":{"doc_comment":"visit indices in ascending order","pl":"forward","src":895,"more_decls":null}{"doc_comment":"visit indices in descending order.\nNote that this may be slightly more expensive than forward iteration.","pl":"reverse","src":898,"more_decls":null}}}{"doc_comment":"Returns the optimal static bit set type for the specified number\nof elements.  The returned type will perform no allocations,\ncan be copied by value, and does not require deinitialization.\nBoth possible implementations fulfill the same interface.","pl":"fn StaticBitSet(comptime size: usize) type","src":46,"more_decls":null}{"doc_comment":"A bit set with static size, which is backed by a single integer.\nThis set is good for sets with a small size, but may generate\ninefficient code for larger sets, especially in debug mode.","pl":"fn IntegerBitSet(comptime size: u16) type","sub_container_type":"struct ","src":57,"more_decls":{"doc_comment":"The bit mask, as a single integer","pl":"mask: MaskInt","src":72,"more_decls":null}{"doc_comment":"Creates a bit set with no elements present.","pl":"pub fn initEmpty() Self {\n    return .{ .mask = 0 };\n}","src":75,"more_decls":null}{"doc_comment":"Creates a bit set with all elements present.","pl":"pub fn initFull() Self {\n    return .{ .mask = ~@as(MaskInt, 0) };\n}","src":80,"more_decls":null}{"doc_comment":"Returns the number of bits in this bit set","pl":"pub fn capacity(self: Self) callconv(.Inline) usize {\n    return bit_length;\n}","src":85,"more_decls":null}{"doc_comment":"Returns true if the bit at the specified index\nis present in the set, false otherwise.","pl":"pub fn isSet(self: Self, index: usize) bool {\n    assert(index < bit_length);\n    return (self.mask & maskBit(index)) != 0;\n}","src":91,"more_decls":null}{"doc_comment":"Returns the total number of set bits in this bit set.","pl":"pub fn count(self: Self) usize {\n    return @popCount(MaskInt, self.mask);\n}","src":97,"more_decls":null}{"doc_comment":"Changes the value of the specified bit of the bit\nset to match the passed boolean.","pl":"fn setValue(self: *Self, index: usize, value: bool) void","src":103,"more_decls":null}{"doc_comment":"Adds a specific bit to the bit set","pl":"pub fn set(self: *Self, index: usize) void {\n    assert(index < bit_length);\n    self.mask |= maskBit(index);\n}","src":112,"more_decls":null}{"doc_comment":"Removes a specific bit from the bit set","pl":"pub fn unset(self: *Self, index: usize) void {\n    assert(index < bit_length);\n    // Workaround for #7953\n    if (MaskInt == u0) return;\n    self.mask &= ~maskBit(index);\n}","src":118,"more_decls":null}{"doc_comment":"Flips a specific bit in the bit set","pl":"pub fn toggle(self: *Self, index: usize) void {\n    assert(index < bit_length);\n    self.mask ^= maskBit(index);\n}","src":126,"more_decls":null}{"doc_comment":"Flips all bits in this bit set which are present\nin the toggles bit set.","pl":"pub fn toggleSet(self: *Self, toggles: Self) void {\n    self.mask ^= toggles.mask;\n}","src":133,"more_decls":null}{"doc_comment":"Flips every bit in the bit set.","pl":"pub fn toggleAll(self: *Self) void {\n    self.mask = ~self.mask;\n}","src":138,"more_decls":null}{"doc_comment":"Performs a union of two bit sets, and stores the\nresult in the first one.  Bits in the result are\nset if the corresponding bits were set in either input.","pl":"pub fn setUnion(self: *Self, other: Self) void {\n    self.mask |= other.mask;\n}","src":145,"more_decls":null}{"doc_comment":"Performs an intersection of two bit sets, and stores\nthe result in the first one.  Bits in the result are\nset if the corresponding bits were set in both inputs.","pl":"pub fn setIntersection(self: *Self, other: Self) void {\n    self.mask &= other.mask;\n}","src":152,"more_decls":null}{"doc_comment":"Finds the index of the first set bit.\nIf no bits are set, returns null.","pl":"pub fn findFirstSet(self: Self) ?usize {\n    const mask = self.mask;\n    if (mask == 0) return null;\n    return @ctz(MaskInt, mask);\n}","src":158,"more_decls":null}{"doc_comment":"Finds the index of the first set bit, and unsets it.\nIf no bits are set, returns null.","pl":"fn toggleFirstSet(self: *Self) ?usize","src":166,"more_decls":null}{"doc_comment":"Iterates through the items in the set, according to the options.\nThe default options (.{}) will iterate indices of set bits in\nascending order.  Modifications to the underlying bit set may\nor may not be observed by the iterator.","pl":"fn iterator(self: *const Self, comptime options: IteratorOptions) Iterator(options)","src":178,"more_decls":null}{"pl":"pub fn Iterator(comptime options: IteratorOptions) type {\n    return SingleWordIterator(options.direction);\n}","src":187,"more_decls":null}{"doc_comment":"The number of items in this bit set","pl":"const bit_length: usize = size","src":63,"more_decls":null}{"doc_comment":"The integer type used to represent a mask in this bit set","pl":"const MaskInt = std.meta.Int(.unsigned, size)","src":66,"more_decls":null}{"doc_comment":"The integer type used to shift a mask in this bit set","pl":"const ShiftInt = std.math.Log2Int(MaskInt)","src":69,"more_decls":null}}{"doc_comment":"A bit set with static size, which is backed by an array of usize.\nThis set is good for sets with a larger size, but may use\nmore bytes than necessary if your set is small.","pl":"fn ArrayBitSet(comptime MaskIntType: type, comptime size: usize) type","sub_container_type":"struct ","src":233,"more_decls":{"doc_comment":"The bit masks, ordered with lower indices first.\nPadding bits at the end are undefined.","pl":"masks: [num_masks]MaskInt","src":295,"more_decls":null}{"doc_comment":"Creates a bit set with no elements present.","pl":"pub fn initEmpty() Self {\n    return .{ .masks = [_]MaskInt{0} ** num_masks };\n}","src":298,"more_decls":null}{"doc_comment":"Creates a bit set with all elements present.","pl":"fn initFull() Self","src":303,"more_decls":null}{"doc_comment":"Returns the number of bits in this bit set","pl":"pub fn capacity(self: Self) callconv(.Inline) usize {\n    return bit_length;\n}","src":312,"more_decls":null}{"doc_comment":"Returns true if the bit at the specified index\nis present in the set, false otherwise.","pl":"pub fn isSet(self: Self, index: usize) bool {\n    assert(index < bit_length);\n    if (num_masks == 0) return false; // doesn't compile in this case\n    return (self.masks[maskIndex(index)] & maskBit(index)) != 0;\n}","src":318,"more_decls":null}{"doc_comment":"Returns the total number of set bits in this bit set.","pl":"fn count(self: Self) usize","src":325,"more_decls":null}{"doc_comment":"Changes the value of the specified bit of the bit\nset to match the passed boolean.","pl":"fn setValue(self: *Self, index: usize, value: bool) void","src":335,"more_decls":null}{"doc_comment":"Adds a specific bit to the bit set","pl":"pub fn set(self: *Self, index: usize) void {\n    assert(index < bit_length);\n    if (num_masks == 0) return; // doesn't compile in this case\n    self.masks[maskIndex(index)] |= maskBit(index);\n}","src":345,"more_decls":null}{"doc_comment":"Removes a specific bit from the bit set","pl":"pub fn unset(self: *Self, index: usize) void {\n    assert(index < bit_length);\n    if (num_masks == 0) return; // doesn't compile in this case\n    self.masks[maskIndex(index)] &= ~maskBit(index);\n}","src":352,"more_decls":null}{"doc_comment":"Flips a specific bit in the bit set","pl":"pub fn toggle(self: *Self, index: usize) void {\n    assert(index < bit_length);\n    if (num_masks == 0) return; // doesn't compile in this case\n    self.masks[maskIndex(index)] ^= maskBit(index);\n}","src":359,"more_decls":null}{"doc_comment":"Flips all bits in this bit set which are present\nin the toggles bit set.","pl":"pub fn toggleSet(self: *Self, toggles: Self) void {\n    for (self.masks) |*mask, i| {\n        mask.* ^= toggles.masks[i];\n    }\n}","src":367,"more_decls":null}{"doc_comment":"Flips every bit in the bit set.","pl":"fn toggleAll(self: *Self) void","src":374,"more_decls":null}{"doc_comment":"Performs a union of two bit sets, and stores the\nresult in the first one.  Bits in the result are\nset if the corresponding bits were set in either input.","pl":"pub fn setUnion(self: *Self, other: Self) void {\n    for (self.masks) |*mask, i| {\n        mask.* |= other.masks[i];\n    }\n}","src":388,"more_decls":null}{"doc_comment":"Performs an intersection of two bit sets, and stores\nthe result in the first one.  Bits in the result are\nset if the corresponding bits were set in both inputs.","pl":"pub fn setIntersection(self: *Self, other: Self) void {\n    for (self.masks) |*mask, i| {\n        mask.* &= other.masks[i];\n    }\n}","src":397,"more_decls":null}{"doc_comment":"Finds the index of the first set bit.\nIf no bits are set, returns null.","pl":"fn findFirstSet(self: Self) ?usize","src":405,"more_decls":null}{"doc_comment":"Finds the index of the first set bit, and unsets it.\nIf no bits are set, returns null.","pl":"fn toggleFirstSet(self: *Self) ?usize","src":416,"more_decls":null}{"doc_comment":"Iterates through the items in the set, according to the options.\nThe default options (.{}) will iterate indices of set bits in\nascending order.  Modifications to the underlying bit set may\nor may not be observed by the iterator.","pl":"pub fn iterator(self: *const Self, comptime options: IteratorOptions) Iterator(options) {\n    return Iterator(options).init(&self.masks, last_item_mask);\n}","src":431,"more_decls":null}{"pl":"pub fn Iterator(comptime options: IteratorOptions) type {\n    return BitSetIterator(MaskInt, options);\n}","src":435,"more_decls":null}{"doc_comment":"The number of items in this bit set","pl":"const bit_length: usize = size","src":274,"more_decls":null}{"doc_comment":"The integer type used to represent a mask in this bit set","pl":"const MaskInt = MaskIntType","src":277,"more_decls":null}{"doc_comment":"The integer type used to shift a mask in this bit set","pl":"const ShiftInt = std.math.Log2Int(MaskInt)","src":280,"more_decls":null}{"pl":"const last_item_mask = ~@as(MaskInt, 0) >> last_pad_bits","src":291,"more_decls":null}}]