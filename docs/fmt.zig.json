[{"pl":"pub const Alignment = enum ","src":18,"more_decls":{"pl":"Left","src":19,"more_decls":null}{"pl":"Center","src":20,"more_decls":null}{"pl":"Right","src":21,"more_decls":null}}{"pl":"pub const FormatOptions = struct ","src":24,"more_decls":{"pl":"precision: ?usize = null","src":25,"more_decls":null}{"pl":"width: ?usize = null","src":26,"more_decls":null}{"pl":"alignment: Alignment = .Right","src":27,"more_decls":null}{"pl":"fill: u8 = ' '","src":28,"more_decls":null}}{"doc_comment":"Renders fmt string with args, calling output with slices of bytes.\nIf `output` returns an error, the error is returned from `format` and\n`output` is not called again.\n\nThe format string must be comptime known and may contain placeholders following\nthis format:\n`{[argument][specifier]:[fill][alignment][width].[precision]}`\n\nEach word between `[` and `]` is a parameter you have to replace with something:\n\n- *argument* is either the index or the name of the argument that should be inserted\n- *specifier* is a type-dependent formatting option that determines how a type should formatted (see below)\n- *fill* is a single character which is used to pad the formatted text\n- *alignment* is one of the three characters `<`, `^` or `>`. they define if the text is *left*, *center*, or *right* aligned\n- *width* is the total width of the field in characters\n- *precision* specifies how many decimals a formatted number should have\n\nNote that most of the parameters are optional and may be omitted. Also you can leave out separators like `:` and `.` when\nall parameters after the separator are omitted.\nOnly exception is the *fill* parameter. If *fill* is required, one has to specify *alignment* as well, as otherwise\nthe digits after `:` is interpreted as *width*, not *fill*.\n\nThe *specifier* has several options for types:\n- `x` and `X`: output numeric value in hexadecimal notation\n- `s`:\n- for pointer-to-many and C pointers of u8, print as a C-string using zero-termination\n- for slices of u8, print the entire slice as a string without zero-termination\n- `e`: output floating point value in scientific notation\n- `d`: output numeric value in decimal notation\n- `b`: output integer value in binary notation\n- `o`: output integer value in octal notation\n- `c`: output integer as an ASCII character. Integer type must have 8 bits at max.\n- `u`: output integer as an UTF-8 sequence. Integer type must have 21 bits at max.\n- `*`: output the address of the value instead of the value itself.\n- `any`: output a value of any type using its default format\n\nIf a formatted user type contains a function of the type\n```\npub fn format(value: ?, comptime fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void\n```\nwith `?` being the type formatted, this function will be called instead of the default implementation.\nThis allows user types to be formatted in a logical manner instead of dumping all fields of the type.\n\nA user type may be a `struct`, `vector`, `union` or `enum` type.\n\nTo print literal curly braces, escape them by writing them twice, e.g. `{{` or `}}`.","pl":"fn format(\n    writer: anytype,\n    comptime fmt: []const u8,\n    args: anytype,\n) !void","src":77,"more_decls":null}{"pl":"fn formatAddress(value: anytype, options: FormatOptions, writer: anytype) @TypeOf(writer).Error!void","src":365,"more_decls":null}{"pl":"fn formatType(\n    value: anytype,\n    comptime fmt: []const u8,\n    options: FormatOptions,\n    writer: anytype,\n    max_depth: usize,\n) @TypeOf(writer).Error!void","src":410,"more_decls":null}{"pl":"fn formatIntValue(\n    value: anytype,\n    comptime fmt: []const u8,\n    options: FormatOptions,\n    writer: anytype,\n) !void","src":630,"more_decls":null}{"doc_comment":"Return a Formatter for a []const u8 where every byte is formatted as a pair\nof lowercase hexadecimal digits.","pl":"pub fn fmtSliceHexLower(bytes: []const u8) std.fmt.Formatter(formatSliceHexLower) {\n    return .{ .data = bytes };\n}","src":731,"more_decls":null}{"doc_comment":"Return a Formatter for a []const u8 where every byte is formatted as a pair\nof uppercase hexadecimal digits.","pl":"pub fn fmtSliceHexUpper(bytes: []const u8) std.fmt.Formatter(formatSliceHexUpper) {\n    return .{ .data = bytes };\n}","src":737,"more_decls":null}{"doc_comment":"Return a Formatter for a []const u8 where every non-printable ASCII\ncharacter is escaped as \\xNN, where NN is the character in lowercase\nhexadecimal notation.","pl":"pub fn fmtSliceEscapeLower(bytes: []const u8) std.fmt.Formatter(formatSliceEscapeLower) {\n    return .{ .data = bytes };\n}","src":775,"more_decls":null}{"doc_comment":"Return a Formatter for a []const u8 where every non-printable ASCII\ncharacter is escaped as \\xNN, where NN is the character in uppercase\nhexadecimal notation.","pl":"pub fn fmtSliceEscapeUpper(bytes: []const u8) std.fmt.Formatter(formatSliceEscapeUpper) {\n    return .{ .data = bytes };\n}","src":782,"more_decls":null}{"doc_comment":"Return a Formatter for a u64 value representing a file size.\nThis formatter represents the number as multiple of 1000 and uses the SI\nmeasurement units (kB, MB, GB, ...).","pl":"pub fn fmtIntSizeDec(value: u64) std.fmt.Formatter(formatSizeDec) {\n    return .{ .data = value };\n}","src":836,"more_decls":null}{"doc_comment":"Return a Formatter for a u64 value representing a file size.\nThis formatter represents the number as multiple of 1024 and uses the IEC\nmeasurement units (KiB, MiB, GiB, ...).","pl":"pub fn fmtIntSizeBin(value: u64) std.fmt.Formatter(formatSizeBin) {\n    return .{ .data = value };\n}","src":843,"more_decls":null}{"pl":"fn formatText(\n    bytes: []const u8,\n    comptime fmt: []const u8,\n    options: FormatOptions,\n    writer: anytype,\n) !void","src":847,"more_decls":null}{"pl":"fn formatAsciiChar(\n    c: u8,\n    options: FormatOptions,\n    writer: anytype,\n) !void","src":872,"more_decls":null}{"pl":"fn formatUnicodeCodepoint(\n    c: u21,\n    options: FormatOptions,\n    writer: anytype,\n) !void","src":880,"more_decls":null}{"pl":"fn formatBuf(\n    buf: []const u8,\n    options: FormatOptions,\n    writer: anytype,\n) !void","src":895,"more_decls":null}{"doc_comment":"Print a float in scientific notation to the specified precision. Null uses full precision.\nIt should be the case that every full precision, printed value can be re-parsed back to the\nsame type unambiguously.","pl":"fn formatFloatScientific(\n    value: anytype,\n    options: FormatOptions,\n    writer: anytype,\n) !void","src":934,"more_decls":null}{"doc_comment":"Print a float of the format x.yyyyy where the number of y is specified by the precision argument.\nBy default floats are printed at full precision (no rounding).","pl":"fn formatFloatDecimal(\n    value: anytype,\n    options: FormatOptions,\n    writer: anytype,\n) !void","src":1027,"more_decls":null}{"pl":"fn formatInt(\n    value: anytype,\n    base: u8,\n    uppercase: bool,\n    options: FormatOptions,\n    writer: anytype,\n) !void","src":1168,"more_decls":null}{"pl":"pub fn formatIntBuf(out_buf: []u8, value: anytype, base: u8, uppercase: bool, options: FormatOptions) usize {\n    var fbs = std.io.fixedBufferStream(out_buf);\n    formatInt(value, base, uppercase, options, fbs.writer()) catch unreachable;\n    return fbs.pos;\n}","src":1220,"more_decls":null}{"doc_comment":"Return a Formatter for number of nanoseconds according to its magnitude:\n[#y][#w][#d][#h][#m]#[.###][n|u|m]s","pl":"pub fn fmtDuration(ns: u64) Formatter(formatDuration) {\n    return .{ .data = ns };\n}","src":1275,"more_decls":null}{"doc_comment":"Creates a Formatter type from a format function. Wrapping data in Formatter(func) causes\nthe data to be formatted using the given function `func`.  `func` must be of the following\nform:\n\nfn formatExample(\ndata: T,\ncomptime fmt: []const u8,\noptions: std.fmt.FormatOptions,\nwriter: anytype,\n) !void;\n","pl":"fn Formatter(comptime format_fn: anytype) type","sub_container_type":"struct ","src":1336,"more_decls":{"pl":"data: Data","src":1339,"more_decls":null}{"pl":"fn format(\n    self: @This(),\n    comptime fmt: []const u8,\n    options: std.fmt.FormatOptions,\n    writer: anytype,\n) @TypeOf(writer).Error!void","src":1340,"more_decls":null}}{"doc_comment":"Parses the string `buf` as signed or unsigned representation in the\nspecified radix of an integral value of type `T`.\n\nWhen `radix` is zero the string prefix is examined to detect the true radix:\n* A prefix of \"0b\" implies radix=2,\n* A prefix of \"0o\" implies radix=8,\n* A prefix of \"0x\" implies radix=16,\n* Otherwise radix=10 is assumed.\n\nSee also `parseUnsigned`.","pl":"pub fn parseInt(comptime T: type, buf: []const u8, radix: u8) ParseIntError!T {\n    if (buf.len == 0) return error.InvalidCharacter;\n    if (buf[0] == '+') return parseWithSign(T, buf[1..], radix, .Pos);\n    if (buf[0] == '-') return parseWithSign(T, buf[1..], radix, .Neg);\n    return parseWithSign(T, buf, radix, .Pos);\n}","src":1361,"more_decls":null}{"doc_comment":"Parses the string `buf` as  unsigned representation in the specified radix\nof an integral value of type `T`.\n\nWhen `radix` is zero the string prefix is examined to detect the true radix:\n* A prefix of \"0b\" implies radix=2,\n* A prefix of \"0o\" implies radix=8,\n* A prefix of \"0x\" implies radix=16,\n* Otherwise radix=10 is assumed.\n\nSee also `parseInt`.","pl":"pub fn parseUnsigned(comptime T: type, buf: []const u8, radix: u8) ParseIntError!T {\n    return parseWithSign(T, buf, radix, .Pos);\n}","src":1469,"more_decls":null}{"pl":"fn charToDigit(c: u8, radix: u8) (error{InvalidCharacter}!u8)","src":1513,"more_decls":null}{"pl":"fn digitToChar(digit: u8, uppercase: bool) u8","src":1526,"more_decls":null}{"pl":"pub fn bufPrint(buf: []u8, comptime fmt: []const u8, args: anytype) BufPrintError![]u8 {\n    var fbs = std.io.fixedBufferStream(buf);\n    try format(fbs.writer(), fmt, args);\n    return fbs.getWritten();\n}","src":1538,"more_decls":null}{"pl":"pub fn bufPrintZ(buf: []u8, comptime fmt: []const u8, args: anytype) BufPrintError![:0]u8 {\n    const result = try bufPrint(buf, fmt ++ \"\\x00\", args);\n    return result[0 .. result.len - 1 :0];\n}","src":1544,"more_decls":null}{"doc_comment":"Count the characters needed for format. Useful for preallocating memory","pl":"pub fn count(comptime fmt: []const u8, args: anytype) u64 {\n    var counting_writer = std.io.countingWriter(std.io.null_writer);\n    format(counting_writer.writer(), fmt, args) catch |err| switch (err) {};\n    return counting_writer.bytes_written;\n}","src":1550,"more_decls":null}{"pl":"fn allocPrint(allocator: *mem.Allocator, comptime fmt: []const u8, args: anytype) AllocPrintError![]u8","src":1558,"more_decls":null}{"pl":"pub fn allocPrintZ(allocator: *mem.Allocator, comptime fmt: []const u8, args: anytype) AllocPrintError![:0]u8 {\n    const result = try allocPrint(allocator, fmt ++ \"\\x00\", args);\n    return result[0 .. result.len - 1 :0];\n}","src":1572,"more_decls":null}{"pl":"pub fn bufPrintIntToSlice(buf: []u8, value: anytype, base: u8, uppercase: bool, options: FormatOptions) []u8 {\n    return buf[0..formatIntBuf(buf, value, base, uppercase, options)];\n}","src":1598,"more_decls":null}{"pl":"fn comptimePrint(comptime fmt: []const u8, args: anytype) *const [count(fmt, args):0]u8","src":1602,"more_decls":null}{"doc_comment":"Decodes the sequence of bytes represented by the specified string of\nhexadecimal characters.\nReturns a slice of the output buffer containing the decoded bytes.","pl":"fn hexToBytes(out: []u8, input: []const u8) ![]u8","src":2075,"more_decls":null}{"pl":"const default_max_depth = 3","src":16,"more_decls":null}{"pl":"const ParseIntError = error{\n    /// The result cannot fit in the type specified\n    Overflow,\n\n    /// The input was empty or had a byte that was not a digit\n    InvalidCharacter,\n}","src":1317,"more_decls":null}{"pl":"const parseFloat = @import(\"fmt/parse_float.zig\").parseFloat","src":1507,"more_decls":null}{"pl":"const BufPrintError = error{\n    /// As much as possible was written to the buffer, but it was too small to fit all the printed bytes.\n    NoSpaceLeft,\n}","src":1534,"more_decls":null}{"pl":"const AllocPrintError = error{OutOfMemory}","src":1556,"more_decls":null}{"doc_comment":"Deprecated, use allocPrintZ","pl":"const allocPrint0 = allocPrintZ","src":1570,"more_decls":null}{"pl":"const trim = @compileError(\"deprecated; use std.mem.trim with std.ascii.spaces instead\")","src":2069,"more_decls":null}{"pl":"const isWhiteSpace = @compileError(\"deprecated; use std.ascii.isSpace instead\")","src":2070,"more_decls":null}]