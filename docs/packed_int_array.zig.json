[{"pl":"fn PackedIntIo(comptime Int: type, comptime endian: builtin.Endian) type","sub_container_type":"struct ","src":10,"more_decls":{"pl":"fn get(bytes: []const u8, index: usize, bit_offset: u7) Int","src":50,"more_decls":null}{"pl":"fn set(bytes: []u8, index: usize, bit_offset: u3, int: Int) void","src":91,"more_decls":null}}{"doc_comment":"Creates a bit-packed array of integers of type Int. Bits\nare packed using native endianess and without storing any meta\ndata. PackedIntArray(i3, 8) will occupy exactly 3 bytes of memory.","pl":"pub fn PackedIntArray(comptime Int: type, comptime int_count: usize) type {\n    return PackedIntArrayEndian(Int, builtin.endian, int_count);\n}","src":173,"more_decls":null}{"doc_comment":"Creates a bit-packed array of integers of type Int. Bits\nare packed using specified endianess and without storing any meta\ndata.","pl":"fn PackedIntArrayEndian(comptime Int: type, comptime endian: builtin.Endian, comptime int_count: usize) type","sub_container_type":"struct ","src":180,"more_decls":{"pl":"bytes: [total_bytes]u8","src":190,"more_decls":null}{"doc_comment":"Returns the number of elements in the packed array","pl":"pub fn len(self: Self) usize {\n    return int_count;\n}","src":193,"more_decls":null}{"doc_comment":"Initialize a packed array using an unpacked array\nor, more likely, an array literal.","pl":"pub fn init(ints: [int_count]Int) Self {\n    var self = @as(Self, undefined);\n    for (ints) |int, i| self.set(i, int);\n    return self;\n}","src":199,"more_decls":null}{"doc_comment":"Initialize all entries of a packed array to the same value","pl":"pub fn initAllTo(int: Int) Self {\n    // TODO: use `var self = @as(Self, undefined);` https://github.com/ziglang/zig/issues/7635\n    var self = Self{ .bytes = [_]u8{0} ** total_bytes };\n    self.setAll(int);\n    return self;\n}","src":206,"more_decls":null}{"doc_comment":"Return the Int stored at index","pl":"pub fn get(self: Self, index: usize) Int {\n    debug.assert(index < int_count);\n    return Io.get(&self.bytes, index, 0);\n}","src":214,"more_decls":null}{"doc_comment":"Copy int into the array at index","pl":"pub fn set(self: *Self, index: usize, int: Int) void {\n    debug.assert(index < int_count);\n    return Io.set(&self.bytes, index, 0, int);\n}","src":220,"more_decls":null}{"doc_comment":"Set all entries of a packed array to the same value","pl":"pub fn setAll(self: *Self, int: Int) void {\n    var i: usize = 0;\n    while (i < int_count) : (i += 1) {\n        self.set(i, int);\n    }\n}","src":226,"more_decls":null}{"doc_comment":"Create a PackedIntSlice of the array from given start to given end","pl":"pub fn slice(self: *Self, start: usize, end: usize) PackedIntSliceEndian(Int, endian) {\n    debug.assert(start < int_count);\n    debug.assert(end <= int_count);\n    return Io.slice(&self.bytes, 0, start, end);\n}","src":234,"more_decls":null}{"doc_comment":"Create a PackedIntSlice of the array using NewInt as the bit width integer.\nNewInt's bit width must fit evenly within the array's Int's total bits.","pl":"pub fn sliceCast(self: *Self, comptime NewInt: type) PackedIntSlice(NewInt) {\n    return self.sliceCastEndian(NewInt, endian);\n}","src":242,"more_decls":null}{"doc_comment":"Create a PackedIntSlice of the array using NewInt as the bit width integer\nand new_endian as the new endianess. NewInt's bit width must fit evenly within\nthe array's Int's total bits.","pl":"pub fn sliceCastEndian(self: *Self, comptime NewInt: type, comptime new_endian: builtin.Endian) PackedIntSliceEndian(NewInt, new_endian) {\n    return Io.sliceCast(&self.bytes, NewInt, new_endian, 0, int_count);\n}","src":249,"more_decls":null}}{"doc_comment":"Uses a slice as a bit-packed block of int_count integers of type Int.\nBits are packed using native endianess and without storing any meta\ndata.","pl":"pub fn PackedIntSlice(comptime Int: type) type {\n    return PackedIntSliceEndian(Int, builtin.endian);\n}","src":258,"more_decls":null}{"doc_comment":"Uses a slice as a bit-packed block of int_count integers of type Int.\nBits are packed using specified endianess and without storing any meta\ndata.","pl":"fn PackedIntSliceEndian(comptime Int: type, comptime endian: builtin.Endian) type","sub_container_type":"struct ","src":265,"more_decls":{"pl":"bytes: []u8","src":272,"more_decls":null}{"pl":"int_count: usize","src":273,"more_decls":null}{"pl":"bit_offset: u3","src":274,"more_decls":null}{"doc_comment":"Returns the number of elements in the packed slice","pl":"pub fn len(self: Self) usize {\n    return self.int_count;\n}","src":277,"more_decls":null}{"doc_comment":"Calculates the number of bytes required to store a desired count\nof Ints","pl":"pub fn bytesRequired(int_count: usize) usize {\n    const total_bits = int_bits * int_count;\n    const total_bytes = (total_bits + 7) / 8;\n    return total_bytes;\n}","src":283,"more_decls":null}{"doc_comment":"Initialize a packed slice using the memory at bytes, with int_count\nelements. bytes must be large enough to accomodate the requested\ncount.","pl":"fn init(bytes: []u8, int_count: usize) Self","src":292,"more_decls":null}{"doc_comment":"Return the Int stored at index","pl":"pub fn get(self: Self, index: usize) Int {\n    debug.assert(index < self.int_count);\n    return Io.get(self.bytes, index, self.bit_offset);\n}","src":303,"more_decls":null}{"doc_comment":"Copy int into the array at index","pl":"pub fn set(self: *Self, index: usize, int: Int) void {\n    debug.assert(index < self.int_count);\n    return Io.set(self.bytes, index, self.bit_offset, int);\n}","src":309,"more_decls":null}{"doc_comment":"Create a PackedIntSlice of this slice from given start to given end","pl":"pub fn slice(self: Self, start: usize, end: usize) PackedIntSliceEndian(Int, endian) {\n    debug.assert(start < self.int_count);\n    debug.assert(end <= self.int_count);\n    return Io.slice(self.bytes, self.bit_offset, start, end);\n}","src":315,"more_decls":null}{"doc_comment":"Create a PackedIntSlice of this slice using NewInt as the bit width integer.\nNewInt's bit width must fit evenly within this slice's Int's total bits.","pl":"pub fn sliceCast(self: Self, comptime NewInt: type) PackedIntSliceEndian(NewInt, endian) {\n    return self.sliceCastEndian(NewInt, endian);\n}","src":323,"more_decls":null}{"doc_comment":"Create a PackedIntSlice of this slice using NewInt as the bit width integer\nand new_endian as the new endianess. NewInt's bit width must fit evenly within\nthis slice's Int's total bits.","pl":"pub fn sliceCastEndian(self: Self, comptime NewInt: type, comptime new_endian: builtin.Endian) PackedIntSliceEndian(NewInt, new_endian) {\n    return Io.sliceCast(self.bytes, NewInt, new_endian, self.bit_offset, self.int_count);\n}","src":330,"more_decls":null}}]