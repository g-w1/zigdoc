[{"pl":"extern \"c\" fn getdents(fd: c_int, buf_ptr: [*]u8, nbytes: usize) usize","src":11,"more_decls":null}{"pl":"extern \"c\" fn sigaltstack(ss: ?*stack_t, old_ss: ?*stack_t) c_int","src":12,"more_decls":null}{"pl":"extern \"c\" fn getrandom(buf_ptr: [*]u8, buf_len: usize, flags: c_uint) isize","src":13,"more_decls":null}{"pl":"extern \"c\" fn pthread_getthreadid_np() c_int","src":15,"more_decls":null}{"pl":"extern \"c\" fn pipe2(fds: *[2]fd_t, flags: u32) c_int","src":16,"more_decls":null}{"pl":"extern \"c\" fn posix_memalign(memptr: *?*c_void, alignment: usize, size: usize) c_int","src":18,"more_decls":null}{"pl":"extern \"c\" fn malloc_usable_size(?*const c_void) usize","src":19,"more_decls":null}{"pl":"pub const sf_hdtr = extern struct ","src":21,"more_decls":{"pl":"headers: [*]const iovec_const","src":22,"more_decls":null}{"pl":"hdr_cnt: c_int","src":23,"more_decls":null}{"pl":"trailers: [*]const iovec_const","src":24,"more_decls":null}{"pl":"trl_cnt: c_int","src":25,"more_decls":null}}{"pl":"extern \"c\" fn sendfile(\n    in_fd: fd_t,\n    out_fd: fd_t,\n    offset: off_t,\n    nbytes: usize,\n    sf_hdtr: ?*sf_hdtr,\n    sbytes: ?*off_t,\n    flags: u32,\n) c_int","src":27,"more_decls":null}{"pl":"extern \"c\" fn dl_iterate_phdr(callback: dl_iterate_phdr_callback, data: ?*c_void) c_int","src":38,"more_decls":null}{"pl":"pub const pthread_mutex_t = extern struct ","src":40,"more_decls":{"pl":"inner: ?*c_void = null","src":41,"more_decls":null}}{"pl":"pub const pthread_cond_t = extern struct ","src":43,"more_decls":{"pl":"inner: ?*c_void = null","src":44,"more_decls":null}}{"pl":"pub const pthread_rwlock_t = extern struct ","src":46,"more_decls":{"pl":"ptr: ?*c_void = null","src":47,"more_decls":null}}{"pl":"pub const pthread_attr_t = extern struct ","src":50,"more_decls":{"pl":"__size: [56]u8","src":51,"more_decls":null}{"pl":"__align: c_long","src":52,"more_decls":null}}{"pl":"pub const sem_t = extern struct ","src":55,"more_decls":{"pl":"_magic: u32","src":56,"more_decls":null}{"pl":"_kern: extern struct {\n        _count: u32,\n        _flags: u32,\n    }","src":57,"more_decls":null}{"pl":"_padding: u32","src":61,"more_decls":null}}{"pl":"pub const EAI = extern enum","src":64,"more_decls":{"doc_comment":"address family for hostname not supported","pl":"ADDRFAMILY = 1","src":66,"more_decls":null}{"doc_comment":"name could not be resolved at this time","pl":"AGAIN = 2","src":69,"more_decls":null}{"doc_comment":"flags parameter had an invalid value","pl":"BADFLAGS = 3","src":72,"more_decls":null}{"doc_comment":"non-recoverable failure in name resolution","pl":"FAIL = 4","src":75,"more_decls":null}{"doc_comment":"address family not recognized","pl":"FAMILY = 5","src":78,"more_decls":null}{"doc_comment":"memory allocation failure","pl":"MEMORY = 6","src":81,"more_decls":null}{"doc_comment":"no address associated with hostname","pl":"NODATA = 7","src":84,"more_decls":null}{"doc_comment":"name does not resolve","pl":"NONAME = 8","src":87,"more_decls":null}{"doc_comment":"service not recognized for socket type","pl":"SERVICE = 9","src":90,"more_decls":null}{"doc_comment":"intended socket type was not recognized","pl":"SOCKTYPE = 10","src":93,"more_decls":null}{"doc_comment":"system error returned in errno","pl":"SYSTEM = 11","src":96,"more_decls":null}{"doc_comment":"invalid value for hints","pl":"BADHINTS = 12","src":99,"more_decls":null}{"doc_comment":"resolved protocol is unknown","pl":"PROTOCOL = 13","src":102,"more_decls":null}{"doc_comment":"argument buffer overflow","pl":"OVERFLOW = 14","src":105,"more_decls":null}{"pl":"_","src":107,"more_decls":null}}{"pl":"const _errno = __error","src":9,"more_decls":null}{"pl":"const dl_iterate_phdr_callback = fn (info: *dl_phdr_info, size: usize, data: ?*c_void) callconv(.C) c_int","src":37,"more_decls":null}{"pl":"const EAI_MAX = 15","src":110,"more_decls":null}{"doc_comment":"get address to use bind()","pl":"const AI_PASSIVE = 0x00000001","src":113,"more_decls":null}{"doc_comment":"fill ai_canonname","pl":"const AI_CANONNAME = 0x00000002","src":116,"more_decls":null}{"doc_comment":"prevent host name resolution","pl":"const AI_NUMERICHOST = 0x00000004","src":119,"more_decls":null}{"doc_comment":"prevent service name resolution","pl":"const AI_NUMERICSERV = 0x00000008","src":122,"more_decls":null}{"doc_comment":"valid flags for addrinfo (not a standard def, apps should not use it)","pl":"const AI_MASK = (AI_PASSIVE | AI_CANONNAME | AI_NUMERICHOST | AI_NUMERICSERV | AI_ADDRCONFIG | AI_ALL | AI_V4MAPPED)","src":125,"more_decls":null}{"doc_comment":"IPv6 and IPv4-mapped (with AI_V4MAPPED)","pl":"const AI_ALL = 0x00000100","src":128,"more_decls":null}{"doc_comment":"accept IPv4-mapped if kernel supports","pl":"const AI_V4MAPPED_CFG = 0x00000200","src":131,"more_decls":null}{"doc_comment":"only if any address is assigned","pl":"const AI_ADDRCONFIG = 0x00000400","src":134,"more_decls":null}{"doc_comment":"accept IPv4-mapped IPv6 address","pl":"const AI_V4MAPPED = 0x00000800","src":137,"more_decls":null}{"doc_comment":"special recommended flags for getipnodebyname","pl":"const AI_DEFAULT = (AI_V4MAPPED_CFG | AI_ADDRCONFIG)","src":140,"more_decls":null}]