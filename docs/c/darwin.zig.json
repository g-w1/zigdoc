[{"pl":"extern \"c\" fn NSVersionOfRunTimeLibrary(library_name: [*:0]const u8) u32","src":13,"more_decls":null}{"pl":"extern \"c\" fn _NSGetExecutablePath(buf: [*:0]u8, bufsize: *u32) c_int","src":14,"more_decls":null}{"pl":"extern \"c\" fn _dyld_image_count() u32","src":15,"more_decls":null}{"pl":"extern \"c\" fn _dyld_get_image_header(image_index: u32) ?*mach_header","src":16,"more_decls":null}{"pl":"extern \"c\" fn _dyld_get_image_vmaddr_slide(image_index: u32) usize","src":17,"more_decls":null}{"pl":"extern \"c\" fn _dyld_get_image_name(image_index: u32) [*:0]const u8","src":18,"more_decls":null}{"pl":"extern \"c\" fn fcopyfile(from: fd_t, to: fd_t, state: ?copyfile_state_t, flags: u32) c_int","src":26,"more_decls":null}{"pl":"extern \"c\" fn @\"realpath$DARWIN_EXTSN\"(noalias file_name: [*:0]const u8, noalias resolved_name: [*]u8) ?[*:0]u8","src":28,"more_decls":null}{"pl":"extern \"c\" fn __getdirentries64(fd: c_int, buf_ptr: [*]u8, buf_len: usize, basep: *i64) isize","src":30,"more_decls":null}{"pl":"extern \"c\" fn mach_absolute_time() u64","src":44,"more_decls":null}{"pl":"extern \"c\" fn mach_timebase_info(tinfo: ?*mach_timebase_info_data) void","src":45,"more_decls":null}{"pl":"extern \"c\" fn malloc_size(?*const c_void) usize","src":47,"more_decls":null}{"pl":"extern \"c\" fn posix_memalign(memptr: *?*c_void, alignment: usize, size: usize) c_int","src":48,"more_decls":null}{"pl":"extern \"c\" fn kevent64(\n    kq: c_int,\n    changelist: [*]const kevent64_s,\n    nchanges: c_int,\n    eventlist: [*]kevent64_s,\n    nevents: c_int,\n    flags: c_uint,\n    timeout: ?*const timespec,\n) c_int","src":50,"more_decls":null}{"pl":"extern \"c\" fn @\"close$NOCANCEL\"(fd: fd_t) c_int","src":83,"more_decls":null}{"pl":"extern \"c\" fn mach_host_self() mach_port_t","src":84,"more_decls":null}{"pl":"extern \"c\" fn clock_get_time(clock_serv: clock_serv_t, cur_time: *mach_timespec_t) kern_return_t","src":85,"more_decls":null}{"pl":"extern \"c\" fn host_get_clock_service(host: host_t, clock_id: clock_id_t, clock_serv: ?[*]clock_serv_t) kern_return_t","src":86,"more_decls":null}{"pl":"extern \"c\" fn mach_port_deallocate(task: ipc_space_t, name: mach_port_name_t) kern_return_t","src":87,"more_decls":null}{"pl":"pub const sf_hdtr = extern struct ","src":89,"more_decls":{"pl":"headers: [*]const iovec_const","src":90,"more_decls":null}{"pl":"hdr_cnt: c_int","src":91,"more_decls":null}{"pl":"trailers: [*]const iovec_const","src":92,"more_decls":null}{"pl":"trl_cnt: c_int","src":93,"more_decls":null}}{"pl":"extern \"c\" fn sendfile(\n    in_fd: fd_t,\n    out_fd: fd_t,\n    offset: off_t,\n    len: *off_t,\n    sf_hdtr: ?*sf_hdtr,\n    flags: u32,\n) c_int","src":96,"more_decls":null}{"pl":"extern \"c\" fn sigaltstack(ss: ?*stack_t, old_ss: ?*stack_t) c_int","src":109,"more_decls":null}{"pl":"pub const EAI = extern enum","src":123,"more_decls":{"doc_comment":"address family for hostname not supported","pl":"ADDRFAMILY = 1","src":125,"more_decls":null}{"doc_comment":"temporary failure in name resolution","pl":"AGAIN = 2","src":128,"more_decls":null}{"doc_comment":"invalid value for ai_flags","pl":"BADFLAGS = 3","src":131,"more_decls":null}{"doc_comment":"non-recoverable failure in name resolution","pl":"FAIL = 4","src":134,"more_decls":null}{"doc_comment":"ai_family not supported","pl":"FAMILY = 5","src":137,"more_decls":null}{"doc_comment":"memory allocation failure","pl":"MEMORY = 6","src":140,"more_decls":null}{"doc_comment":"no address associated with hostname","pl":"NODATA = 7","src":143,"more_decls":null}{"doc_comment":"hostname nor servname provided, or not known","pl":"NONAME = 8","src":146,"more_decls":null}{"doc_comment":"servname not supported for ai_socktype","pl":"SERVICE = 9","src":149,"more_decls":null}{"doc_comment":"ai_socktype not supported","pl":"SOCKTYPE = 10","src":152,"more_decls":null}{"doc_comment":"system error returned in errno","pl":"SYSTEM = 11","src":155,"more_decls":null}{"doc_comment":"invalid value for hints","pl":"BADHINTS = 12","src":158,"more_decls":null}{"doc_comment":"resolved protocol is unknown","pl":"PROTOCOL = 13","src":161,"more_decls":null}{"doc_comment":"argument buffer overflow","pl":"OVERFLOW = 14","src":164,"more_decls":null}{"pl":"_","src":166,"more_decls":null}}{"pl":"pub const pthread_mutex_t = extern struct ","src":171,"more_decls":{"pl":"__sig: c_long = 0x32AAABA7","src":172,"more_decls":null}{"pl":"__opaque: [__PTHREAD_MUTEX_SIZE__]u8 = [_]u8{0} ** __PTHREAD_MUTEX_SIZE__","src":173,"more_decls":null}}{"pl":"pub const pthread_cond_t = extern struct ","src":175,"more_decls":{"pl":"__sig: c_long = 0x3CB0B1BB","src":176,"more_decls":null}{"pl":"__opaque: [__PTHREAD_COND_SIZE__]u8 = [_]u8{0} ** __PTHREAD_COND_SIZE__","src":177,"more_decls":null}}{"pl":"pub const pthread_rwlock_t = extern struct ","src":179,"more_decls":{"pl":"__sig: c_long = 0x2DA8B3B4","src":180,"more_decls":null}{"pl":"__opaque: [192]u8 = [_]u8{0} ** 192","src":181,"more_decls":null}}{"pl":"pub const pthread_attr_t = extern struct ","src":187,"more_decls":{"pl":"__sig: c_long","src":188,"more_decls":null}{"pl":"__opaque: [56]u8","src":189,"more_decls":null}}{"pl":"extern \"c\" fn pthread_threadid_np(thread: ?pthread_t, thread_id: *u64) c_int","src":193,"more_decls":null}{"pl":"extern \"c\" fn arc4random_buf(buf: [*]u8, len: usize) void","src":195,"more_decls":null}{"pl":"extern \"c\" fn dispatch_semaphore_create(value: isize) ?dispatch_semaphore_t","src":202,"more_decls":null}{"pl":"extern \"c\" fn dispatch_semaphore_wait(dsema: dispatch_semaphore_t, timeout: dispatch_time_t) isize","src":203,"more_decls":null}{"pl":"extern \"c\" fn dispatch_semaphore_signal(dsema: dispatch_semaphore_t) isize","src":204,"more_decls":null}{"pl":"extern \"c\" fn dispatch_release(object: *c_void) void","src":206,"more_decls":null}{"pl":"extern \"c\" fn dispatch_time(when: dispatch_time_t, delta: i64) dispatch_time_t","src":207,"more_decls":null}{"pl":"pub fn sigaddset(set: *sigset_t, signo: u5) void {\n    set.* |= @as(u32, 1) << (signo - 1);\n}","src":105,"more_decls":null}{"pl":"const COPYFILE_ACL = 1 << 0","src":20,"more_decls":null}{"pl":"const COPYFILE_STAT = 1 << 1","src":21,"more_decls":null}{"pl":"const COPYFILE_XATTR = 1 << 2","src":22,"more_decls":null}{"pl":"const COPYFILE_DATA = 1 << 3","src":23,"more_decls":null}{"pl":"const copyfile_state_t = *opaque {}","src":25,"more_decls":null}{"pl":"const _fstat = if (builtin.arch == .aarch64) fstat else @\"fstat$INODE64\"","src":36,"more_decls":null}{"pl":"const _fstatat = if (builtin.arch == .aarch64) fstatat else @\"fstatat$INODE64\"","src":42,"more_decls":null}{"pl":"var _mh_execute_header: mach_hdr;\ncomptime {\n    if (std.Target.current.isDarwin()) {\n        @export(dummy_execute_header, .{ .name = \"_mh_execute_header\", .linkage = .Weak });\n    }\n}\n\npub const mach_header_64 = macho.mach_header_64;\npub const mach_header = macho.mach_header;\n\npub const _errno = __error;\n\npub extern \"c\" fn @\"close$NOCANCEL\"(fd: fd_t) c_int;\npub extern \"c\" fn mach_host_self() mach_port_t;\npub extern \"c\" fn clock_get_time(clock_serv: clock_serv_t, cur_time: *mach_timespec_t) kern_return_t;\npub extern \"c\" fn host_get_clock_service(host: host_t, clock_id: clock_id_t, clock_serv: ?[*]clock_serv_t) kern_return_t;\npub extern \"c\" fn mach_port_deallocate(task: ipc_space_t, name: mach_port_name_t) kern_return_t;\n\npub const sf_hdtr = extern struct {\n    headers: [*]const iovec_const,\n    hdr_cnt: c_int,\n    trailers: [*]const iovec_const,\n    trl_cnt: c_int,\n};\n\npub extern \"c\" fn sendfile(\n    in_fd: fd_t,\n    out_fd: fd_t,\n    offset: off_t,\n    len: *off_t,\n    sf_hdtr: ?*sf_hdtr,\n    flags: u32,\n) c_int;\n\npub fn sigaddset(set: *sigset_t, signo: u5) void {\n    set.* |= @as(u32, 1) << (signo - 1);\n}\n\npub extern \"c\" fn sigaltstack(ss: ?*stack_t, old_ss: ?*stack_t) c_int;\n\n/// get address to use bind()\npub const AI_PASSIVE = 0x00000001;\n\n/// fill ai_canonname\npub const AI_CANONNAME = 0x00000002;\n\n/// prevent host name resolution\npub const AI_NUMERICHOST = 0x00000004;\n\n/// prevent service name resolution\npub const AI_NUMERICSERV = 0x00001000;\n\npub const EAI = extern enum(c_int) {\n    /// address family for hostname not supported\n    ADDRFAMILY = 1,\n\n    /// temporary failure in name resolution\n    AGAIN = 2,\n\n    /// invalid value for ai_flags\n    BADFLAGS = 3,\n\n    /// non-recoverable failure in name resolution\n    FAIL = 4,\n\n    /// ai_family not supported\n    FAMILY = 5,\n\n    /// memory allocation failure\n    MEMORY = 6,\n\n    /// no address associated with hostname\n    NODATA = 7,\n\n    /// hostname nor servname provided, or not known\n    NONAME = 8,\n\n    /// servname not supported for ai_socktype\n    SERVICE = 9,\n\n    /// ai_socktype not supported\n    SOCKTYPE = 10,\n\n    /// system error returned in errno\n    SYSTEM = 11,\n\n    /// invalid value for hints\n    BADHINTS = 12,\n\n    /// resolved protocol is unknown\n    PROTOCOL = 13,\n\n    /// argument buffer overflow\n    OVERFLOW = 14,\n\n    _,\n};\n\npub const EAI_MAX = 15;\n\npub const pthread_mutex_t = extern struct {\n    __sig: c_long = 0x32AAABA7,\n    __opaque: [__PTHREAD_MUTEX_SIZE__]u8 = [_]u8{0} ** __PTHREAD_MUTEX_SIZE__,\n};\npub const pthread_cond_t = extern struct {\n    __sig: c_long = 0x3CB0B1BB,\n    __opaque: [__PTHREAD_COND_SIZE__]u8 = [_]u8{0} ** __PTHREAD_COND_SIZE__,\n};\npub const pthread_rwlock_t = extern struct {\n    __sig: c_long = 0x2DA8B3B4,\n    __opaque: [192]u8 = [_]u8{0} ** 192,\n};\npub const sem_t = c_int;\nconst __PTHREAD_MUTEX_SIZE__ = if (@sizeOf(usize) == 8) 56 else 40;\nconst __PTHREAD_COND_SIZE__ = if (@sizeOf(usize) == 8) 40 else 24;\n\npub const pthread_attr_t = extern struct {\n    __sig: c_long,\n    __opaque: [56]u8,\n};\n\nconst pthread_t = std.c.pthread_t;\npub extern \"c\" fn pthread_threadid_np(thread: ?pthread_t, thread_id: *u64) c_int;\n\npub extern \"c\" fn arc4random_buf(buf: [*]u8, len: usize) void;\n\n// Grand Central Dispatch is exposed by libSystem.\npub const dispatch_semaphore_t = *opaque {};\npub const dispatch_time_t = u64;\npub const DISPATCH_TIME_NOW = @as(dispatch_time_t, 0);\npub const DISPATCH_TIME_FOREVER = ~@as(dispatch_time_t, 0);\npub extern \"c\" fn dispatch_semaphore_create(value: isize) ?dispatch_semaphore_t;\npub extern \"c\" fn dispatch_semaphore_wait(dsema: dispatch_semaphore_t, timeout: dispatch_time_t) isize;\npub extern \"c\" fn dispatch_semaphore_signal(dsema: dispatch_semaphore_t) isize;\n\npub extern \"c\" fn dispatch_release(object: *c_void) void;\npub extern \"c\" fn dispatch_time(when: dispatch_time_t, delta: i64) dispatch_time_t;\n","src":71,"more_decls":null}{"pl":"const mach_header_64 = macho.mach_header_64","src":78,"more_decls":null}{"pl":"const mach_header = macho.mach_header","src":79,"more_decls":null}{"pl":"const _errno = __error","src":81,"more_decls":null}{"doc_comment":"get address to use bind()","pl":"const AI_PASSIVE = 0x00000001","src":112,"more_decls":null}{"doc_comment":"fill ai_canonname","pl":"const AI_CANONNAME = 0x00000002","src":115,"more_decls":null}{"doc_comment":"prevent host name resolution","pl":"const AI_NUMERICHOST = 0x00000004","src":118,"more_decls":null}{"doc_comment":"prevent service name resolution","pl":"const AI_NUMERICSERV = 0x00001000","src":121,"more_decls":null}{"pl":"const EAI_MAX = 15","src":169,"more_decls":null}{"pl":"const sem_t = c_int","src":183,"more_decls":null}{"pl":"const dispatch_semaphore_t = *opaque {}","src":198,"more_decls":null}{"pl":"const dispatch_time_t = u64","src":199,"more_decls":null}{"pl":"const DISPATCH_TIME_NOW = @as(dispatch_time_t, 0)","src":200,"more_decls":null}{"pl":"const DISPATCH_TIME_FOREVER = ~@as(dispatch_time_t, 0)","src":201,"more_decls":null}]