[{"pl":"pub const Tree = struct ","src":12,"more_decls":{"pl":"tokens: []Token","src":13,"more_decls":null}{"pl":"sources: []Source","src":14,"more_decls":null}{"pl":"root_node: *Node.Root","src":15,"more_decls":null}{"pl":"arena_state: std.heap.ArenaAllocator.State","src":16,"more_decls":null}{"pl":"gpa: *mem.Allocator","src":17,"more_decls":null}{"pl":"msgs: []Msg","src":18,"more_decls":null}{"pl":"pub fn deinit(self: *Tree) void {\n    self.arena_state.promote(self.gpa).deinit();\n}","src":20,"more_decls":null}{"pl":"pub fn tokenSlice(tree: *Tree, token: TokenIndex) []const u8 {\n    return tree.tokens.at(token).slice();\n}","src":24,"more_decls":null}{"pl":"pub fn tokenEql(tree: *Tree, a: TokenIndex, b: TokenIndex) bool {\n    const atok = tree.tokens.at(a);\n    const btok = tree.tokens.at(b);\n    return atok.eql(btok.*);\n}","src":28,"more_decls":null}}{"pl":"pub const Msg = struct ","src":35,"more_decls":{"pl":"kind: enum {\n        Error,\n        Warning,\n        Note,\n    }","src":36,"more_decls":null}{"pl":"inner: Error","src":41,"more_decls":null}}{"pl":"pub const Error = union(enum) ","src":44,"more_decls":{"pl":"InvalidToken: SingleTokenError(\"invalid token '{}'\")","src":45,"more_decls":null}{"pl":"ExpectedToken: ExpectedToken","src":46,"more_decls":null}{"pl":"ExpectedExpr: SingleTokenError(\"expected expression, found '{}'\")","src":47,"more_decls":null}{"pl":"ExpectedTypeName: SingleTokenError(\"expected type name, found '{}'\")","src":48,"more_decls":null}{"pl":"ExpectedFnBody: SingleTokenError(\"expected function body, found '{}'\")","src":49,"more_decls":null}{"pl":"ExpectedDeclarator: SingleTokenError(\"expected declarator, found '{}'\")","src":50,"more_decls":null}{"pl":"ExpectedInitializer: SingleTokenError(\"expected initializer, found '{}'\")","src":51,"more_decls":null}{"pl":"ExpectedEnumField: SingleTokenError(\"expected enum field, found '{}'\")","src":52,"more_decls":null}{"pl":"ExpectedType: SingleTokenError(\"expected enum field, found '{}'\")","src":53,"more_decls":null}{"pl":"InvalidTypeSpecifier: InvalidTypeSpecifier","src":54,"more_decls":null}{"pl":"InvalidStorageClass: SingleTokenError(\"invalid storage class, found '{}'\")","src":55,"more_decls":null}{"pl":"InvalidDeclarator: SimpleError(\"invalid declarator\")","src":56,"more_decls":null}{"pl":"DuplicateQualifier: SingleTokenError(\"duplicate type qualifier '{}'\")","src":57,"more_decls":null}{"pl":"DuplicateSpecifier: SingleTokenError(\"duplicate declaration specifier '{}'\")","src":58,"more_decls":null}{"pl":"MustUseKwToRefer: MustUseKwToRefer","src":59,"more_decls":null}{"pl":"FnSpecOnNonFn: SingleTokenError(\"function specifier '{}' on non function\")","src":60,"more_decls":null}{"pl":"NothingDeclared: SimpleError(\"declaration doesn't declare anything\")","src":61,"more_decls":null}{"pl":"QualifierIgnored: SingleTokenError(\"qualifier '{}' ignored\")","src":62,"more_decls":null}{"pl":"pub const ExpectedToken = struct ","src":110,"more_decls":{"pl":"token: TokenIndex","src":111,"more_decls":null}{"pl":"expected_id: std.meta.Tag(Token.Id)","src":112,"more_decls":null}{"pl":"fn render(self: *const ExpectedToken, tree: *Tree, stream: anytype) !void","src":114,"more_decls":null}}{"pl":"pub const InvalidTypeSpecifier = struct ","src":125,"more_decls":{"pl":"token: TokenIndex","src":126,"more_decls":null}{"pl":"type_spec: *Node.TypeSpec","src":127,"more_decls":null}{"pl":"pub fn render(self: *const ExpectedToken, tree: *Tree, stream: anytype) !void {\n    try stream.write(\"invalid type specifier '\");\n    try type_spec.spec.print(tree, stream);\n    const token_name = tree.tokens.at(self.token).id.symbol();\n    return stream.print(\"{s}'\", .{token_name});\n}","src":129,"more_decls":null}}{"pl":"pub const MustUseKwToRefer = struct ","src":137,"more_decls":{"pl":"kw: TokenIndex","src":138,"more_decls":null}{"pl":"name: TokenIndex","src":139,"more_decls":null}{"pl":"pub fn render(self: *const ExpectedToken, tree: *Tree, stream: anytype) !void {\n    return stream.print(\"must use '{s}' tag to refer to type '{s}'\", .{ tree.slice(kw), tree.slice(name) });\n}","src":141,"more_decls":null}}{"pl":"fn render(self: *const Error, tree: *Tree, stream: anytype) !void","src":64,"more_decls":null}{"pl":"fn loc(self: *const Error) TokenIndex","src":87,"more_decls":null}}{"pl":"pub const Type = struct ","src":170,"more_decls":{"pl":"@\"const\": bool = false","src":173,"more_decls":null}{"pl":"atomic: bool = false","src":174,"more_decls":null}{"pl":"@\"volatile\": bool = false","src":175,"more_decls":null}{"pl":"restrict: bool = false","src":176,"more_decls":null}{"pl":"id: union(enum) {\n        Int: struct {\n            id: Id,\n            is_signed: bool,\n\n            pub const Id = enum {\n                Char,\n                Short,\n                Int,\n                Long,\n                LongLong,\n            };\n        },\n        Float: struct {\n            id: Id,\n\n            pub const Id = enum {\n                Float,\n                Double,\n                LongDouble,\n            };\n        },\n        Pointer: *Type,\n        Function: struct {\n            return_type: *Type,\n            param_types: TypeList,\n        },\n        Typedef: *Type,\n        Record: *Node.RecordType,\n        Enum: *Node.EnumType,\n\n        /// Special case for macro parameters that can be any type.\n        /// Only present if `retain_macros == true`.\n        Macro,\n    }","src":178,"more_decls":null}{"pl":"const TypeList = ArrayList(*Type)","src":171,"more_decls":null}}{"pl":"pub const Node = struct ","src":215,"more_decls":{"pl":"id: Id","src":216,"more_decls":null}{"pl":"pub const Id = enum ","src":218,"more_decls":{"pl":"Root","src":219,"more_decls":null}{"pl":"EnumField","src":220,"more_decls":null}{"pl":"RecordField","src":221,"more_decls":null}{"pl":"RecordDeclarator","src":222,"more_decls":null}{"pl":"JumpStmt","src":223,"more_decls":null}{"pl":"ExprStmt","src":224,"more_decls":null}{"pl":"LabeledStmt","src":225,"more_decls":null}{"pl":"CompoundStmt","src":226,"more_decls":null}{"pl":"IfStmt","src":227,"more_decls":null}{"pl":"SwitchStmt","src":228,"more_decls":null}{"pl":"WhileStmt","src":229,"more_decls":null}{"pl":"DoStmt","src":230,"more_decls":null}{"pl":"ForStmt","src":231,"more_decls":null}{"pl":"StaticAssert","src":232,"more_decls":null}{"pl":"Declarator","src":233,"more_decls":null}{"pl":"Pointer","src":234,"more_decls":null}{"pl":"FnDecl","src":235,"more_decls":null}{"pl":"Typedef","src":236,"more_decls":null}{"pl":"VarDecl","src":237,"more_decls":null}}{"pl":"pub const Root = struct ","src":240,"more_decls":{"pl":"base: Node = Node{ .id = .Root }","src":241,"more_decls":null}{"pl":"decls: DeclList","src":242,"more_decls":null}{"pl":"eof: TokenIndex","src":243,"more_decls":null}{"pl":"const DeclList = ArrayList(*Node)","src":245,"more_decls":null}}{"pl":"pub const DeclSpec = struct ","src":248,"more_decls":{"pl":"storage_class: union(enum) {\n            Auto: TokenIndex,\n            Extern: TokenIndex,\n            Register: TokenIndex,\n            Static: TokenIndex,\n            Typedef: TokenIndex,\n            None,\n        } = .None","src":249,"more_decls":null}{"pl":"thread_local: ?TokenIndex = null","src":257,"more_decls":null}{"pl":"type_spec: TypeSpec = TypeSpec{}","src":258,"more_decls":null}{"pl":"fn_spec: union(enum) {\n            Inline: TokenIndex,\n            Noreturn: TokenIndex,\n            None,\n        } = .None","src":259,"more_decls":null}{"pl":"align_spec: ?struct {\n            alignas: TokenIndex,\n            expr: *Node,\n            rparen: TokenIndex,\n        } = null","src":264,"more_decls":null}}{"pl":"pub const TypeSpec = struct ","src":271,"more_decls":{"pl":"qual: TypeQual = TypeQual{}","src":272,"more_decls":null}{"pl":"spec: union(enum) {\n            /// error or default to int\n            None,\n            Void: TokenIndex,\n            Char: struct {\n                sign: ?TokenIndex = null,\n                char: TokenIndex,\n            },\n            Short: struct {\n                sign: ?TokenIndex = null,\n                short: TokenIndex = null,\n                int: ?TokenIndex = null,\n            },\n            Int: struct {\n                sign: ?TokenIndex = null,\n                int: ?TokenIndex = null,\n            },\n            Long: struct {\n                sign: ?TokenIndex = null,\n                long: TokenIndex,\n                longlong: ?TokenIndex = null,\n                int: ?TokenIndex = null,\n            },\n            Float: struct {\n                float: TokenIndex,\n                complex: ?TokenIndex = null,\n            },\n            Double: struct {\n                long: ?TokenIndex = null,\n                double: ?TokenIndex,\n                complex: ?TokenIndex = null,\n            },\n            Bool: TokenIndex,\n            Atomic: struct {\n                atomic: TokenIndex,\n                typename: *Node,\n                rparen: TokenIndex,\n            },\n            Enum: *EnumType,\n            Record: *RecordType,\n            Typedef: struct {\n                sym: TokenIndex,\n                sym_type: *Type,\n            },\n\n            pub fn print(self: *@This(), self: *const @This(), tree: *Tree, stream: anytype) !void {\n                switch (self.spec) {\n                    .None => unreachable,\n                    .Void => |index| try stream.write(tree.slice(index)),\n                    .Char => |char| {\n                        if (char.sign) |s| {\n                            try stream.write(tree.slice(s));\n                            try stream.writeByte(' ');\n                        }\n                        try stream.write(tree.slice(char.char));\n                    },\n                    .Short => |short| {\n                        if (short.sign) |s| {\n                            try stream.write(tree.slice(s));\n                            try stream.writeByte(' ');\n                        }\n                        try stream.write(tree.slice(short.short));\n                        if (short.int) |i| {\n                            try stream.writeByte(' ');\n                            try stream.write(tree.slice(i));\n                        }\n                    },\n                    .Int => |int| {\n                        if (int.sign) |s| {\n                            try stream.write(tree.slice(s));\n                            try stream.writeByte(' ');\n                        }\n                        if (int.int) |i| {\n                            try stream.writeByte(' ');\n                            try stream.write(tree.slice(i));\n                        }\n                    },\n                    .Long => |long| {\n                        if (long.sign) |s| {\n                            try stream.write(tree.slice(s));\n                            try stream.writeByte(' ');\n                        }\n                        try stream.write(tree.slice(long.long));\n                        if (long.longlong) |l| {\n                            try stream.writeByte(' ');\n                            try stream.write(tree.slice(l));\n                        }\n                        if (long.int) |i| {\n                            try stream.writeByte(' ');\n                            try stream.write(tree.slice(i));\n                        }\n                    },\n                    .Float => |float| {\n                        try stream.write(tree.slice(float.float));\n                        if (float.complex) |c| {\n                            try stream.writeByte(' ');\n                            try stream.write(tree.slice(c));\n                        }\n                    },\n                    .Double => |double| {\n                        if (double.long) |l| {\n                            try stream.write(tree.slice(l));\n                            try stream.writeByte(' ');\n                        }\n                        try stream.write(tree.slice(double.double));\n                        if (double.complex) |c| {\n                            try stream.writeByte(' ');\n                            try stream.write(tree.slice(c));\n                        }\n                    },\n                    .Bool => |index| try stream.write(tree.slice(index)),\n                    .Typedef => |typedef| try stream.write(tree.slice(typedef.sym)),\n                    else => try stream.print(\"TODO print {}\", self.spec),\n                }\n            }\n        } = .None","src":273,"more_decls":null}}{"pl":"pub const EnumType = struct ","src":391,"more_decls":{"pl":"tok: TokenIndex","src":392,"more_decls":null}{"pl":"name: ?TokenIndex","src":393,"more_decls":null}{"pl":"body: ?struct {\n            lbrace: TokenIndex,\n\n            /// always EnumField\n            fields: FieldList,\n            rbrace: TokenIndex,\n        }","src":394,"more_decls":null}{"pl":"const FieldList = Root.DeclList","src":402,"more_decls":null}}{"pl":"pub const EnumField = struct ","src":405,"more_decls":{"pl":"base: Node = Node{ .id = .EnumField }","src":406,"more_decls":null}{"pl":"name: TokenIndex","src":407,"more_decls":null}{"pl":"value: ?*Node","src":408,"more_decls":null}}{"pl":"pub const RecordType = struct ","src":411,"more_decls":{"pl":"tok: TokenIndex","src":412,"more_decls":null}{"pl":"kind: enum {\n            Struct,\n            Union,\n        }","src":413,"more_decls":null}{"pl":"name: ?TokenIndex","src":417,"more_decls":null}{"pl":"body: ?struct {\n            lbrace: TokenIndex,\n\n            /// RecordField or StaticAssert\n            fields: FieldList,\n            rbrace: TokenIndex,\n        }","src":418,"more_decls":null}{"pl":"const FieldList = Root.DeclList","src":426,"more_decls":null}}{"pl":"pub const RecordField = struct ","src":429,"more_decls":{"pl":"base: Node = Node{ .id = .RecordField }","src":430,"more_decls":null}{"pl":"type_spec: TypeSpec","src":431,"more_decls":null}{"pl":"declarators: DeclaratorList","src":432,"more_decls":null}{"pl":"semicolon: TokenIndex","src":433,"more_decls":null}{"pl":"const DeclaratorList = Root.DeclList","src":435,"more_decls":null}}{"pl":"pub const RecordDeclarator = struct ","src":438,"more_decls":{"pl":"base: Node = Node{ .id = .RecordDeclarator }","src":439,"more_decls":null}{"pl":"declarator: ?*Declarator","src":440,"more_decls":null}{"pl":"bit_field_expr: ?*Expr","src":441,"more_decls":null}}{"pl":"pub const TypeQual = struct ","src":444,"more_decls":{"pl":"@\"const\": ?TokenIndex = null","src":445,"more_decls":null}{"pl":"atomic: ?TokenIndex = null","src":446,"more_decls":null}{"pl":"@\"volatile\": ?TokenIndex = null","src":447,"more_decls":null}{"pl":"restrict: ?TokenIndex = null","src":448,"more_decls":null}}{"pl":"pub const JumpStmt = struct ","src":451,"more_decls":{"pl":"base: Node = Node{ .id = .JumpStmt }","src":452,"more_decls":null}{"pl":"ltoken: TokenIndex","src":453,"more_decls":null}{"pl":"kind: union(enum) {\n            Break,\n            Continue,\n            Return: ?*Node,\n            Goto: TokenIndex,\n        }","src":454,"more_decls":null}{"pl":"semicolon: TokenIndex","src":460,"more_decls":null}}{"pl":"pub const ExprStmt = struct ","src":463,"more_decls":{"pl":"base: Node = Node{ .id = .ExprStmt }","src":464,"more_decls":null}{"pl":"expr: ?*Expr","src":465,"more_decls":null}{"pl":"semicolon: TokenIndex","src":466,"more_decls":null}}{"pl":"pub const LabeledStmt = struct ","src":469,"more_decls":{"pl":"base: Node = Node{ .id = .LabeledStmt }","src":470,"more_decls":null}{"pl":"kind: union(enum) {\n            Label: TokenIndex,\n            Case: TokenIndex,\n            Default: TokenIndex,\n        }","src":471,"more_decls":null}{"pl":"stmt: *Node","src":476,"more_decls":null}}{"pl":"pub const CompoundStmt = struct ","src":479,"more_decls":{"pl":"base: Node = Node{ .id = .CompoundStmt }","src":480,"more_decls":null}{"pl":"lbrace: TokenIndex","src":481,"more_decls":null}{"pl":"statements: StmtList","src":482,"more_decls":null}{"pl":"rbrace: TokenIndex","src":483,"more_decls":null}{"pl":"const StmtList = Root.DeclList","src":485,"more_decls":null}}{"pl":"pub const IfStmt = struct ","src":488,"more_decls":{"pl":"base: Node = Node{ .id = .IfStmt }","src":489,"more_decls":null}{"pl":"@\"if\": TokenIndex","src":490,"more_decls":null}{"pl":"cond: *Node","src":491,"more_decls":null}{"pl":"body: *Node","src":492,"more_decls":null}{"pl":"@\"else\": ?struct {\n            tok: TokenIndex,\n            body: *Node,\n        }","src":493,"more_decls":null}}{"pl":"pub const SwitchStmt = struct ","src":499,"more_decls":{"pl":"base: Node = Node{ .id = .SwitchStmt }","src":500,"more_decls":null}{"pl":"@\"switch\": TokenIndex","src":501,"more_decls":null}{"pl":"expr: *Expr","src":502,"more_decls":null}{"pl":"rparen: TokenIndex","src":503,"more_decls":null}{"pl":"stmt: *Node","src":504,"more_decls":null}}{"pl":"pub const WhileStmt = struct ","src":507,"more_decls":{"pl":"base: Node = Node{ .id = .WhileStmt }","src":508,"more_decls":null}{"pl":"@\"while\": TokenIndex","src":509,"more_decls":null}{"pl":"cond: *Expr","src":510,"more_decls":null}{"pl":"rparen: TokenIndex","src":511,"more_decls":null}{"pl":"body: *Node","src":512,"more_decls":null}}{"pl":"pub const DoStmt = struct ","src":515,"more_decls":{"pl":"base: Node = Node{ .id = .DoStmt }","src":516,"more_decls":null}{"pl":"do: TokenIndex","src":517,"more_decls":null}{"pl":"body: *Node","src":518,"more_decls":null}{"pl":"@\"while\": TokenIndex","src":519,"more_decls":null}{"pl":"cond: *Expr","src":520,"more_decls":null}{"pl":"semicolon: TokenIndex","src":521,"more_decls":null}}{"pl":"pub const ForStmt = struct ","src":524,"more_decls":{"pl":"base: Node = Node{ .id = .ForStmt }","src":525,"more_decls":null}{"pl":"@\"for\": TokenIndex","src":526,"more_decls":null}{"pl":"init: ?*Node","src":527,"more_decls":null}{"pl":"cond: ?*Expr","src":528,"more_decls":null}{"pl":"semicolon: TokenIndex","src":529,"more_decls":null}{"pl":"incr: ?*Expr","src":530,"more_decls":null}{"pl":"rparen: TokenIndex","src":531,"more_decls":null}{"pl":"body: *Node","src":532,"more_decls":null}}{"pl":"pub const StaticAssert = struct ","src":535,"more_decls":{"pl":"base: Node = Node{ .id = .StaticAssert }","src":536,"more_decls":null}{"pl":"assert: TokenIndex","src":537,"more_decls":null}{"pl":"expr: *Node","src":538,"more_decls":null}{"pl":"semicolon: TokenIndex","src":539,"more_decls":null}}{"pl":"pub const Declarator = struct ","src":542,"more_decls":{"pl":"base: Node = Node{ .id = .Declarator }","src":543,"more_decls":null}{"pl":"pointer: ?*Pointer","src":544,"more_decls":null}{"pl":"prefix: union(enum) {\n            None,\n            Identifer: TokenIndex,\n            Complex: struct {\n                lparen: TokenIndex,\n                inner: *Node,\n                rparen: TokenIndex,\n            },\n        }","src":545,"more_decls":null}{"pl":"suffix: union(enum) {\n            None,\n            Fn: struct {\n                lparen: TokenIndex,\n                params: Params,\n                rparen: TokenIndex,\n            },\n            Array: Arrays,\n        }","src":554,"more_decls":null}{"pl":"const Arrays = ArrayList(*Array)","src":564,"more_decls":null}{"pl":"const Params = ArrayList(*Param)","src":565,"more_decls":null}}{"pl":"pub const Array = struct ","src":568,"more_decls":{"pl":"lbracket: TokenIndex","src":569,"more_decls":null}{"pl":"inner: union(enum) {\n            Inferred,\n            Unspecified: TokenIndex,\n            Variable: struct {\n                asterisk: ?TokenIndex,\n                static: ?TokenIndex,\n                qual: TypeQual,\n                expr: *Expr,\n            },\n        }","src":570,"more_decls":null}{"pl":"rbracket: TokenIndex","src":580,"more_decls":null}}{"pl":"pub const Pointer = struct ","src":583,"more_decls":{"pl":"base: Node = Node{ .id = .Pointer }","src":584,"more_decls":null}{"pl":"asterisk: TokenIndex","src":585,"more_decls":null}{"pl":"qual: TypeQual","src":586,"more_decls":null}{"pl":"pointer: ?*Pointer","src":587,"more_decls":null}}{"pl":"pub const Param = struct ","src":590,"more_decls":{"pl":"kind: union(enum) {\n            Variable,\n            Old: TokenIndex,\n            Normal: struct {\n                decl_spec: *DeclSpec,\n                declarator: *Node,\n            },\n        }","src":591,"more_decls":null}}{"pl":"pub const FnDecl = struct ","src":601,"more_decls":{"pl":"base: Node = Node{ .id = .FnDecl }","src":602,"more_decls":null}{"pl":"decl_spec: DeclSpec","src":603,"more_decls":null}{"pl":"declarator: *Declarator","src":604,"more_decls":null}{"pl":"old_decls: OldDeclList","src":605,"more_decls":null}{"pl":"body: ?*CompoundStmt","src":606,"more_decls":null}{"pl":"const OldDeclList = ArrayList(*Node)","src":608,"more_decls":null}}{"pl":"pub const Typedef = struct ","src":611,"more_decls":{"pl":"base: Node = Node{ .id = .Typedef }","src":612,"more_decls":null}{"pl":"decl_spec: DeclSpec","src":613,"more_decls":null}{"pl":"declarators: DeclaratorList","src":614,"more_decls":null}{"pl":"semicolon: TokenIndex","src":615,"more_decls":null}{"pl":"const DeclaratorList = Root.DeclList","src":617,"more_decls":null}}{"pl":"pub const VarDecl = struct ","src":620,"more_decls":{"pl":"base: Node = Node{ .id = .VarDecl }","src":621,"more_decls":null}{"pl":"decl_spec: DeclSpec","src":622,"more_decls":null}{"pl":"initializers: Initializers","src":623,"more_decls":null}{"pl":"semicolon: TokenIndex","src":624,"more_decls":null}{"pl":"const Initializers = Root.DeclList","src":626,"more_decls":null}}{"pl":"pub const Initialized = struct ","src":629,"more_decls":{"pl":"base: Node = Node{ .id = Initialized }","src":630,"more_decls":null}{"pl":"declarator: *Declarator","src":631,"more_decls":null}{"pl":"eq: TokenIndex","src":632,"more_decls":null}{"pl":"init: Initializer","src":633,"more_decls":null}}{"pl":"pub const Initializer = union(enum) ","src":636,"more_decls":{"pl":"list: struct {\n            initializers: List,\n            rbrace: TokenIndex,\n        }","src":637,"more_decls":null}{"pl":"expr: *Expr","src":641,"more_decls":null}{"pl":"const List = ArrayList(*Initializer)","src":643,"more_decls":null}}{"pl":"pub const Macro = struct ","src":646,"more_decls":{"pl":"base: Node = Node{ .id = Macro }","src":647,"more_decls":null}{"pl":"kind: union(enum) {\n            Undef: []const u8,\n            Fn: struct {\n                params: []const []const u8,\n                expr: *Expr,\n            },\n            Expr: *Expr,\n        }","src":648,"more_decls":null}}}{"pl":"pub const Expr = struct ","src":659,"more_decls":{"pl":"id: Id","src":660,"more_decls":null}{"pl":"ty: *Type","src":661,"more_decls":null}{"pl":"value: union(enum) {\n        None,\n    }","src":662,"more_decls":null}{"pl":"pub const Id = enum ","src":666,"more_decls":{"pl":"Infix","src":667,"more_decls":null}{"pl":"Literal","src":668,"more_decls":null}}{"pl":"pub const Infix = struct ","src":671,"more_decls":{"pl":"base: Expr = Expr{ .id = .Infix }","src":672,"more_decls":null}{"pl":"lhs: *Expr","src":673,"more_decls":null}{"pl":"op_token: TokenIndex","src":674,"more_decls":null}{"pl":"op: Op","src":675,"more_decls":null}{"pl":"rhs: *Expr","src":676,"more_decls":null}{"pl":"pub const Op = enum ","src":678,"more_decls":}}}{"pl":"const TokenIndex = usize","src":10,"more_decls":null}]