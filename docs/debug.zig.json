[{"pl":"pub const LineInfo = struct ","src":40,"more_decls":{"pl":"line: u64","src":41,"more_decls":null}{"pl":"column: u64","src":42,"more_decls":null}{"pl":"file_name: []const u8","src":43,"more_decls":null}{"pl":"allocator: ?*mem.Allocator","src":44,"more_decls":null}}{"pl":"pub const StackIterator = struct ","src":331,"more_decls":{"pl":"first_address: ?usize","src":333,"more_decls":null}{"pl":"fp: usize","src":335,"more_decls":null}{"pl":"pub fn init(first_address: ?usize, fp: ?usize) StackIterator {\n    return StackIterator{\n        .first_address = first_address,\n        .fp = fp orelse @frameAddress(),\n    };\n}","src":337,"more_decls":null}{"pl":"fn next(self: *StackIterator) ?usize","src":368,"more_decls":null}}{"pl":"pub const TTY = struct ","src":447,"more_decls":{"pl":"pub const Color = enum ","src":448,"more_decls":{"pl":"Red","src":449,"more_decls":null}{"pl":"Green","src":450,"more_decls":null}{"pl":"Cyan","src":451,"more_decls":null}{"pl":"White","src":452,"more_decls":null}{"pl":"Dim","src":453,"more_decls":null}{"pl":"Bold","src":454,"more_decls":null}{"pl":"Reset","src":455,"more_decls":null}}{"pl":"pub const Config = enum ","src":458,"more_decls":{"pl":"no_color","src":459,"more_decls":null}{"pl":"escape_codes","src":460,"more_decls":null}{"pl":"windows_api","src":462,"more_decls":null}}}{"pl":"pub const DebugInfo = struct ","src":1106,"more_decls":{"pl":"allocator: *mem.Allocator","src":1107,"more_decls":null}{"pl":"address_map: std.AutoHashMap(usize, *ModuleDebugInfo)","src":1108,"more_decls":null}{"pl":"pub fn init(allocator: *mem.Allocator) DebugInfo {\n    return DebugInfo{\n        .allocator = allocator,\n        .address_map = std.AutoHashMap(usize, *ModuleDebugInfo).init(allocator),\n    };\n}","src":1110,"more_decls":null}{"pl":"pub fn deinit(self: *DebugInfo) void {\n    // TODO: resources https://github.com/ziglang/zig/issues/4353\n    self.address_map.deinit();\n}","src":1117,"more_decls":null}{"pl":"fn getModuleForAddress(self: *DebugInfo, address: usize) !*ModuleDebugInfo","src":1122,"more_decls":null}}{"doc_comment":"Print to stderr, unbuffered, and silently returning on failure. Intended\nfor use in \"printf debugging.\" Use `std.log` functions for proper logging.","pl":"pub fn print(comptime fmt: []const u8, args: anytype) void {\n    const held = stderr_mutex.acquire();\n    defer held.release();\n    const stderr = io.getStdErr().writer();\n    nosuspend stderr.print(fmt, args) catch return;\n}","src":60,"more_decls":null}{"pl":"pub fn getStderrMutex() *std.Thread.Mutex {\n    return &stderr_mutex;\n}","src":67,"more_decls":null}{"pl":"fn getSelfDebugInfo() !*DebugInfo","src":74,"more_decls":null}{"pl":"fn detectTTYConfig() TTY.Config","src":83,"more_decls":null}{"doc_comment":"Tries to print the current stack trace to stderr, unbuffered, and ignores any error returned.\nTODO multithreaded awareness","pl":"fn dumpCurrentStackTrace(start_addr: ?usize) void","src":102,"more_decls":null}{"doc_comment":"Tries to print the stack trace starting from the supplied base pointer to stderr,\nunbuffered, and ignores any error returned.\nTODO multithreaded awareness","pl":"fn dumpStackTraceFromBase(bp: usize, ip: usize) void","src":123,"more_decls":null}{"doc_comment":"Returns a slice with the same pointer as addresses, with a potentially smaller len.\nOn Windows, when first_address is not null, we ask for at least 32 stack frames,\nand then try to find the first address. If addresses.len is more than 32, we\ncapture that many stack frames exactly, and then look for the first address,\nchopping off the irrelevant frames and shifting so that the returned addresses pointer\nequals the passed in addresses pointer.","pl":"fn captureStackTrace(first_address: ?usize, stack_trace: *builtin.StackTrace) void","src":149,"more_decls":null}{"doc_comment":"Tries to print a stack trace to stderr, unbuffered, and ignores any error returned.\nTODO multithreaded awareness","pl":"fn dumpStackTrace(stack_trace: builtin.StackTrace) void","src":193,"more_decls":null}{"doc_comment":"This function invokes undefined behavior when `ok` is `false`.\nIn Debug and ReleaseSafe modes, calls to this function are always\ngenerated, and the `unreachable` statement triggers a panic.\nIn ReleaseFast and ReleaseSmall modes, calls to this function are\noptimized away, and in fact the optimizer is able to use the assertion\nin its heuristics.\nInside a test block, it is best to use the `std.testing` module rather\nthan this function, because this function may not detect a test failure\nin ReleaseFast and ReleaseSmall mode. Outside of a test block, this assert\nfunction is the correct function to use.","pl":"pub fn assert(ok: bool) void {\n    if (!ok) unreachable; // assertion failure\n}","src":221,"more_decls":null}{"pl":"pub fn panic(comptime format: []const u8, args: anytype) noreturn {\n    @setCold(true);\n    // TODO: remove conditional once wasi / LLVM defines __builtin_return_address\n    const first_trace_addr = if (builtin.os.tag == .wasi) null else @returnAddress();\n    panicExtra(null, first_trace_addr, format, args);\n}","src":225,"more_decls":null}{"pl":"fn panicExtra(trace: ?*const builtin.StackTrace, first_trace_addr: ?usize, comptime format: []const u8, args: anytype) noreturn","src":243,"more_decls":null}{"pl":"fn writeStackTrace(\n    stack_trace: builtin.StackTrace,\n    out_stream: anytype,\n    allocator: *mem.Allocator,\n    debug_info: *DebugInfo,\n    tty_config: TTY.Config,\n) !void","src":311,"more_decls":null}{"pl":"fn writeCurrentStackTrace(\n    out_stream: anytype,\n    debug_info: *DebugInfo,\n    tty_config: TTY.Config,\n    start_addr: ?usize,\n) !void","src":412,"more_decls":null}{"pl":"fn writeCurrentStackTraceWindows(\n    out_stream: anytype,\n    debug_info: *DebugInfo,\n    tty_config: TTY.Config,\n    start_addr: ?usize,\n) !void","src":427,"more_decls":null}{"doc_comment":"TODO resources https://github.com/ziglang/zig/issues/4353","pl":"fn printSourceAtAddress(debug_info: *DebugInfo, out_stream: anytype, address: usize, tty_config: TTY.Config) !void","src":584,"more_decls":null}{"doc_comment":"TODO resources https://github.com/ziglang/zig/issues/4353","pl":"fn openSelfDebugInfo(allocator: *mem.Allocator) anyerror!DebugInfo","src":670,"more_decls":null}{"doc_comment":"This takes ownership of elf_file: users of this function should not close\nit themselves, even on error.\nTODO resources https://github.com/ziglang/zig/issues/4353\nTODO it's weird to take ownership even on error, rework this code.","pl":"fn readElfDebugInfo(allocator: *mem.Allocator, elf_file: File) !ModuleDebugInfo","src":878,"more_decls":null}{"pl":"pub fn maybeEnableSegfaultHandler() void {\n    if (enable_segfault_handler) {\n        std.debug.attachSegfaultHandler();\n    }\n}","src":1733,"more_decls":null}{"doc_comment":"Attaches a global SIGSEGV handler which calls @panic(\"segmentation fault\");","pl":"fn attachSegfaultHandler() void","src":1742,"more_decls":null}{"pl":"pub fn dumpStackPointerAddr(prefix: []const u8) void {\n    const sp = asm (\"\"\n        : [argc] \"={rsp}\" (-> usize)\n    );\n    std.debug.warn(\"{} sp = 0x{x}\\n\", .{ prefix, sp });\n}","src":1887,"more_decls":null}{"pl":"const runtime_safety = switch (builtin.mode) {\n    .Debug, .ReleaseSafe => true,\n    .ReleaseFast, .ReleaseSmall => false,\n}","src":24,"more_decls":null}{"doc_comment":"Deprecated. Use `std.log` functions for logging or `std.debug.print` for\n\"printf debugging\".","pl":"const warn = print","src":56,"more_decls":null}{"pl":"const OpenSelfDebugInfoError = error{\n    MissingDebugInfo,\n    OutOfMemory,\n    UnsupportedOperatingSystem,\n}","src":663,"more_decls":null}{"pl":"const ModuleDebugInfo = switch (builtin.os.tag) {\n    .macos, .ios, .watchos, .tvos => struct {\n        base_address: usize,\n        mapped_memory: []const u8,\n        symbols: []const MachoSymbol,\n        strings: [:0]const u8,\n        ofiles: OFileTable,\n\n        const OFileTable = std.StringHashMap(DW.DwarfInfo);\n\n        pub fn allocator(self: @This()) *mem.Allocator {\n            return self.ofiles.allocator;\n        }\n\n        fn loadOFile(self: *@This(), o_file_path: []const u8) !DW.DwarfInfo {\n            const o_file = try fs.cwd().openFile(o_file_path, .{ .intended_io_mode = .blocking });\n            const mapped_mem = try mapWholeFile(o_file);\n\n            const hdr = @ptrCast(\n                *const macho.mach_header_64,\n                @alignCast(@alignOf(macho.mach_header_64), mapped_mem.ptr),\n            );\n            if (hdr.magic != std.macho.MH_MAGIC_64)\n                return error.InvalidDebugInfo;\n\n            const hdr_base = @ptrCast([*]const u8, hdr);\n            var ptr = hdr_base + @sizeOf(macho.mach_header_64);\n            var ncmd: u32 = hdr.ncmds;\n            const segcmd = while (ncmd != 0) : (ncmd -= 1) {\n                const lc = @ptrCast(*const std.macho.load_command, ptr);\n                switch (lc.cmd) {\n                    std.macho.LC_SEGMENT_64 => {\n                        break @ptrCast(\n                            *const std.macho.segment_command_64,\n                            @alignCast(@alignOf(std.macho.segment_command_64), ptr),\n                        );\n                    },\n                    else => {},\n                }\n                ptr = @alignCast(@alignOf(std.macho.load_command), ptr + lc.cmdsize);\n            } else {\n                return error.MissingDebugInfo;\n            };\n\n            var opt_debug_line: ?*const macho.section_64 = null;\n            var opt_debug_info: ?*const macho.section_64 = null;\n            var opt_debug_abbrev: ?*const macho.section_64 = null;\n            var opt_debug_str: ?*const macho.section_64 = null;\n            var opt_debug_ranges: ?*const macho.section_64 = null;\n\n            const sections = @ptrCast(\n                [*]const macho.section_64,\n                @alignCast(@alignOf(macho.section_64), ptr + @sizeOf(std.macho.segment_command_64)),\n            )[0..segcmd.nsects];\n            for (sections) |*sect| {\n                // The section name may not exceed 16 chars and a trailing null may\n                // not be present\n                const name = if (mem.indexOfScalar(u8, sect.sectname[0..], 0)) |last|\n                    sect.sectname[0..last]\n                else\n                    sect.sectname[0..];\n\n                if (mem.eql(u8, name, \"__debug_line\")) {\n                    opt_debug_line = sect;\n                } else if (mem.eql(u8, name, \"__debug_info\")) {\n                    opt_debug_info = sect;\n                } else if (mem.eql(u8, name, \"__debug_abbrev\")) {\n                    opt_debug_abbrev = sect;\n                } else if (mem.eql(u8, name, \"__debug_str\")) {\n                    opt_debug_str = sect;\n                } else if (mem.eql(u8, name, \"__debug_ranges\")) {\n                    opt_debug_ranges = sect;\n                }\n            }\n\n            const debug_line = opt_debug_line orelse\n                return error.MissingDebugInfo;\n            const debug_info = opt_debug_info orelse\n                return error.MissingDebugInfo;\n            const debug_str = opt_debug_str orelse\n                return error.MissingDebugInfo;\n            const debug_abbrev = opt_debug_abbrev orelse\n                return error.MissingDebugInfo;\n\n            var di = DW.DwarfInfo{\n                .endian = .Little,\n                .debug_info = try chopSlice(mapped_mem, debug_info.offset, debug_info.size),\n                .debug_abbrev = try chopSlice(mapped_mem, debug_abbrev.offset, debug_abbrev.size),\n                .debug_str = try chopSlice(mapped_mem, debug_str.offset, debug_str.size),\n                .debug_line = try chopSlice(mapped_mem, debug_line.offset, debug_line.size),\n                .debug_ranges = if (opt_debug_ranges) |debug_ranges|\n                    try chopSlice(mapped_mem, debug_ranges.offset, debug_ranges.size)\n                else\n                    null,\n            };\n\n            try DW.openDwarfDebugInfo(&di, self.allocator());\n\n            // Add the debug info to the cache\n            try self.ofiles.putNoClobber(o_file_path, di);\n\n            return di;\n        }\n\n        pub fn getSymbolAtAddress(self: *@This(), address: usize) !SymbolInfo {\n            nosuspend {\n                // Translate the VA into an address into this object\n                const relocated_address = address - self.base_address;\n                assert(relocated_address >= 0x100000000);\n\n                // Find the .o file where this symbol is defined\n                const symbol = machoSearchSymbols(self.symbols, relocated_address) orelse\n                    return SymbolInfo{};\n\n                // Take the symbol name from the N_FUN STAB entry, we're going to\n                // use it if we fail to find the DWARF infos\n                const stab_symbol = mem.spanZ(self.strings[symbol.nlist.n_strx..]);\n\n                if (symbol.ofile == null)\n                    return SymbolInfo{ .symbol_name = stab_symbol };\n\n                const o_file_path = mem.spanZ(self.strings[symbol.ofile.?.n_strx..]);\n\n                // Check if its debug infos are already in the cache\n                var o_file_di = self.ofiles.get(o_file_path) orelse\n                    (self.loadOFile(o_file_path) catch |err| switch (err) {\n                    error.FileNotFound,\n                    error.MissingDebugInfo,\n                    error.InvalidDebugInfo,\n                    => {\n                        return SymbolInfo{ .symbol_name = stab_symbol };\n                    },\n                    else => return err,\n                });\n\n                // Translate again the address, this time into an address inside the\n                // .o file\n                const relocated_address_o = relocated_address - symbol.reloc;\n\n                if (o_file_di.findCompileUnit(relocated_address_o)) |compile_unit| {\n                    return SymbolInfo{\n                        .symbol_name = o_file_di.getSymbolName(relocated_address_o) orelse \"???\",\n                        .compile_unit_name = compile_unit.die.getAttrString(&o_file_di, DW.AT_name) catch |err| switch (err) {\n                            error.MissingDebugInfo, error.InvalidDebugInfo => \"???\",\n                            else => return err,\n                        },\n                        .line_info = o_file_di.getLineNumberInfo(compile_unit.*, relocated_address_o) catch |err| switch (err) {\n                            error.MissingDebugInfo, error.InvalidDebugInfo => null,\n                            else => return err,\n                        },\n                    };\n                } else |err| switch (err) {\n                    error.MissingDebugInfo, error.InvalidDebugInfo => {\n                        return SymbolInfo{ .symbol_name = stab_symbol };\n                    },\n                    else => return err,\n                }\n\n                unreachable;\n            }\n        }\n    },\n    .uefi, .windows => struct {\n        base_address: usize,\n        pdb: pdb.Pdb,\n        coff: *coff.Coff,\n        sect_contribs: []pdb.SectionContribEntry,\n        modules: []Module,\n\n        pub fn allocator(self: @This()) *mem.Allocator {\n            return self.coff.allocator;\n        }\n\n        pub fn getSymbolAtAddress(self: *@This(), address: usize) !SymbolInfo {\n            // Translate the VA into an address into this object\n            const relocated_address = address - self.base_address;\n\n            var coff_section: *coff.Section = undefined;\n            const mod_index = for (self.sect_contribs) |sect_contrib| {\n                if (sect_contrib.Section > self.coff.sections.items.len) continue;\n                // Remember that SectionContribEntry.Section is 1-based.\n                coff_section = &self.coff.sections.items[sect_contrib.Section - 1];\n\n                const vaddr_start = coff_section.header.virtual_address + sect_contrib.Offset;\n                const vaddr_end = vaddr_start + sect_contrib.Size;\n                if (relocated_address >= vaddr_start and relocated_address < vaddr_end) {\n                    break sect_contrib.ModuleIndex;\n                }\n            } else {\n                // we have no information to add to the address\n                return SymbolInfo{};\n            };\n\n            const mod = &self.modules[mod_index];\n            try populateModule(self, mod);\n            const obj_basename = fs.path.basename(mod.obj_file_name);\n\n            var symbol_i: usize = 0;\n            const symbol_name = if (!mod.populated) \"???\" else while (symbol_i != mod.symbols.len) {\n                const prefix = @ptrCast(*pdb.RecordPrefix, &mod.symbols[symbol_i]);\n                if (prefix.RecordLen < 2)\n                    return error.InvalidDebugInfo;\n                switch (prefix.RecordKind) {\n                    .S_LPROC32, .S_GPROC32 => {\n                        const proc_sym = @ptrCast(*pdb.ProcSym, &mod.symbols[symbol_i + @sizeOf(pdb.RecordPrefix)]);\n                        const vaddr_start = coff_section.header.virtual_address + proc_sym.CodeOffset;\n                        const vaddr_end = vaddr_start + proc_sym.CodeSize;\n                        if (relocated_address >= vaddr_start and relocated_address < vaddr_end) {\n                            break mem.spanZ(@ptrCast([*:0]u8, proc_sym) + @sizeOf(pdb.ProcSym));\n                        }\n                    },\n                    else => {},\n                }\n                symbol_i += prefix.RecordLen + @sizeOf(u16);\n                if (symbol_i > mod.symbols.len)\n                    return error.InvalidDebugInfo;\n            } else \"???\";\n\n            const subsect_info = mod.subsect_info;\n\n            var sect_offset: usize = 0;\n            var skip_len: usize = undefined;\n            const opt_line_info = subsections: {\n                const checksum_offset = mod.checksum_offset orelse break :subsections null;\n                while (sect_offset != subsect_info.len) : (sect_offset += skip_len) {\n                    const subsect_hdr = @ptrCast(*pdb.DebugSubsectionHeader, &subsect_info[sect_offset]);\n                    skip_len = subsect_hdr.Length;\n                    sect_offset += @sizeOf(pdb.DebugSubsectionHeader);\n\n                    switch (subsect_hdr.Kind) {\n                        .Lines => {\n                            var line_index = sect_offset;\n\n                            const line_hdr = @ptrCast(*pdb.LineFragmentHeader, &subsect_info[line_index]);\n                            if (line_hdr.RelocSegment == 0)\n                                return error.MissingDebugInfo;\n                            line_index += @sizeOf(pdb.LineFragmentHeader);\n                            const frag_vaddr_start = coff_section.header.virtual_address + line_hdr.RelocOffset;\n                            const frag_vaddr_end = frag_vaddr_start + line_hdr.CodeSize;\n\n                            if (relocated_address >= frag_vaddr_start and relocated_address < frag_vaddr_end) {\n                                // There is an unknown number of LineBlockFragmentHeaders (and their accompanying line and column records)\n                                // from now on. We will iterate through them, and eventually find a LineInfo that we're interested in,\n                                // breaking out to :subsections. If not, we will make sure to not read anything outside of this subsection.\n                                const subsection_end_index = sect_offset + subsect_hdr.Length;\n\n                                while (line_index < subsection_end_index) {\n                                    const block_hdr = @ptrCast(*pdb.LineBlockFragmentHeader, &subsect_info[line_index]);\n                                    line_index += @sizeOf(pdb.LineBlockFragmentHeader);\n                                    const start_line_index = line_index;\n\n                                    const has_column = line_hdr.Flags.LF_HaveColumns;\n\n                                    // All line entries are stored inside their line block by ascending start address.\n                                    // Heuristic: we want to find the last line entry\n                                    // that has a vaddr_start <= relocated_address.\n                                    // This is done with a simple linear search.\n                                    var line_i: u32 = 0;\n                                    while (line_i < block_hdr.NumLines) : (line_i += 1) {\n                                        const line_num_entry = @ptrCast(*pdb.LineNumberEntry, &subsect_info[line_index]);\n                                        line_index += @sizeOf(pdb.LineNumberEntry);\n\n                                        const vaddr_start = frag_vaddr_start + line_num_entry.Offset;\n                                        if (relocated_address < vaddr_start) {\n                                            break;\n                                        }\n                                    }\n\n                                    // line_i == 0 would mean that no matching LineNumberEntry was found.\n                                    if (line_i > 0) {\n                                        const subsect_index = checksum_offset + block_hdr.NameIndex;\n                                        const chksum_hdr = @ptrCast(*pdb.FileChecksumEntryHeader, &mod.subsect_info[subsect_index]);\n                                        const strtab_offset = @sizeOf(pdb.PDBStringTableHeader) + chksum_hdr.FileNameOffset;\n                                        try self.pdb.string_table.seekTo(strtab_offset);\n                                        const source_file_name = try self.pdb.string_table.readNullTermString(self.allocator());\n\n                                        const line_entry_idx = line_i - 1;\n\n                                        const column = if (has_column) blk: {\n                                            const start_col_index = start_line_index + @sizeOf(pdb.LineNumberEntry) * block_hdr.NumLines;\n                                            const col_index = start_col_index + @sizeOf(pdb.ColumnNumberEntry) * line_entry_idx;\n                                            const col_num_entry = @ptrCast(*pdb.ColumnNumberEntry, &subsect_info[col_index]);\n                                            break :blk col_num_entry.StartColumn;\n                                        } else 0;\n\n                                        const found_line_index = start_line_index + line_entry_idx * @sizeOf(pdb.LineNumberEntry);\n                                        const line_num_entry = @ptrCast(*pdb.LineNumberEntry, &subsect_info[found_line_index]);\n                                        const flags = @ptrCast(*pdb.LineNumberEntry.Flags, &line_num_entry.Flags);\n\n                                        break :subsections LineInfo{\n                                            .allocator = self.allocator(),\n                                            .file_name = source_file_name,\n                                            .line = flags.Start,\n                                            .column = column,\n                                        };\n                                    }\n                                }\n\n                                // Checking that we are not reading garbage after the (possibly) multiple block fragments.\n                                if (line_index != subsection_end_index) {\n                                    return error.InvalidDebugInfo;\n                                }\n                            }\n                        },\n                        else => {},\n                    }\n\n                    if (sect_offset > subsect_info.len)\n                        return error.InvalidDebugInfo;\n                } else {\n                    break :subsections null;\n                }\n            };\n\n            return SymbolInfo{\n                .symbol_name = symbol_name,\n                .compile_unit_name = obj_basename,\n                .line_info = opt_line_info,\n            };\n        }\n    },\n    .linux, .netbsd, .freebsd, .dragonfly, .openbsd => struct {\n        base_address: usize,\n        dwarf: DW.DwarfInfo,\n        mapped_memory: []const u8,\n\n        pub fn getSymbolAtAddress(self: *@This(), address: usize) !SymbolInfo {\n            // Translate the VA into an address into this object\n            const relocated_address = address - self.base_address;\n\n            if (nosuspend self.dwarf.findCompileUnit(relocated_address)) |compile_unit| {\n                return SymbolInfo{\n                    .symbol_name = nosuspend self.dwarf.getSymbolName(relocated_address) orelse \"???\",\n                    .compile_unit_name = compile_unit.die.getAttrString(&self.dwarf, DW.AT_name) catch |err| switch (err) {\n                        error.MissingDebugInfo, error.InvalidDebugInfo => \"???\",\n                        else => return err,\n                    },\n                    .line_info = nosuspend self.dwarf.getLineNumberInfo(compile_unit.*, relocated_address) catch |err| switch (err) {\n                        error.MissingDebugInfo, error.InvalidDebugInfo => null,\n                        else => return err,\n                    },\n                };\n            } else |err| switch (err) {\n                error.MissingDebugInfo, error.InvalidDebugInfo => {\n                    return SymbolInfo{};\n                },\n                else => return err,\n            }\n\n            unreachable;\n        }\n    },\n    else => DW.DwarfInfo,\n}","src":1355,"more_decls":null}{"doc_comment":"Whether or not the current target can print useful debug information when a segfault occurs.","pl":"const have_segfault_handling_support = switch (builtin.os.tag) {\n    .linux, .netbsd => true,\n    .windows => true,\n    .freebsd, .openbsd => @hasDecl(os, \"ucontext_t\"),\n    else => false,\n}","src":1722,"more_decls":null}{"pl":"const enable_segfault_handler: bool = if (@hasDecl(root, \"enable_segfault_handler\"))\n    root.enable_segfault_handler\nelse\n    runtime_safety and have_segfault_handling_support","src":1728,"more_decls":null}]