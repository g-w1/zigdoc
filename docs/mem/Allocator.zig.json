[{"doc_comment":"Attempt to allocate at least `len` bytes aligned to `ptr_align`.\n\nIf `len_align` is `0`, then the length returned MUST be exactly `len` bytes,\notherwise, the length must be aligned to `len_align`.\n\n`len` must be greater than or equal to `len_align` and must be aligned by `len_align`.\n\n`ret_addr` is optionally provided as the first return address of the allocation call stack.\nIf the value is `0` it means no return address has been provided.","pl":"allocFn: fn (self: *Allocator, len: usize, ptr_align: u29, len_align: u29, ret_addr: usize) Error![]u8","src":24,"more_decls":null}{"doc_comment":"Attempt to expand or shrink memory in place. `buf.len` must equal the most recent\nlength returned by `allocFn` or `resizeFn`. `buf_align` must equal the same value\nthat was passed as the `ptr_align` parameter to the original `allocFn` call.\n\nPassing a `new_len` of 0 frees and invalidates the buffer such that it can no\nlonger be passed to `resizeFn`.\n\nerror.OutOfMemory can only be returned if `new_len` is greater than `buf.len`.\nIf `buf` cannot be expanded to accomodate `new_len`, then the allocation MUST be\nunmodified and error.OutOfMemory MUST be returned.\n\nIf `len_align` is `0`, then the length returned MUST be exactly `len` bytes,\notherwise, the length must be aligned to `len_align`. Note that `len_align` does *not*\nprovide a way to modify the alignment of a pointer. Rather it provides an API for\naccepting more bytes of memory from the allocator than requested.\n\n`new_len` must be greater than or equal to `len_align` and must be aligned by `len_align`.\n\n`ret_addr` is optionally provided as the first return address of the allocation call stack.\nIf the value is `0` it means no return address has been provided.","pl":"resizeFn: fn (self: *Allocator, buf: []u8, buf_align: u29, new_len: usize, len_align: u29, ret_addr: usize) Error!usize","src":46,"more_decls":null}{"pl":"pub const Exact = enum ","src":260,"more_decls":{"pl":"exact","src":260,"more_decls":null}{"pl":"at_least ","src":260,"more_decls":null}}{"doc_comment":"Set to resizeFn if in-place resize is not supported.","pl":"fn noResize(\n    self: *Allocator,\n    buf: []u8,\n    buf_align: u29,\n    new_len: usize,\n    len_align: u29,\n    ret_addr: usize,\n) Error!usize","src":49,"more_decls":null}{"doc_comment":"Returns a pointer to undefined memory.\nCall `destroy` with the result to free the memory.","pl":"pub fn create(self: *Allocator, comptime T: type) Error!*T {\n    if (@sizeOf(T) == 0) return @as(*T, undefined);\n    const slice = try self.allocAdvancedWithRetAddr(T, null, 1, .exact, @returnAddress());\n    return &slice[0];\n}","src":156,"more_decls":null}{"doc_comment":"`ptr` should be the return value of `create`, or otherwise\nhave the same address and alignment property.","pl":"fn destroy(self: *Allocator, ptr: anytype) void","src":164,"more_decls":null}{"doc_comment":"Allocates an array of `n` items of type `T` and sets all the\nitems to `undefined`. Depending on the Allocator\nimplementation, it may be required to call `free` once the\nmemory is no longer needed, to avoid a resource leak. If the\n`Allocator` implementation is unknown, then correct code will\ncall `free` when done.\n\nFor allocating a single item, see `create`.","pl":"pub fn alloc(self: *Allocator, comptime T: type, n: usize) Error![]T {\n    return self.allocAdvancedWithRetAddr(T, null, n, .exact, @returnAddress());\n}","src":180,"more_decls":null}{"pl":"fn allocWithOptions(\n    self: *Allocator,\n    comptime Elem: type,\n    n: usize,\n    /// null means naturally aligned\n    comptime optional_alignment: ?u29,\n    comptime optional_sentinel: ?Elem,\n) Error!AllocWithOptionsPayload(Elem, optional_alignment, optional_sentinel)","src":184,"more_decls":null}{"pl":"fn allocWithOptionsRetAddr(\n    self: *Allocator,\n    comptime Elem: type,\n    n: usize,\n    /// null means naturally aligned\n    comptime optional_alignment: ?u29,\n    comptime optional_sentinel: ?Elem,\n    return_address: usize,\n) Error!AllocWithOptionsPayload(Elem, optional_alignment, optional_sentinel)","src":195,"more_decls":null}{"doc_comment":"Allocates an array of `n + 1` items of type `T` and sets the first `n`\nitems to `undefined` and the last item to `sentinel`. Depending on the\nAllocator implementation, it may be required to call `free` once the\nmemory is no longer needed, to avoid a resource leak. If the\n`Allocator` implementation is unknown, then correct code will\ncall `free` when done.\n\nFor allocating a single item, see `create`.","pl":"fn allocSentinel(\n    self: *Allocator,\n    comptime Elem: type,\n    n: usize,\n    comptime sentinel: Elem,\n) Error![:sentinel]Elem","src":229,"more_decls":null}{"doc_comment":"Deprecated: use `allocAdvanced`","pl":"fn alignedAlloc(\n    self: *Allocator,\n    comptime T: type,\n    /// null means naturally aligned\n    comptime alignment: ?u29,\n    n: usize,\n) Error![]align(alignment orelse @alignOf(T)) T","src":239,"more_decls":null}{"pl":"fn allocAdvanced(\n    self: *Allocator,\n    comptime T: type,\n    /// null means naturally aligned\n    comptime alignment: ?u29,\n    n: usize,\n    exact: Exact,\n) Error![]align(alignment orelse @alignOf(T)) T","src":249,"more_decls":null}{"pl":"fn allocAdvancedWithRetAddr(\n    self: *Allocator,\n    comptime T: type,\n    /// null means naturally aligned\n    comptime alignment: ?u29,\n    n: usize,\n    exact: Exact,\n    return_address: usize,\n) Error![]align(alignment orelse @alignOf(T)) T","src":262,"more_decls":null}{"doc_comment":"Increases or decreases the size of an allocation. It is guaranteed to not move the pointer.","pl":"fn resize(self: *Allocator, old_mem: anytype, new_n: usize) Error!@TypeOf(old_mem)","src":305,"more_decls":null}{"doc_comment":"This function requests a new byte size for an existing allocation,\nwhich can be larger, smaller, or the same size as the old memory\nallocation.\nThis function is preferred over `shrink`, because it can fail, even\nwhen shrinking. This gives the allocator a chance to perform a\ncheap shrink operation if possible, or otherwise return OutOfMemory,\nindicating that the caller should keep their capacity, for example\nin `std.ArrayList.shrink`.\nIf you need guaranteed success, call `shrink`.\nIf `new_n` is 0, this is the same as `free` and it always succeeds.","pl":"fn realloc(self: *Allocator, old_mem: anytype, new_n: usize) t: {\n    const Slice = @typeInfo(@TypeOf(old_mem)).Pointer;\n    break :t Error![]align(Slice.alignment) Slice.child;\n}","src":330,"more_decls":null}{"pl":"fn reallocAtLeast(self: *Allocator, old_mem: anytype, new_n: usize) t: {\n    const Slice = @typeInfo(@TypeOf(old_mem)).Pointer;\n    break :t Error![]align(Slice.alignment) Slice.child;\n}","src":338,"more_decls":null}{"doc_comment":"This is the same as `realloc`, except caller may additionally request\na new alignment, which can be larger, smaller, or the same as the old\nallocation.","pl":"fn reallocAdvanced(\n    self: *Allocator,\n    old_mem: anytype,\n    comptime new_alignment: u29,\n    new_n: usize,\n    exact: Exact,\n) Error![]align(new_alignment) @typeInfo(@TypeOf(old_mem)).Pointer.child","src":349,"more_decls":null}{"pl":"fn reallocAdvancedWithRetAddr(\n    self: *Allocator,\n    old_mem: anytype,\n    comptime new_alignment: u29,\n    new_n: usize,\n    exact: Exact,\n    return_address: usize,\n) Error![]align(new_alignment) @typeInfo(@TypeOf(old_mem)).Pointer.child","src":359,"more_decls":null}{"doc_comment":"Prefer calling realloc to shrink if you can tolerate failure, such as\nin an ArrayList data structure with a storage capacity.\nShrink always succeeds, and `new_n` must be <= `old_mem.len`.\nReturned slice has same alignment as old_mem.\nShrinking to 0 is the same as calling `free`.","pl":"fn shrink(self: *Allocator, old_mem: anytype, new_n: usize) t: {\n    const Slice = @typeInfo(@TypeOf(old_mem)).Pointer;\n    break :t []align(Slice.alignment) Slice.child;\n}","src":393,"more_decls":null}{"doc_comment":"This is the same as `shrink`, except caller may additionally request\na new alignment, which must be smaller or the same as the old\nallocation.","pl":"fn alignedShrink(\n    self: *Allocator,\n    old_mem: anytype,\n    comptime new_alignment: u29,\n    new_n: usize,\n) []align(new_alignment) @typeInfo(@TypeOf(old_mem)).Pointer.child","src":404,"more_decls":null}{"doc_comment":"This is the same as `alignedShrink`, except caller may additionally pass\nthe return address of the first stack frame, which may be relevant for\nallocators which collect stack traces.","pl":"fn alignedShrinkWithRetAddr(\n    self: *Allocator,\n    old_mem: anytype,\n    comptime new_alignment: u29,\n    new_n: usize,\n    return_address: usize,\n) []align(new_alignment) @typeInfo(@TypeOf(old_mem)).Pointer.child","src":416,"more_decls":null}{"doc_comment":"Free an array allocated with `alloc`. To free a single item,\nsee `destroy`.","pl":"fn free(self: *Allocator, memory: anytype) void","src":444,"more_decls":null}{"doc_comment":"Copies `m` to newly allocated memory. Caller owns the memory.","pl":"pub fn dupe(allocator: *Allocator, comptime T: type, m: []const T) ![]T {\n    const new_buf = try allocator.alloc(T, m.len);\n    mem.copy(T, new_buf, m);\n    return new_buf;\n}","src":456,"more_decls":null}{"doc_comment":"Copies `m` to newly allocated memory, with a null-terminated element. Caller owns the memory.","pl":"pub fn dupeZ(allocator: *Allocator, comptime T: type, m: []const T) ![:0]T {\n    const new_buf = try allocator.alloc(T, m.len + 1);\n    mem.copy(T, new_buf, m);\n    new_buf[m.len] = 0;\n    return new_buf[0..m.len :0];\n}","src":463,"more_decls":null}{"doc_comment":"Call `resizeFn`, but caller guarantees that `new_len` <= `buf.len` meaning\nerror.OutOfMemory should be impossible.\nThis function allows a runtime `buf_align` value. Callers should generally prefer\nto call `shrink` directly.","pl":"fn shrinkBytes(\n    self: *Allocator,\n    buf: []u8,\n    buf_align: u29,\n    new_len: usize,\n    len_align: u29,\n    return_address: usize,\n) usize","src":474,"more_decls":null}{"pl":"const Error = error{OutOfMemory}","src":13,"more_decls":null}]