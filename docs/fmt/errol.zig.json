[{"pl":"pub const FloatDecimal = struct ","src":14,"more_decls":{"pl":"digits: []u8","src":15,"more_decls":null}{"pl":"exp: i32","src":16,"more_decls":null}}{"pl":"pub const RoundMode = enum ","src":19,"more_decls":{"pl":"Decimal","src":21,"more_decls":null}{"pl":"Scientific","src":23,"more_decls":null}}{"doc_comment":"Round a FloatDecimal as returned by errol3 to the specified fractional precision.\nAll digits after the specified precision should be considered invalid.","pl":"fn roundToPrecision(float_decimal: *FloatDecimal, precision: usize, mode: RoundMode) void","src":28,"more_decls":null}{"doc_comment":"Corrected Errol3 double to ASCII conversion.","pl":"fn errol3(value: f64, buffer: []u8) FloatDecimal","src":86,"more_decls":null}{"pl":"const c_digits_lut = [_]u8{\n    '0', '0', '0', '1', '0', '2', '0', '3', '0', '4', '0', '5', '0', '6',\n    '0', '7', '0', '8', '0', '9', '1', '0', '1', '1', '1', '2', '1', '3',\n    '1', '4', '1', '5', '1', '6', '1', '7', '1', '8', '1', '9', '2', '0',\n    '2', '1', '2', '2', '2', '3', '2', '4', '2', '5', '2', '6', '2', '7',\n    '2', '8', '2', '9', '3', '0', '3', '1', '3', '2', '3', '3', '3', '4',\n    '3', '5', '3', '6', '3', '7', '3', '8', '3', '9', '4', '0', '4', '1',\n    '4', '2', '4', '3', '4', '4', '4', '5', '4', '6', '4', '7', '4', '8',\n    '4', '9', '5', '0', '5', '1', '5', '2', '5', '3', '5', '4', '5', '5',\n    '5', '6', '5', '7', '5', '8', '5', '9', '6', '0', '6', '1', '6', '2',\n    '6', '3', '6', '4', '6', '5', '6', '6', '6', '7', '6', '8', '6', '9',\n    '7', '0', '7', '1', '7', '2', '7', '3', '7', '4', '7', '5', '7', '6',\n    '7', '7', '7', '8', '7', '9', '8', '0', '8', '1', '8', '2', '8', '3',\n    '8', '4', '8', '5', '8', '6', '8', '7', '8', '8', '8', '9', '9', '0',\n    '9', '1', '9', '2', '9', '3', '9', '4', '9', '5', '9', '6', '9', '7',\n    '9', '8', '9', '9',\n}","src":422,"more_decls":null}]