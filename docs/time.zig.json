[{"doc_comment":"A monotonic high-performance timer.\nTimer.start() must be called to initialize the struct, which captures\nthe counter frequency on windows and darwin, records the resolution,\nand gives the user an opportunity to check for the existnece of\nmonotonic clocks without forcing them to check for error on each read.\n.resolution is in nanoseconds on all platforms but .start_time's meaning\ndepends on the OS. On Windows and Darwin it is a hardware counter\nvalue that requires calculation to convert to a meaninful unit.","pl":"pub const Timer = struct ","src":142,"more_decls":{"doc_comment":"if we used resolution's value when performing the\nperformance counter calc on windows/darwin, it would\nbe less precise","pl":"frequency: switch (builtin.os.tag) {\n        .windows => u64,\n        .macos, .ios, .tvos, .watchos => os.darwin.mach_timebase_info_data,\n        else => void,\n    }","src":146,"more_decls":null}{"pl":"resolution: u64","src":151,"more_decls":null}{"pl":"start_time: u64","src":152,"more_decls":null}{"doc_comment":"Initialize the timer structure.\nCan only fail when running in a hostile environment that intentionally injects\nerror values into syscalls, such as using seccomp on Linux to intercept\n`clock_gettime`.","pl":"fn start() Error!Timer","src":165,"more_decls":null}{"doc_comment":"Reads the timer value since start or the last reset in nanoseconds","pl":"pub fn read(self: Timer) u64 {\n    var clock = clockNative() - self.start_time;\n    return self.nativeDurationToNanos(clock);\n}","src":212,"more_decls":null}{"doc_comment":"Resets the timer value to 0/now.","pl":"pub fn reset(self: *Timer) void {\n    self.start_time = clockNative();\n}","src":218,"more_decls":null}{"doc_comment":"Returns the current value of the timer in nanoseconds, then resets it","pl":"pub fn lap(self: *Timer) u64 {\n    var now = clockNative();\n    var lap_time = self.nativeDurationToNanos(now - self.start_time);\n    self.start_time = now;\n    return lap_time;\n}","src":223,"more_decls":null}{"pl":"const Error = error{TimerUnsupported}","src":154,"more_decls":null}}{"doc_comment":"Spurious wakeups are possible and no precision of timing is guaranteed.","pl":"fn sleep(nanoseconds: u64) void","src":16,"more_decls":null}{"doc_comment":"Get a calendar timestamp, in seconds, relative to UTC 1970-01-01.\nPrecision of timing depends on the hardware and operating system.\nThe return value is signed because it is possible to have a date that is\nbefore the epoch.\nSee `std.os.clock_gettime` for a POSIX timestamp.","pl":"pub fn timestamp() i64 {\n    return @divFloor(milliTimestamp(), ms_per_s);\n}","src":62,"more_decls":null}{"doc_comment":"Get a calendar timestamp, in milliseconds, relative to UTC 1970-01-01.\nPrecision of timing depends on the hardware and operating system.\nThe return value is signed because it is possible to have a date that is\nbefore the epoch.\nSee `std.os.clock_gettime` for a POSIX timestamp.","pl":"pub fn milliTimestamp() i64 {\n    return @intCast(i64, @divFloor(nanoTimestamp(), ns_per_ms));\n}","src":71,"more_decls":null}{"doc_comment":"Get a calendar timestamp, in nanoseconds, relative to UTC 1970-01-01.\nPrecision of timing depends on the hardware and operating system.\nOn Windows this has a maximum granularity of 100 nanoseconds.\nThe return value is signed because it is possible to have a date that is\nbefore the epoch.\nSee `std.os.clock_gettime` for a POSIX timestamp.","pl":"fn nanoTimestamp() i128","src":81,"more_decls":null}{"pl":"const epoch = @import(\"time/epoch.zig\")","src":13,"more_decls":null}{"pl":"const ns_per_us = 1000","src":105,"more_decls":null}{"pl":"const ns_per_ms = 1000 * ns_per_us","src":106,"more_decls":null}{"pl":"const ns_per_s = 1000 * ns_per_ms","src":107,"more_decls":null}{"pl":"const ns_per_min = 60 * ns_per_s","src":108,"more_decls":null}{"pl":"const ns_per_hour = 60 * ns_per_min","src":109,"more_decls":null}{"pl":"const ns_per_day = 24 * ns_per_hour","src":110,"more_decls":null}{"pl":"const ns_per_week = 7 * ns_per_day","src":111,"more_decls":null}{"pl":"const us_per_ms = 1000","src":114,"more_decls":null}{"pl":"const us_per_s = 1000 * us_per_ms","src":115,"more_decls":null}{"pl":"const us_per_min = 60 * us_per_s","src":116,"more_decls":null}{"pl":"const us_per_hour = 60 * us_per_min","src":117,"more_decls":null}{"pl":"const us_per_day = 24 * us_per_hour","src":118,"more_decls":null}{"pl":"const us_per_week = 7 * us_per_day","src":119,"more_decls":null}{"pl":"const ms_per_s = 1000","src":122,"more_decls":null}{"pl":"const ms_per_min = 60 * ms_per_s","src":123,"more_decls":null}{"pl":"const ms_per_hour = 60 * ms_per_min","src":124,"more_decls":null}{"pl":"const ms_per_day = 24 * ms_per_hour","src":125,"more_decls":null}{"pl":"const ms_per_week = 7 * ms_per_day","src":126,"more_decls":null}{"pl":"const s_per_min = 60","src":129,"more_decls":null}{"pl":"const s_per_hour = s_per_min * 60","src":130,"more_decls":null}{"pl":"const s_per_day = s_per_hour * 24","src":131,"more_decls":null}{"pl":"const s_per_week = s_per_day * 7","src":132,"more_decls":null}]