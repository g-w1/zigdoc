[{"doc_comment":"Describes how pointer types should be hashed.","pl":"pub const HashStrategy = enum ","src":12,"more_decls":{"doc_comment":"Do not follow pointers, only hash their value.","pl":"Shallow","src":14,"more_decls":null}{"doc_comment":"Follow pointers, hash the pointee content.\nOnly dereferences one level, ie. it is changed into .Shallow when a\npointer type is encountered.","pl":"Deep","src":19,"more_decls":null}{"doc_comment":"Follow pointers, hash the pointee content.\nDereferences all pointers encountered.\nAssumes no cycle.","pl":"DeepRecursive","src":24,"more_decls":null}}{"doc_comment":"Helper function to hash a pointer and mutate the strategy if needed.","pl":"fn hashPointer(hasher: anytype, key: anytype, comptime strat: HashStrategy) void","src":28,"more_decls":null}{"doc_comment":"Helper function to hash a set of contiguous objects, from an array or slice.","pl":"fn hashArray(hasher: anytype, key: anytype, comptime strat: HashStrategy) void","src":60,"more_decls":null}{"doc_comment":"Provides generic hashing for any eligible type.\nStrategy is provided to determine if pointers should be followed or not.","pl":"fn hash(hasher: anytype, key: anytype, comptime strat: HashStrategy) void","src":77,"more_decls":null}{"doc_comment":"Provides generic hashing for any eligible type.\nOnly hashes `key` itself, pointers are not followed.\nSlices as well as unions and structs containing slices are rejected to avoid\nambiguity on the user's intention.","pl":"fn autoHash(hasher: anytype, key: anytype) void","src":198,"more_decls":null}]