[{"pl":"pub const TranslateCStep = struct ","src":16,"more_decls":{"pl":"step: Step","src":17,"more_decls":null}{"pl":"builder: *Builder","src":18,"more_decls":null}{"pl":"source: build.FileSource","src":19,"more_decls":null}{"pl":"include_dirs: std.ArrayList([]const u8)","src":20,"more_decls":null}{"pl":"output_dir: ?[]const u8","src":21,"more_decls":null}{"pl":"out_basename: []const u8","src":22,"more_decls":null}{"pl":"target: CrossTarget = CrossTarget{}","src":23,"more_decls":null}{"pl":"fn create(builder: *Builder, source: build.FileSource) *TranslateCStep","src":25,"more_decls":null}{"doc_comment":"Unless setOutputDir was called, this function must be called only in\nthe make step, from a step that has declared a dependency on this one.\nTo run an executable built with zig build, use `run`, or create an install step and invoke it.","pl":"pub fn getOutputPath(self: *TranslateCStep) []const u8 {\n    return fs.path.join(\n        self.builder.allocator,\n        &[_][]const u8{ self.output_dir.?, self.out_basename },\n    ) catch unreachable;\n}","src":42,"more_decls":null}{"pl":"pub fn setTarget(self: *TranslateCStep, target: CrossTarget) void {\n    self.target = target;\n}","src":49,"more_decls":null}{"doc_comment":"Creates a step to build an executable from the translated source.","pl":"pub fn addExecutable(self: *TranslateCStep) *LibExeObjStep {\n    return self.builder.addExecutableSource(\"translated_c\", @as(build.FileSource, .{ .translate_c = self }));\n}","src":54,"more_decls":null}{"pl":"pub fn addIncludeDir(self: *TranslateCStep, include_dir: []const u8) void {\n    self.include_dirs.append(self.builder.dupePath(include_dir)) catch unreachable;\n}","src":58,"more_decls":null}{"pl":"pub fn addCheckFile(self: *TranslateCStep, expected_matches: []const []const u8) *CheckFileStep {\n    return CheckFileStep.create(self.builder, .{ .translate_c = self }, self.builder.dupeStrings(expected_matches));\n}","src":62,"more_decls":null}}]