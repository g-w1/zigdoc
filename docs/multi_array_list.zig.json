[{"pl":"fn MultiArrayList(comptime S: type) type","sub_container_type":"struct ","src":12,"more_decls":{"pl":"bytes: [*]align(@alignOf(S)) u8 = undefined","src":14,"more_decls":null}{"pl":"len: usize = 0","src":15,"more_decls":null}{"pl":"capacity: usize = 0","src":16,"more_decls":null}{"pl":"pub const Slice = struct ","src":22,"more_decls":{"doc_comment":"This array is indexed by the field index which can be obtained\nby using @enumToInt() on the Field enum","pl":"ptrs: [fields.len][*]u8","src":25,"more_decls":null}{"pl":"len: usize","src":26,"more_decls":null}{"pl":"capacity: usize","src":27,"more_decls":null}{"pl":"fn items(self: Slice, comptime field: Field) []FieldType(field)","src":29,"more_decls":null}{"pl":"fn toMultiArrayList(self: Slice) Self","src":39,"more_decls":null}{"pl":"pub fn deinit(self: *Slice, gpa: *Allocator) void {\n    var other = self.toMultiArrayList();\n    other.deinit(gpa);\n    self.* = undefined;\n}","src":53,"more_decls":null}}{"doc_comment":"Release all allocated memory.","pl":"pub fn deinit(self: *Self, gpa: *Allocator) void {\n    gpa.free(self.allocatedBytes());\n    self.* = undefined;\n}","src":99,"more_decls":null}{"doc_comment":"The caller owns the returned memory. Empties this MultiArrayList.","pl":"pub fn toOwnedSlice(self: *Self) Slice {\n    const result = self.slice();\n    self.* = .{};\n    return result;\n}","src":105,"more_decls":null}{"pl":"fn slice(self: Self) Slice","src":111,"more_decls":null}{"pl":"pub fn items(self: Self, comptime field: Field) []FieldType(field) {\n    return self.slice().items(field);\n}","src":125,"more_decls":null}{"doc_comment":"Overwrite one array element with new data.","pl":"pub fn set(self: *Self, index: usize, elem: S) void {\n    const slices = self.slice();\n    inline for (fields) |field_info, i| {\n        slices.items(@intToEnum(Field, i))[index] = @field(elem, field_info.name);\n    }\n}","src":130,"more_decls":null}{"doc_comment":"Obtain all the data for one array element.","pl":"fn get(self: *Self, index: usize) S","src":138,"more_decls":null}{"doc_comment":"Extend the list by 1 element. Allocates more memory as necessary.","pl":"pub fn append(self: *Self, gpa: *Allocator, elem: S) !void {\n    try self.ensureCapacity(gpa, self.len + 1);\n    self.appendAssumeCapacity(elem);\n}","src":148,"more_decls":null}{"doc_comment":"Extend the list by 1 element, but asserting `self.capacity`\nis sufficient to hold an additional item.","pl":"pub fn appendAssumeCapacity(self: *Self, elem: S) void {\n    assert(self.len < self.capacity);\n    self.len += 1;\n    self.set(self.len - 1, elem);\n}","src":155,"more_decls":null}{"doc_comment":"Adjust the list's length to `new_len`.\nDoes not initialize added items, if any.","pl":"pub fn resize(self: *Self, gpa: *Allocator, new_len: usize) !void {\n    try self.ensureCapacity(gpa, new_len);\n    self.len = new_len;\n}","src":163,"more_decls":null}{"doc_comment":"Attempt to reduce allocated capacity to `new_len`.\nIf `new_len` is greater than zero, this may fail to reduce the capacity,\nbut the data remains intact and the length is updated to new_len.","pl":"fn shrinkAndFree(self: *Self, gpa: *Allocator, new_len: usize) void","src":171,"more_decls":null}{"doc_comment":"Reduce length to `new_len`.\nInvalidates pointers to elements `items[new_len..]`.\nKeeps capacity the same.","pl":"pub fn shrinkRetainingCapacity(self: *Self, new_len: usize) void {\n    self.len = new_len;\n}","src":222,"more_decls":null}{"doc_comment":"Modify the array so that it can hold at least `new_capacity` items.\nImplements super-linear growth to achieve amortized O(1) append operations.\nInvalidates pointers if additional memory is needed.","pl":"fn ensureCapacity(self: *Self, gpa: *Allocator, new_capacity: usize) !void","src":229,"more_decls":null}{"doc_comment":"Modify the array so that it can hold exactly `new_capacity` items.\nInvalidates pointers if additional memory is needed.\n`new_capacity` must be greater or equal to `len`.","pl":"fn setCapacity(self: *Self, gpa: *Allocator, new_capacity: usize) !void","src":244,"more_decls":null}{"pl":"const Elem = S","src":18,"more_decls":null}{"pl":"const Field = meta.FieldEnum(S)","src":20,"more_decls":null}}]