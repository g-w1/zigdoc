[{"pl":"pub const ClientRequest = extern enum ","src":50,"more_decls":{"pl":"RunningOnValgrind = 4097","src":51,"more_decls":null}{"pl":"DiscardTranslations = 4098","src":52,"more_decls":null}{"pl":"ClientCall0 = 4353","src":53,"more_decls":null}{"pl":"ClientCall1 = 4354","src":54,"more_decls":null}{"pl":"ClientCall2 = 4355","src":55,"more_decls":null}{"pl":"ClientCall3 = 4356","src":56,"more_decls":null}{"pl":"CountErrors = 4609","src":57,"more_decls":null}{"pl":"GdbMonitorCommand = 4610","src":58,"more_decls":null}{"pl":"MalloclikeBlock = 4865","src":59,"more_decls":null}{"pl":"ResizeinplaceBlock = 4875","src":60,"more_decls":null}{"pl":"FreelikeBlock = 4866","src":61,"more_decls":null}{"pl":"CreateMempool = 4867","src":62,"more_decls":null}{"pl":"DestroyMempool = 4868","src":63,"more_decls":null}{"pl":"MempoolAlloc = 4869","src":64,"more_decls":null}{"pl":"MempoolFree = 4870","src":65,"more_decls":null}{"pl":"MempoolTrim = 4871","src":66,"more_decls":null}{"pl":"MoveMempool = 4872","src":67,"more_decls":null}{"pl":"MempoolChange = 4873","src":68,"more_decls":null}{"pl":"MempoolExists = 4874","src":69,"more_decls":null}{"pl":"Printf = 5121","src":70,"more_decls":null}{"pl":"PrintfBacktrace = 5122","src":71,"more_decls":null}{"pl":"PrintfValistByRef = 5123","src":72,"more_decls":null}{"pl":"PrintfBacktraceValistByRef = 5124","src":73,"more_decls":null}{"pl":"StackRegister = 5377","src":74,"more_decls":null}{"pl":"StackDeregister = 5378","src":75,"more_decls":null}{"pl":"StackChange = 5379","src":76,"more_decls":null}{"pl":"LoadPdbDebuginfo = 5633","src":77,"more_decls":null}{"pl":"MapIpToSrcloc = 5889","src":78,"more_decls":null}{"pl":"ChangeErrDisablement = 6145","src":79,"more_decls":null}{"pl":"VexInitForIri = 6401","src":80,"more_decls":null}{"pl":"InnerThreads = 6402","src":81,"more_decls":null}}{"doc_comment":"Create a memory pool.","pl":"pub const MempoolFlags = extern enum ","src":158,"more_decls":{"pl":"AutoFree = 1","src":159,"more_decls":null}{"pl":"MetaPool = 2","src":160,"more_decls":null}}{"pl":"fn doClientRequest(default: usize, request: usize, a1: usize, a2: usize, a3: usize, a4: usize, a5: usize) usize","src":9,"more_decls":null}{"pl":"pub fn ToolBase(base: [2]u8) u32 {\n    return (@as(u32, base[0] & 0xff) << 24) | (@as(u32, base[1] & 0xff) << 16);\n}","src":83,"more_decls":null}{"pl":"pub fn IsTool(base: [2]u8, code: usize) bool {\n    return ToolBase(base) == (code & 0xffff0000);\n}","src":86,"more_decls":null}{"doc_comment":"Returns the number of Valgrinds this code is running under.  That\nis, 0 if running natively, 1 if running under Valgrind, 2 if\nrunning under Valgrind which is running under another Valgrind,\netc.","pl":"pub fn runningOnValgrind() usize {\n    return doClientRequestExpr(0, .RunningOnValgrind, 0, 0, 0, 0, 0);\n}","src":102,"more_decls":null}{"doc_comment":"Discard translation of code in the slice qzz.  Useful if you are debugging\na JITter or some such, since it provides a way to make sure valgrind will\nretranslate the invalidated area.  Returns no value.","pl":"pub fn discardTranslations(qzz: []const u8) void {\n    doClientRequestStmt(.DiscardTranslations, @ptrToInt(qzz.ptr), qzz.len, 0, 0, 0);\n}","src":113,"more_decls":null}{"pl":"pub fn innerThreads(qzz: [*]u8) void {\n    doClientRequestStmt(.InnerThreads, qzz, 0, 0, 0, 0);\n}","src":117,"more_decls":null}{"pl":"pub fn nonSIMDCall0(func: fn (usize) usize) usize {\n    return doClientRequestExpr(0, .ClientCall0, @ptrToInt(func), 0, 0, 0, 0);\n}","src":121,"more_decls":null}{"pl":"pub fn nonSIMDCall1(func: fn (usize, usize) usize, a1: usize) usize {\n    return doClientRequestExpr(0, .ClientCall1, @ptrToInt(func), a1, 0, 0, 0);\n}","src":125,"more_decls":null}{"pl":"pub fn nonSIMDCall2(func: fn (usize, usize, usize) usize, a1: usize, a2: usize) usize {\n    return doClientRequestExpr(0, .ClientCall2, @ptrToInt(func), a1, a2, 0, 0);\n}","src":129,"more_decls":null}{"pl":"pub fn nonSIMDCall3(func: fn (usize, usize, usize, usize) usize, a1: usize, a2: usize, a3: usize) usize {\n    return doClientRequestExpr(0, .ClientCall3, @ptrToInt(func), a1, a2, a3, 0);\n}","src":133,"more_decls":null}{"doc_comment":"Counts the number of errors that have been recorded by a tool.  Nb:\nthe tool must record the errors with VG_(maybe_record_error)() or\nVG_(unique_error)() for them to be counted.","pl":"pub fn countErrors() usize {\n    return doClientRequestExpr(0, // default return\n        .CountErrors, 0, 0, 0, 0, 0);\n}","src":140,"more_decls":null}{"pl":"pub fn mallocLikeBlock(mem: []u8, rzB: usize, is_zeroed: bool) void {\n    doClientRequestStmt(.MalloclikeBlock, @ptrToInt(mem.ptr), mem.len, rzB, @boolToInt(is_zeroed), 0);\n}","src":145,"more_decls":null}{"pl":"pub fn resizeInPlaceBlock(oldmem: []u8, newsize: usize, rzB: usize) void {\n    doClientRequestStmt(.ResizeinplaceBlock, @ptrToInt(oldmem.ptr), oldmem.len, newsize, rzB, 0);\n}","src":149,"more_decls":null}{"pl":"pub fn freeLikeBlock(addr: [*]u8, rzB: usize) void {\n    doClientRequestStmt(.FreelikeBlock, @ptrToInt(addr), rzB, 0, 0, 0);\n}","src":153,"more_decls":null}{"pl":"pub fn createMempool(pool: [*]u8, rzB: usize, is_zeroed: bool, flags: usize) void {\n    doClientRequestStmt(.CreateMempool, @ptrToInt(pool), rzB, @boolToInt(is_zeroed), flags, 0);\n}","src":162,"more_decls":null}{"doc_comment":"Destroy a memory pool.","pl":"pub fn destroyMempool(pool: [*]u8) void {\n    doClientRequestStmt(.DestroyMempool, pool, 0, 0, 0, 0);\n}","src":167,"more_decls":null}{"doc_comment":"Associate a piece of memory with a memory pool.","pl":"pub fn mempoolAlloc(pool: [*]u8, mem: []u8) void {\n    doClientRequestStmt(.MempoolAlloc, @ptrToInt(pool), @ptrToInt(mem.ptr), mem.len, 0, 0);\n}","src":172,"more_decls":null}{"doc_comment":"Disassociate a piece of memory from a memory pool.","pl":"pub fn mempoolFree(pool: [*]u8, addr: [*]u8) void {\n    doClientRequestStmt(.MempoolFree, @ptrToInt(pool), @ptrToInt(addr), 0, 0, 0);\n}","src":177,"more_decls":null}{"doc_comment":"Disassociate any pieces outside a particular range.","pl":"pub fn mempoolTrim(pool: [*]u8, mem: []u8) void {\n    doClientRequestStmt(.MempoolTrim, @ptrToInt(pool), @ptrToInt(mem.ptr), mem.len, 0, 0);\n}","src":182,"more_decls":null}{"doc_comment":"Resize and/or move a piece associated with a memory pool.","pl":"pub fn moveMempool(poolA: [*]u8, poolB: [*]u8) void {\n    doClientRequestStmt(.MoveMempool, @ptrToInt(poolA), @ptrToInt(poolB), 0, 0, 0);\n}","src":187,"more_decls":null}{"doc_comment":"Resize and/or move a piece associated with a memory pool.","pl":"pub fn mempoolChange(pool: [*]u8, addrA: [*]u8, mem: []u8) void {\n    doClientRequestStmt(.MempoolChange, @ptrToInt(pool), @ptrToInt(addrA), @ptrToInt(mem.ptr), mem.len, 0);\n}","src":192,"more_decls":null}{"doc_comment":"Return if a mempool exists.","pl":"pub fn mempoolExists(pool: [*]u8) bool {\n    return doClientRequestExpr(0, .MempoolExists, @ptrToInt(pool), 0, 0, 0, 0) != 0;\n}","src":197,"more_decls":null}{"doc_comment":"Mark a piece of memory as being a stack. Returns a stack id.\nstart is the lowest addressable stack byte, end is the highest\naddressable stack byte.","pl":"pub fn stackRegister(stack: []u8) usize {\n    return doClientRequestExpr(0, .StackRegister, @ptrToInt(stack.ptr), @ptrToInt(stack.ptr) + stack.len, 0, 0, 0);\n}","src":204,"more_decls":null}{"doc_comment":"Unmark the piece of memory associated with a stack id as being a stack.","pl":"pub fn stackDeregister(id: usize) void {\n    doClientRequestStmt(.StackDeregister, id, 0, 0, 0, 0);\n}","src":209,"more_decls":null}{"doc_comment":"Change the start and end address of the stack id.\nstart is the new lowest addressable stack byte, end is the new highest\naddressable stack byte.","pl":"pub fn stackChange(id: usize, newstack: []u8) void {\n    doClientRequestStmt(.StackChange, id, @ptrToInt(newstack.ptr), @ptrToInt(newstack.ptr) + newstack.len, 0, 0);\n}","src":216,"more_decls":null}{"doc_comment":"Map a code address to a source file name and line number.  buf64\nmust point to a 64-byte buffer in the caller's address space. The\nresult will be dumped in there and is guaranteed to be zero\nterminated.  If no info is found, the first byte is set to zero.","pl":"pub fn mapIpToSrcloc(addr: *const u8, buf64: [64]u8) usize {\n    return doClientRequestExpr(0, .MapIpToSrcloc, @ptrToInt(addr), @ptrToInt(&buf64[0]), 0, 0, 0);\n}","src":231,"more_decls":null}{"doc_comment":"Disable error reporting for this thread.  Behaves in a stack like\nway, so you can safely call this multiple times provided that\nenableErrorReporting() is called the same number of times\nto re-enable reporting.  The first call of this macro disables\nreporting.  Subsequent calls have no effect except to increase the\nnumber of enableErrorReporting() calls needed to re-enable\nreporting.  Child threads do not inherit this setting from their\nparents -- they are always created with reporting enabled.","pl":"pub fn disableErrorReporting() void {\n    doClientRequestStmt(.ChangeErrDisablement, 1, 0, 0, 0, 0);\n}","src":243,"more_decls":null}{"doc_comment":"Re-enable error reporting, (see disableErrorReporting())","pl":"pub fn enableErrorReporting() void {\n    doClientRequestStmt(.ChangeErrDisablement, math.maxInt(usize), 0, 0, 0, 0);\n}","src":248,"more_decls":null}{"doc_comment":"Execute a monitor command from the client program.\nIf a connection is opened with GDB, the output will be sent\naccording to the output mode set for vgdb.\nIf no connection is opened, output will go to the log output.\nReturns 1 if command not recognised, 0 otherwise.","pl":"pub fn monitorCommand(command: [*]u8) bool {\n    return doClientRequestExpr(0, .GdbMonitorCommand, @ptrToInt(command.ptr), 0, 0, 0, 0) != 0;\n}","src":257,"more_decls":null}{"pl":"const memcheck = @import(\"valgrind/memcheck.zig\")","src":261,"more_decls":null}{"pl":"const callgrind = @import(\"valgrind/callgrind.zig\")","src":262,"more_decls":null}]