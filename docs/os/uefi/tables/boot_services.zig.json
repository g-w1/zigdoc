[{"doc_comment":"Boot services are services provided by the system's firmware until the operating system takes\nover control over the hardware by calling exitBootServices.\n\nBoot Services must not be used after exitBootServices has been called. The only exception is\ngetMemoryMap, which may be used after the first unsuccessful call to exitBootServices.\nAfter successfully calling exitBootServices, system_table.console_in_handle, system_table.con_in,\nsystem_table.console_out_handle, system_table.con_out, system_table.standard_error_handle,\nsystem_table.std_err, and system_table.boot_services should be set to null. After setting these\nattributes to null, system_table.hdr.crc32 must be recomputed.\n\nAs the boot_services table may grow with new UEFI versions, it is important to check hdr.header_size.","pl":"pub const BootServices = extern struct ","src":24,"more_decls":{"pl":"hdr: TableHeader","src":25,"more_decls":null}{"doc_comment":"Raises a task's priority level and returns its previous level.","pl":"raiseTpl: fn (usize) callconv(.C) usize","src":28,"more_decls":null}{"doc_comment":"Restores a task's priority level to its previous value.","pl":"restoreTpl: fn (usize) callconv(.C) void","src":31,"more_decls":null}{"doc_comment":"Allocates memory pages from the system.","pl":"allocatePages: fn (AllocateType, MemoryType, usize, *[*]align(4096) u8) callconv(.C) Status","src":34,"more_decls":null}{"doc_comment":"Frees memory pages.","pl":"freePages: fn ([*]align(4096) u8, usize) callconv(.C) Status","src":37,"more_decls":null}{"doc_comment":"Returns the current memory map.","pl":"getMemoryMap: fn (*usize, [*]MemoryDescriptor, *usize, *usize, *u32) callconv(.C) Status","src":40,"more_decls":null}{"doc_comment":"Allocates pool memory.","pl":"allocatePool: fn (MemoryType, usize, *[*]align(8) u8) callconv(.C) Status","src":43,"more_decls":null}{"doc_comment":"Returns pool memory to the system.","pl":"freePool: fn ([*]align(8) u8) callconv(.C) Status","src":46,"more_decls":null}{"doc_comment":"Creates an event.","pl":"createEvent: fn (u32, usize, ?fn (Event, ?*c_void) callconv(.C) void, ?*const c_void, *Event) callconv(.C) Status","src":49,"more_decls":null}{"doc_comment":"Sets the type of timer and the trigger time for a timer event.","pl":"setTimer: fn (Event, TimerDelay, u64) callconv(.C) Status","src":52,"more_decls":null}{"doc_comment":"Stops execution until an event is signaled.","pl":"waitForEvent: fn (usize, [*]const Event, *usize) callconv(.C) Status","src":55,"more_decls":null}{"doc_comment":"Signals an event.","pl":"signalEvent: fn (Event) callconv(.C) Status","src":58,"more_decls":null}{"doc_comment":"Closes an event.","pl":"closeEvent: fn (Event) callconv(.C) Status","src":61,"more_decls":null}{"doc_comment":"Checks whether an event is in the signaled state.","pl":"checkEvent: fn (Event) callconv(.C) Status","src":64,"more_decls":null}{"pl":"installProtocolInterface: Status","src":66,"more_decls":null}{"pl":"reinstallProtocolInterface: Status","src":67,"more_decls":null}{"pl":"uninstallProtocolInterface: Status","src":68,"more_decls":null}{"doc_comment":"Queries a handle to determine if it supports a specified protocol.","pl":"handleProtocol: fn (Handle, *align(8) const Guid, *?*c_void) callconv(.C) Status","src":71,"more_decls":null}{"pl":"reserved: *c_void","src":73,"more_decls":null}{"pl":"registerProtocolNotify: Status","src":75,"more_decls":null}{"doc_comment":"Returns an array of handles that support a specified protocol.","pl":"locateHandle: fn (LocateSearchType, ?*align(8) const Guid, ?*const c_void, *usize, [*]Handle) callconv(.C) Status","src":78,"more_decls":null}{"doc_comment":"Locates the handle to a device on the device path that supports the specified protocol","pl":"locateDevicePath: fn (*align(8) const Guid, **const DevicePathProtocol, *?Handle) callconv(.C) Status","src":81,"more_decls":null}{"pl":"installConfigurationTable: Status","src":82,"more_decls":null}{"doc_comment":"Loads an EFI image into memory.","pl":"loadImage: fn (bool, Handle, ?*const DevicePathProtocol, ?[*]const u8, usize, *?Handle) callconv(.C) Status","src":85,"more_decls":null}{"doc_comment":"Transfers control to a loaded image's entry point.","pl":"startImage: fn (Handle, ?*usize, ?*[*]u16) callconv(.C) Status","src":88,"more_decls":null}{"doc_comment":"Terminates a loaded EFI image and returns control to boot services.","pl":"exit: fn (Handle, Status, usize, ?*const c_void) callconv(.C) Status","src":91,"more_decls":null}{"doc_comment":"Unloads an image.","pl":"unloadImage: fn (Handle) callconv(.C) Status","src":94,"more_decls":null}{"doc_comment":"Terminates all boot services.","pl":"exitBootServices: fn (Handle, usize) callconv(.C) Status","src":97,"more_decls":null}{"doc_comment":"Returns a monotonically increasing count for the platform.","pl":"getNextMonotonicCount: fn (*u64) callconv(.C) Status","src":100,"more_decls":null}{"doc_comment":"Induces a fine-grained stall.","pl":"stall: fn (usize) callconv(.C) Status","src":103,"more_decls":null}{"doc_comment":"Sets the system's watchdog timer.","pl":"setWatchdogTimer: fn (usize, u64, usize, ?[*]const u16) callconv(.C) Status","src":106,"more_decls":null}{"pl":"connectController: Status","src":108,"more_decls":null}{"pl":"disconnectController: Status","src":109,"more_decls":null}{"doc_comment":"Queries a handle to determine if it supports a specified protocol.","pl":"openProtocol: fn (Handle, *align(8) const Guid, *?*c_void, ?Handle, ?Handle, OpenProtocolAttributes) callconv(.C) Status","src":112,"more_decls":null}{"doc_comment":"Closes a protocol on a handle that was opened using openProtocol().","pl":"closeProtocol: fn (Handle, *align(8) const Guid, Handle, ?Handle) callconv(.C) Status","src":115,"more_decls":null}{"doc_comment":"Retrieves the list of agents that currently have a protocol interface opened.","pl":"openProtocolInformation: fn (Handle, *align(8) const Guid, *[*]ProtocolInformationEntry, *usize) callconv(.C) Status","src":118,"more_decls":null}{"doc_comment":"Retrieves the list of protocol interface GUIDs that are installed on a handle in a buffer allocated from pool.","pl":"protocolsPerHandle: fn (Handle, *[*]*align(8) const Guid, *usize) callconv(.C) Status","src":121,"more_decls":null}{"doc_comment":"Returns an array of handles that support the requested protocol in a buffer allocated from pool.","pl":"locateHandleBuffer: fn (LocateSearchType, ?*align(8) const Guid, ?*const c_void, *usize, *[*]Handle) callconv(.C) Status","src":124,"more_decls":null}{"doc_comment":"Returns the first protocol instance that matches the given protocol.","pl":"locateProtocol: fn (*align(8) const Guid, ?*const c_void, *?*c_void) callconv(.C) Status","src":127,"more_decls":null}{"pl":"installMultipleProtocolInterfaces: Status","src":129,"more_decls":null}{"pl":"uninstallMultipleProtocolInterfaces: Status","src":130,"more_decls":null}{"doc_comment":"Computes and returns a 32-bit CRC for a data buffer.","pl":"calculateCrc32: fn ([*]const u8, usize, *u32) callconv(.C) Status","src":133,"more_decls":null}{"doc_comment":"Copies the contents of one buffer to another buffer","pl":"copyMem: fn ([*]u8, [*]const u8, usize) callconv(.C) void","src":136,"more_decls":null}{"doc_comment":"Fills a buffer with a specified value","pl":"setMem: fn ([*]u8, usize, u8) callconv(.C) void","src":139,"more_decls":null}{"pl":"createEventEx: Status","src":141,"more_decls":null}{"pl":"const signature: u64 = 0x56524553544f4f42","src":143,"more_decls":null}{"pl":"const event_timer: u32 = 0x80000000","src":145,"more_decls":null}{"pl":"const event_runtime: u32 = 0x40000000","src":146,"more_decls":null}{"pl":"const event_notify_wait: u32 = 0x00000100","src":147,"more_decls":null}{"pl":"const event_notify_signal: u32 = 0x00000200","src":148,"more_decls":null}{"pl":"const event_signal_exit_boot_services: u32 = 0x00000201","src":149,"more_decls":null}{"pl":"const event_signal_virtual_address_change: u32 = 0x00000202","src":150,"more_decls":null}{"pl":"const tpl_application: usize = 4","src":152,"more_decls":null}{"pl":"const tpl_callback: usize = 8","src":153,"more_decls":null}{"pl":"const tpl_notify: usize = 16","src":154,"more_decls":null}{"pl":"const tpl_high_level: usize = 31","src":155,"more_decls":null}}{"pl":"pub const TimerDelay = extern enum","src":158,"more_decls":{"pl":"TimerCancel","src":159,"more_decls":null}{"pl":"TimerPeriodic","src":160,"more_decls":null}{"pl":"TimerRelative","src":161,"more_decls":null}}{"pl":"pub const MemoryType = extern enum","src":164,"more_decls":{"pl":"ReservedMemoryType","src":165,"more_decls":null}{"pl":"LoaderCode","src":166,"more_decls":null}{"pl":"LoaderData","src":167,"more_decls":null}{"pl":"BootServicesCode","src":168,"more_decls":null}{"pl":"BootServicesData","src":169,"more_decls":null}{"pl":"RuntimeServicesCode","src":170,"more_decls":null}{"pl":"RuntimeServicesData","src":171,"more_decls":null}{"pl":"ConventionalMemory","src":172,"more_decls":null}{"pl":"UnusableMemory","src":173,"more_decls":null}{"pl":"ACPIReclaimMemory","src":174,"more_decls":null}{"pl":"ACPIMemoryNVS","src":175,"more_decls":null}{"pl":"MemoryMappedIO","src":176,"more_decls":null}{"pl":"MemoryMappedIOPortSpace","src":177,"more_decls":null}{"pl":"PalCode","src":178,"more_decls":null}{"pl":"PersistentMemory","src":179,"more_decls":null}{"pl":"MaxMemoryType","src":180,"more_decls":null}}{"pl":"pub const MemoryDescriptor = extern struct ","src":183,"more_decls":{"pl":"type: MemoryType","src":184,"more_decls":null}{"pl":"physical_start: u64","src":185,"more_decls":null}{"pl":"virtual_start: u64","src":186,"more_decls":null}{"pl":"number_of_pages: usize","src":187,"more_decls":null}{"pl":"attribute: packed struct {\n        uc: bool,\n        wc: bool,\n        wt: bool,\n        wb: bool,\n        uce: bool,\n        _pad1: u7,\n        wp: bool,\n        rp: bool,\n        xp: bool,\n        nv: bool,\n        more_reliable: bool,\n        ro: bool,\n        sp: bool,\n        cpu_crypto: bool,\n        _pad2: u43,\n        memory_runtime: bool,\n    }","src":188,"more_decls":null}}{"pl":"pub const LocateSearchType = extern enum","src":208,"more_decls":{"pl":"AllHandles","src":209,"more_decls":null}{"pl":"ByRegisterNotify","src":210,"more_decls":null}{"pl":"ByProtocol","src":211,"more_decls":null}}{"pl":"pub const OpenProtocolAttributes = packed struct ","src":214,"more_decls":{"pl":"by_handle_protocol: bool = false","src":215,"more_decls":null}{"pl":"get_protocol: bool = false","src":216,"more_decls":null}{"pl":"test_protocol: bool = false","src":217,"more_decls":null}{"pl":"by_child_controller: bool = false","src":218,"more_decls":null}{"pl":"by_driver: bool = false","src":219,"more_decls":null}{"pl":"exclusive: bool = false","src":220,"more_decls":null}{"pl":"_pad: u26 = undefined","src":221,"more_decls":null}}{"pl":"pub const ProtocolInformationEntry = extern struct ","src":224,"more_decls":{"pl":"agent_handle: ?Handle","src":225,"more_decls":null}{"pl":"controller_handle: ?Handle","src":226,"more_decls":null}{"pl":"attributes: OpenProtocolAttributes","src":227,"more_decls":null}{"pl":"open_count: u32","src":228,"more_decls":null}}{"pl":"pub const AllocateType = extern enum","src":231,"more_decls":{"pl":"AllocateAnyPages","src":232,"more_decls":null}{"pl":"AllocateMaxAddress","src":233,"more_decls":null}{"pl":"AllocateAddress","src":234,"more_decls":null}}]