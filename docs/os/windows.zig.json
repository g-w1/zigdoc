[{"pl":"pub const OpenFileOptions = struct ","src":45,"more_decls":{"pl":"access_mask: ACCESS_MASK","src":46,"more_decls":null}{"pl":"dir: ?HANDLE = null","src":47,"more_decls":null}{"pl":"sa: ?*SECURITY_ATTRIBUTES = null","src":48,"more_decls":null}{"pl":"share_access: ULONG = FILE_SHARE_WRITE | FILE_SHARE_READ | FILE_SHARE_DELETE","src":49,"more_decls":null}{"pl":"share_access_nonblocking: bool = false","src":50,"more_decls":null}{"pl":"creation: ULONG","src":51,"more_decls":null}{"pl":"io_mode: std.io.ModeOverride","src":52,"more_decls":null}{"doc_comment":"If true, tries to open path as a directory.\nDefaults to false.","pl":"open_dir: bool = false","src":55,"more_decls":null}{"doc_comment":"If false, tries to open path as a reparse point without dereferencing it.\nDefaults to true.","pl":"follow_symlinks: bool = true","src":58,"more_decls":null}}{"pl":"pub const GetQueuedCompletionStatusResult = enum ","src":355,"more_decls":{"pl":"Normal","src":356,"more_decls":null}{"pl":"Aborted","src":357,"more_decls":null}{"pl":"Cancelled","src":358,"more_decls":null}{"pl":"EOF","src":359,"more_decls":null}}{"pl":"pub const DeleteFileOptions = struct ","src":805,"more_decls":{"pl":"dir: ?HANDLE","src":806,"more_decls":null}{"pl":"remove_dir: bool = false","src":807,"more_decls":null}}{"doc_comment":"Specifies how to format volume path in the result of `GetFinalPathNameByHandle`.\nDefaults to DOS volume names.","pl":"pub const GetFinalPathNameByHandleFormat = struct ","src":1014,"more_decls":{"pl":"volume_name: enum {\n        /// Format as DOS volume name\n        Dos,\n        /// Format as NT volume name\n        Nt,\n    } = .Dos","src":1015,"more_decls":null}}{"pl":"pub const PathSpace = struct ","src":1606,"more_decls":{"pl":"data: [PATH_MAX_WIDE:0]u16","src":1607,"more_decls":null}{"pl":"len: usize","src":1608,"more_decls":null}{"pl":"pub fn span(self: PathSpace) [:0]const u16 {\n    return self.data[0..self.len :0];\n}","src":1610,"more_decls":null}}{"doc_comment":"TODO when share_access_nonblocking is false, this implementation uses\nuntinterruptible sleep() to block. This is not the final iteration of the API.","pl":"fn OpenFile(sub_path_w: []const u16, options: OpenFileOptions) OpenError!HANDLE","src":63,"more_decls":null}{"pl":"fn CreatePipe(rd: *HANDLE, wr: *HANDLE, sattr: *const SECURITY_ATTRIBUTES) CreatePipeError!void","src":147,"more_decls":null}{"pl":"pub fn CreateEventEx(attributes: ?*SECURITY_ATTRIBUTES, name: []const u8, flags: DWORD, desired_access: DWORD) !HANDLE {\n    const nameW = try sliceToPrefixedFileW(name);\n    return CreateEventExW(attributes, nameW.span().ptr, flags, desired_access);\n}","src":155,"more_decls":null}{"pl":"fn CreateEventExW(attributes: ?*SECURITY_ATTRIBUTES, nameW: [*:0]const u16, flags: DWORD, desired_access: DWORD) !HANDLE","src":160,"more_decls":null}{"doc_comment":"A Zig wrapper around `NtDeviceIoControlFile` and `NtFsControlFile` syscalls.\nIt implements similar behavior to `DeviceIoControl` and is meant to serve\nas a direct substitute for that call.\nTODO work out if we need to expose other arguments to the underlying syscalls.","pl":"fn DeviceIoControl(\n    h: HANDLE,\n    ioControlCode: ULONG,\n    in: ?[]const u8,\n    out: ?[]u8,\n) DeviceIoControlError!void","src":177,"more_decls":null}{"pl":"fn GetOverlappedResult(h: HANDLE, overlapped: *OVERLAPPED, wait: bool) !DWORD","src":230,"more_decls":null}{"pl":"fn SetHandleInformation(h: HANDLE, mask: DWORD, flags: DWORD) SetHandleInformationError!void","src":243,"more_decls":null}{"doc_comment":"Call RtlGenRandom() instead of CryptGetRandom() on Windows\nhttps://github.com/rust-lang-nursery/rand/issues/111\nhttps://bugzilla.mozilla.org/show_bug.cgi?id=504270","pl":"fn RtlGenRandom(output: []u8) RtlGenRandomError!void","src":256,"more_decls":null}{"pl":"pub fn WaitForSingleObject(handle: HANDLE, milliseconds: DWORD) WaitForSingleObjectError!void {\n    return WaitForSingleObjectEx(handle, milliseconds, false);\n}","src":279,"more_decls":null}{"pl":"fn WaitForSingleObjectEx(handle: HANDLE, milliseconds: DWORD, alertable: bool) WaitForSingleObjectError!void","src":283,"more_decls":null}{"pl":"fn WaitForMultipleObjectsEx(handles: []const HANDLE, waitAll: bool, milliseconds: DWORD, alertable: bool) !u32","src":295,"more_decls":null}{"pl":"fn CreateIoCompletionPort(\n    file_handle: HANDLE,\n    existing_completion_port: ?HANDLE,\n    completion_key: usize,\n    concurrent_thread_count: DWORD,\n) CreateIoCompletionPortError!HANDLE","src":325,"more_decls":null}{"pl":"fn PostQueuedCompletionStatus(\n    completion_port: HANDLE,\n    bytes_transferred_count: DWORD,\n    completion_key: usize,\n    lpOverlapped: ?*OVERLAPPED,\n) PostQueuedCompletionStatusError!void","src":342,"more_decls":null}{"pl":"fn GetQueuedCompletionStatus(\n    completion_port: HANDLE,\n    bytes_transferred_count: *DWORD,\n    lpCompletionKey: *usize,\n    lpOverlapped: *?*OVERLAPPED,\n    dwMilliseconds: DWORD,\n) GetQueuedCompletionStatusResult","src":362,"more_decls":null}{"pl":"pub fn CloseHandle(hObject: HANDLE) void {\n    assert(ntdll.NtClose(hObject) == .SUCCESS);\n}","src":391,"more_decls":null}{"pl":"pub fn FindClose(hFindFile: HANDLE) void {\n    assert(kernel32.FindClose(hFindFile) != 0);\n}","src":395,"more_decls":null}{"doc_comment":"If buffer's length exceeds what a Windows DWORD integer can hold, it will be broken into\nmultiple non-atomic reads.","pl":"fn ReadFile(in_hFile: HANDLE, buffer: []u8, offset: ?u64, io_mode: std.io.ModeOverride) ReadFileError!usize","src":407,"more_decls":null}{"pl":"fn WriteFile(\n    handle: HANDLE,\n    bytes: []const u8,\n    offset: ?u64,\n    io_mode: std.io.ModeOverride,\n) WriteFileError!usize","src":482,"more_decls":null}{"pl":"fn SetCurrentDirectory(path_name: []const u16) SetCurrentDirectoryError!void","src":569,"more_decls":null}{"doc_comment":"The result is a slice of `buffer`, indexed from 0.","pl":"fn GetCurrentDirectory(buffer: []u8) GetCurrentDirectoryError![]u8","src":601,"more_decls":null}{"doc_comment":"Needs either:\n- `SeCreateSymbolicLinkPrivilege` privilege\nor\n- Developper mode on Windows 10\notherwise fails with `error.AccessDenied`. In which case `sym_link_path` may still\nbe created on the file system but will lack reparse processing data applied to it.","pl":"fn CreateSymbolicLink(\n    dir: ?HANDLE,\n    sym_link_path: []const u16,\n    target_path: []const u16,\n    is_directory: bool,\n) CreateSymbolicLinkError!void","src":638,"more_decls":null}{"pl":"fn ReadLink(dir: ?HANDLE, sub_path_w: []const u16, out_buffer: []u8) ReadLinkError![]u8","src":700,"more_decls":null}{"pl":"fn DeleteFile(sub_path_w: []const u16, options: DeleteFileOptions) DeleteFileError!void","src":810,"more_decls":null}{"pl":"pub fn MoveFileEx(old_path: []const u8, new_path: []const u8, flags: DWORD) MoveFileError!void {\n    const old_path_w = try sliceToPrefixedFileW(old_path);\n    const new_path_w = try sliceToPrefixedFileW(new_path);\n    return MoveFileExW(old_path_w.span().ptr, new_path_w.span().ptr, flags);\n}","src":871,"more_decls":null}{"pl":"fn MoveFileExW(old_path: [*:0]const u16, new_path: [*:0]const u16, flags: DWORD) MoveFileError!void","src":877,"more_decls":null}{"pl":"fn GetStdHandle(handle_id: DWORD) GetStdHandleError!HANDLE","src":892,"more_decls":null}{"doc_comment":"The SetFilePointerEx function with the `dwMoveMethod` parameter set to `FILE_BEGIN`.","pl":"fn SetFilePointerEx_BEGIN(handle: HANDLE, offset: u64) SetFilePointerError!void","src":905,"more_decls":null}{"doc_comment":"The SetFilePointerEx function with the `dwMoveMethod` parameter set to `FILE_CURRENT`.","pl":"fn SetFilePointerEx_CURRENT(handle: HANDLE, offset: i64) SetFilePointerError!void","src":920,"more_decls":null}{"doc_comment":"The SetFilePointerEx function with the `dwMoveMethod` parameter set to `FILE_END`.","pl":"fn SetFilePointerEx_END(handle: HANDLE, offset: i64) SetFilePointerError!void","src":931,"more_decls":null}{"doc_comment":"The SetFilePointerEx function with parameters to get the current offset.","pl":"fn SetFilePointerEx_CURRENT_get(handle: HANDLE) SetFilePointerError!u64","src":942,"more_decls":null}{"pl":"fn QueryObjectName(\n    handle: HANDLE,\n    out_buffer: []u16,\n) ![]u16","src":956,"more_decls":null}{"doc_comment":"Returns canonical (normalized) path of handle.\nUse `GetFinalPathNameByHandleFormat` to specify whether the path is meant to include\nNT or DOS volume name (e.g., `\\Device\\HarddiskVolume0\\foo.txt` versus `C:\\foo.txt`).\nIf DOS volume name format is selected, note that this function does *not* prepend\n`\\\\?\\` prefix to the resultant path.","pl":"fn GetFinalPathNameByHandle(\n    hFile: HANDLE,\n    fmt: GetFinalPathNameByHandleFormat,\n    out_buffer: []u16,\n) GetFinalPathNameByHandleError![]u16","src":1028,"more_decls":null}{"pl":"fn QueryInformationFile(\n    handle: HANDLE,\n    info_class: FILE_INFORMATION_CLASS,\n    out_buffer: []u8,\n) QueryInformationFileError!void","src":1167,"more_decls":null}{"pl":"fn GetFileSizeEx(hFile: HANDLE) GetFileSizeError!u64","src":1184,"more_decls":null}{"pl":"pub fn GetFileAttributes(filename: []const u8) GetFileAttributesError!DWORD {\n    const filename_w = try sliceToPrefixedFileW(filename);\n    return GetFileAttributesW(filename_w.span().ptr);\n}","src":1200,"more_decls":null}{"pl":"fn GetFileAttributesW(lpFileName: [*:0]const u16) GetFileAttributesError!DWORD","src":1205,"more_decls":null}{"pl":"fn WSAStartup(majorVersion: u8, minorVersion: u8) !ws2_32.WSADATA","src":1218,"more_decls":null}{"pl":"fn WSACleanup() !void","src":1232,"more_decls":null}{"pl":"fn WSASocketW(\n    af: i32,\n    socket_type: i32,\n    protocol: i32,\n    protocolInfo: ?*ws2_32.WSAPROTOCOL_INFOW,\n    g: ws2_32.GROUP,\n    dwFlags: DWORD,\n) !ws2_32.SOCKET","src":1245,"more_decls":null}{"pl":"pub fn bind(s: ws2_32.SOCKET, name: *const ws2_32.sockaddr, namelen: ws2_32.socklen_t) i32 {\n    return ws2_32.bind(s, name, @intCast(i32, namelen));\n}","src":1266,"more_decls":null}{"pl":"pub fn listen(s: ws2_32.SOCKET, backlog: u31) i32 {\n    return ws2_32.listen(s, backlog);\n}","src":1270,"more_decls":null}{"pl":"fn closesocket(s: ws2_32.SOCKET) !void","src":1274,"more_decls":null}{"pl":"pub fn accept(s: ws2_32.SOCKET, name: ?*ws2_32.sockaddr, namelen: ?*ws2_32.socklen_t) ws2_32.SOCKET {\n    assert((name == null) == (namelen == null));\n    return ws2_32.accept(s, name, @ptrCast(?*i32, namelen));\n}","src":1284,"more_decls":null}{"pl":"pub fn getsockname(s: ws2_32.SOCKET, name: *ws2_32.sockaddr, namelen: *ws2_32.socklen_t) i32 {\n    return ws2_32.getsockname(s, name, @ptrCast(*i32, namelen));\n}","src":1289,"more_decls":null}{"pl":"fn sendmsg(\n    s: ws2_32.SOCKET,\n    msg: *const ws2_32.WSAMSG,\n    flags: u32,\n) i32","src":1293,"more_decls":null}{"pl":"fn sendto(s: ws2_32.SOCKET, buf: [*]const u8, len: usize, flags: u32, to: ?*const ws2_32.sockaddr, to_len: ws2_32.socklen_t) i32","src":1306,"more_decls":null}{"pl":"fn recvfrom(s: ws2_32.SOCKET, buf: [*]u8, len: usize, flags: u32, from: ?*ws2_32.sockaddr, from_len: ?*ws2_32.socklen_t) i32","src":1316,"more_decls":null}{"pl":"pub fn poll(fds: [*]ws2_32.pollfd, n: c_ulong, timeout: i32) i32 {\n    return ws2_32.WSAPoll(fds, n, timeout);\n}","src":1327,"more_decls":null}{"pl":"fn WSAIoctl(\n    s: ws2_32.SOCKET,\n    dwIoControlCode: DWORD,\n    inBuffer: ?[]const u8,\n    outBuffer: []u8,\n    overlapped: ?*ws2_32.WSAOVERLAPPED,\n    completionRoutine: ?ws2_32.WSAOVERLAPPED_COMPLETION_ROUTINE,\n) !DWORD","src":1331,"more_decls":null}{"pl":"fn GetModuleFileNameW(hModule: ?HMODULE, buf_ptr: [*]u16, buf_len: DWORD) GetModuleFileNameError![:0]u16","src":1362,"more_decls":null}{"pl":"fn TerminateProcess(hProcess: HANDLE, uExitCode: UINT) TerminateProcessError!void","src":1374,"more_decls":null}{"pl":"fn VirtualAlloc(addr: ?LPVOID, size: usize, alloc_type: DWORD, flProtect: DWORD) VirtualAllocError!LPVOID","src":1384,"more_decls":null}{"pl":"pub fn VirtualFree(lpAddress: ?LPVOID, dwSize: usize, dwFreeType: DWORD) void {\n    assert(kernel32.VirtualFree(lpAddress, dwSize, dwFreeType) != 0);\n}","src":1392,"more_decls":null}{"pl":"fn SetConsoleTextAttribute(hConsoleOutput: HANDLE, wAttributes: WORD) SetConsoleTextAttributeError!void","src":1398,"more_decls":null}{"pl":"pub fn GetEnvironmentStringsW() GetEnvironmentStringsError![*:0]u16 {\n    return kernel32.GetEnvironmentStringsW() orelse return error.OutOfMemory;\n}","src":1408,"more_decls":null}{"pl":"pub fn FreeEnvironmentStringsW(penv: [*:0]u16) void {\n    assert(kernel32.FreeEnvironmentStringsW(penv) != 0);\n}","src":1412,"more_decls":null}{"pl":"fn GetEnvironmentVariableW(lpName: LPWSTR, lpBuffer: [*]u16, nSize: DWORD) GetEnvironmentVariableError!DWORD","src":1421,"more_decls":null}{"pl":"fn CreateProcessW(\n    lpApplicationName: ?LPWSTR,\n    lpCommandLine: LPWSTR,\n    lpProcessAttributes: ?*SECURITY_ATTRIBUTES,\n    lpThreadAttributes: ?*SECURITY_ATTRIBUTES,\n    bInheritHandles: BOOL,\n    dwCreationFlags: DWORD,\n    lpEnvironment: ?*c_void,\n    lpCurrentDirectory: ?LPWSTR,\n    lpStartupInfo: *STARTUPINFOW,\n    lpProcessInformation: *PROCESS_INFORMATION,\n) CreateProcessError!void","src":1439,"more_decls":null}{"pl":"fn LoadLibraryW(lpLibFileName: [*:0]const u16) LoadLibraryError!HMODULE","src":1479,"more_decls":null}{"pl":"pub fn FreeLibrary(hModule: HMODULE) void {\n    assert(kernel32.FreeLibrary(hModule) != 0);\n}","src":1490,"more_decls":null}{"pl":"fn QueryPerformanceFrequency() u64","src":1494,"more_decls":null}{"pl":"fn QueryPerformanceCounter() u64","src":1503,"more_decls":null}{"pl":"pub fn InitOnceExecuteOnce(InitOnce: *INIT_ONCE, InitFn: INIT_ONCE_FN, Parameter: ?*c_void, Context: ?*c_void) void {\n    assert(kernel32.InitOnceExecuteOnce(InitOnce, InitFn, Parameter, Context) != 0);\n}","src":1512,"more_decls":null}{"pl":"pub fn HeapFree(hHeap: HANDLE, dwFlags: DWORD, lpMem: *c_void) void {\n    assert(kernel32.HeapFree(hHeap, dwFlags, lpMem) != 0);\n}","src":1516,"more_decls":null}{"pl":"pub fn HeapDestroy(hHeap: HANDLE) void {\n    assert(kernel32.HeapDestroy(hHeap) != 0);\n}","src":1520,"more_decls":null}{"pl":"fn GetFileInformationByHandle(\n    hFile: HANDLE,\n) GetFileInformationByHandleError!BY_HANDLE_FILE_INFORMATION","src":1526,"more_decls":null}{"pl":"fn SetFileTime(\n    hFile: HANDLE,\n    lpCreationTime: ?*const FILETIME,\n    lpLastAccessTime: ?*const FILETIME,\n    lpLastWriteTime: ?*const FILETIME,\n) SetFileTimeError!void","src":1541,"more_decls":null}{"pl":"fn teb() *TEB","src":1555,"more_decls":null}{"pl":"pub fn peb() *PEB {\n    return teb().ProcessEnvironmentBlock;\n}","src":1573,"more_decls":null}{"doc_comment":"A file time is a 64-bit value that represents the number of 100-nanosecond\nintervals that have elapsed since 12:00 A.M. January 1, 1601 Coordinated\nUniversal Time (UTC).\nThis function returns the number of nanoseconds since the canonical epoch,\nwhich is the POSIX one (Jan 01, 1970 AD).","pl":"pub fn fromSysTime(hns: i64) i128 {\n    const adjusted_epoch: i128 = hns + std.time.epoch.windows * (std.time.ns_per_s / 100);\n    return adjusted_epoch * 100;\n}","src":1582,"more_decls":null}{"pl":"pub fn toSysTime(ns: i128) i64 {\n    const hns = @divFloor(ns, 100);\n    return @intCast(i64, hns) - std.time.epoch.windows * (std.time.ns_per_s / 100);\n}","src":1587,"more_decls":null}{"pl":"pub fn fileTimeToNanoSeconds(ft: FILETIME) i128 {\n    const hns = (@as(i64, ft.dwHighDateTime) << 32) | ft.dwLowDateTime;\n    return fromSysTime(hns);\n}","src":1592,"more_decls":null}{"doc_comment":"Converts a number of nanoseconds since the POSIX epoch to a Windows FILETIME.","pl":"fn nanoSecondsToFileTime(ns: i128) FILETIME","src":1598,"more_decls":null}{"doc_comment":"Same as `sliceToPrefixedFileW` but accepts a pointer\nto a null-terminated path.","pl":"pub fn cStrToPrefixedFileW(s: [*:0]const u8) !PathSpace {\n    return sliceToPrefixedFileW(mem.spanZ(s));\n}","src":1617,"more_decls":null}{"doc_comment":"Converts the path `s` to WTF16, null-terminated. If the path is absolute,\nit will get NT-style prefix `\\??\\` prepended automatically.","pl":"fn sliceToPrefixedFileW(s: []const u8) !PathSpace","src":1623,"more_decls":null}{"doc_comment":"Assumes an absolute path.","pl":"fn wToPrefixedFileW(s: []const u16) !PathSpace","src":1657,"more_decls":null}{"doc_comment":"Call this when you made a windows DLL call or something that does SetLastError\nand you get an unexpected error.","pl":"fn unexpectedError(err: Win32Error) std.os.UnexpectedError","src":1690,"more_decls":null}{"pl":"pub fn unexpectedWSAError(err: ws2_32.WinsockError) std.os.UnexpectedError {\n    return unexpectedError(@intToEnum(Win32Error, @enumToInt(err)));\n}","src":1711,"more_decls":null}{"doc_comment":"Call this when you made a windows NtDll call\nand you get an unexpected status.","pl":"fn unexpectedStatus(status: NTSTATUS) std.os.UnexpectedError","src":1717,"more_decls":null}{"pl":"const advapi32 = @import(\"windows/advapi32.zig\")","src":18,"more_decls":null}{"pl":"const kernel32 = @import(\"windows/kernel32.zig\")","src":19,"more_decls":null}{"pl":"const ntdll = @import(\"windows/ntdll.zig\")","src":20,"more_decls":null}{"pl":"const ole32 = @import(\"windows/ole32.zig\")","src":21,"more_decls":null}{"pl":"const psapi = @import(\"windows/psapi.zig\")","src":22,"more_decls":null}{"pl":"const shell32 = @import(\"windows/shell32.zig\")","src":23,"more_decls":null}{"pl":"const user32 = @import(\"windows/user32.zig\")","src":24,"more_decls":null}{"pl":"const ws2_32 = @import(\"windows/ws2_32.zig\")","src":25,"more_decls":null}{"pl":"const gdi32 = @import(\"windows/gdi32.zig\")","src":26,"more_decls":null}{"pl":"const self_process_handle = @intToPtr(HANDLE, maxInt(usize))","src":30,"more_decls":null}{"pl":"const OpenError = error{\n    IsDir,\n    NotDir,\n    FileNotFound,\n    NoDevice,\n    AccessDenied,\n    PipeBusy,\n    PathAlreadyExists,\n    Unexpected,\n    NameTooLong,\n    WouldBlock,\n}","src":32,"more_decls":null}{"pl":"const CreatePipeError = error{Unexpected}","src":145,"more_decls":null}{"pl":"const DeviceIoControlError = error{ AccessDenied, Unexpected }","src":171,"more_decls":null}{"pl":"const SetHandleInformationError = error{Unexpected}","src":241,"more_decls":null}{"pl":"const RtlGenRandomError = error{Unexpected}","src":251,"more_decls":null}{"pl":"const WaitForSingleObjectError = error{\n    WaitAbandoned,\n    WaitTimeOut,\n    Unexpected,\n}","src":273,"more_decls":null}{"pl":"const CreateIoCompletionPortError = error{Unexpected}","src":323,"more_decls":null}{"pl":"const PostQueuedCompletionStatusError = error{Unexpected}","src":340,"more_decls":null}{"pl":"const ReadFileError = error{\n    OperationAborted,\n    BrokenPipe,\n    Unexpected,\n}","src":399,"more_decls":null}{"pl":"const WriteFileError = error{\n    SystemResources,\n    OperationAborted,\n    BrokenPipe,\n    NotOpenForWriting,\n    Unexpected,\n}","src":474,"more_decls":null}{"pl":"const SetCurrentDirectoryError = error{\n    NameTooLong,\n    InvalidUtf8,\n    FileNotFound,\n    NotDir,\n    AccessDenied,\n    NoDevice,\n    BadPathName,\n    Unexpected,\n}","src":558,"more_decls":null}{"pl":"const GetCurrentDirectoryError = error{\n    NameTooLong,\n    Unexpected,\n}","src":595,"more_decls":null}{"pl":"const CreateSymbolicLinkError = error{\n    AccessDenied,\n    PathAlreadyExists,\n    FileNotFound,\n    NameTooLong,\n    NoDevice,\n    Unexpected,\n}","src":623,"more_decls":null}{"pl":"const ReadLinkError = error{\n    FileNotFound,\n    AccessDenied,\n    Unexpected,\n    NameTooLong,\n    UnsupportedReparsePointType,\n}","src":692,"more_decls":null}{"pl":"const DeleteFileError = error{\n    FileNotFound,\n    AccessDenied,\n    NameTooLong,\n    /// Also known as sharing violation.\n    FileBusy,\n    Unexpected,\n    NotDir,\n    IsDir,\n}","src":794,"more_decls":null}{"pl":"const MoveFileError = error{ FileNotFound, AccessDenied, Unexpected }","src":869,"more_decls":null}{"pl":"const GetStdHandleError = error{\n    NoStandardHandleAttached,\n    Unexpected,\n}","src":887,"more_decls":null}{"pl":"const SetFilePointerError = error{Unexpected}","src":902,"more_decls":null}{"pl":"const GetFinalPathNameByHandleError = error{\n    AccessDenied,\n    BadPathName,\n    FileNotFound,\n    NameTooLong,\n    Unexpected,\n}","src":1004,"more_decls":null}{"pl":"const QueryInformationFileError = error{Unexpected}","src":1165,"more_decls":null}{"pl":"const GetFileSizeError = error{Unexpected}","src":1182,"more_decls":null}{"pl":"const GetFileAttributesError = error{\n    FileNotFound,\n    PermissionDenied,\n    Unexpected,\n}","src":1194,"more_decls":null}{"pl":"const TerminateProcessError = error{Unexpected}","src":1372,"more_decls":null}{"pl":"const VirtualAllocError = error{Unexpected}","src":1382,"more_decls":null}{"pl":"const SetConsoleTextAttributeError = error{Unexpected}","src":1396,"more_decls":null}{"pl":"const GetEnvironmentStringsError = error{OutOfMemory}","src":1406,"more_decls":null}{"pl":"const GetEnvironmentVariableError = error{\n    EnvironmentVariableNotFound,\n    Unexpected,\n}","src":1416,"more_decls":null}{"pl":"const CreateProcessError = error{\n    FileNotFound,\n    AccessDenied,\n    InvalidName,\n    Unexpected,\n}","src":1432,"more_decls":null}{"pl":"const LoadLibraryError = error{\n    FileNotFound,\n    Unexpected,\n}","src":1474,"more_decls":null}{"pl":"const GetFileInformationByHandleError = error{Unexpected}","src":1524,"more_decls":null}{"pl":"const SetFileTimeError = error{Unexpected}","src":1539,"more_decls":null}]