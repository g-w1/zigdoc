[{"pl":"pub const Address = extern union ","src":20,"more_decls":{"pl":"any: os.sockaddr","src":21,"more_decls":null}{"pl":"in: Ip4Address","src":22,"more_decls":null}{"pl":"in6: Ip6Address","src":23,"more_decls":null}{"pl":"un: if (has_unix_sockets) os.sockaddr_un else void","src":24,"more_decls":null}{"doc_comment":"Parse the given IP address string into an Address value.\nIt is recommended to use `resolveIp` instead, to handle\nIPv6 link-local unix addresses.","pl":"fn parseIp(name: []const u8, port: u16) !Address","src":29,"more_decls":null}{"pl":"fn resolveIp(name: []const u8, port: u16) !Address","src":50,"more_decls":null}{"pl":"fn parseExpectingFamily(name: []const u8, family: os.sa_family_t, port: u16) !Address","src":72,"more_decls":null}{"pl":"pub fn parseIp6(buf: []const u8, port: u16) !Address {\n    return Address{ .in6 = try Ip6Address.parse(buf, port) };\n}","src":81,"more_decls":null}{"pl":"pub fn resolveIp6(buf: []const u8, port: u16) !Address {\n    return Address{ .in6 = try Ip6Address.resolve(buf, port) };\n}","src":85,"more_decls":null}{"pl":"pub fn parseIp4(buf: []const u8, port: u16) !Address {\n    return Address{ .in = try Ip4Address.parse(buf, port) };\n}","src":89,"more_decls":null}{"pl":"pub fn initIp4(addr: [4]u8, port: u16) Address {\n    return Address{ .in = Ip4Address.init(addr, port) };\n}","src":93,"more_decls":null}{"pl":"pub fn initIp6(addr: [16]u8, port: u16, flowinfo: u32, scope_id: u32) Address {\n    return Address{ .in6 = Ip6Address.init(addr, port, flowinfo, scope_id) };\n}","src":97,"more_decls":null}{"pl":"fn initUnix(path: []const u8) !Address","src":101,"more_decls":null}{"doc_comment":"Returns the port in native endian.\nAsserts that the address is ip4 or ip6.","pl":"fn getPort(self: Address) u16","src":118,"more_decls":null}{"doc_comment":"`port` is native-endian.\nAsserts that the address is ip4 or ip6.","pl":"fn setPort(self: *Address, port: u16) void","src":128,"more_decls":null}{"doc_comment":"Asserts that `addr` is an IP address.\nThis function will read past the end of the pointer, with a size depending\non the address family.","pl":"fn initPosix(addr: *align(4) const os.sockaddr) Address","src":139,"more_decls":null}{"pl":"fn format(\n    self: Address,\n    comptime fmt: []const u8,\n    options: std.fmt.FormatOptions,\n    out_stream: anytype,\n) !void","src":147,"more_decls":null}{"pl":"pub fn eql(a: Address, b: Address) bool {\n    const a_bytes = @ptrCast([*]const u8, &a.any)[0..a.getOsSockLen()];\n    const b_bytes = @ptrCast([*]const u8, &b.any)[0..b.getOsSockLen()];\n    return mem.eql(u8, a_bytes, b_bytes);\n}","src":167,"more_decls":null}{"pl":"fn getOsSockLen(self: Address) os.socklen_t","src":173,"more_decls":null}}{"pl":"pub const Ip4Address = extern struct ","src":190,"more_decls":{"pl":"sa: os.sockaddr_in","src":191,"more_decls":null}{"pl":"fn parse(buf: []const u8, port: u16) !Ip4Address","src":193,"more_decls":null}{"pl":"fn resolveIp(name: []const u8, port: u16) !Ip4Address","src":233,"more_decls":null}{"pl":"fn init(addr: [4]u8, port: u16) Ip4Address","src":244,"more_decls":null}{"doc_comment":"Returns the port in native endian.\nAsserts that the address is ip4 or ip6.","pl":"pub fn getPort(self: Ip4Address) u16 {\n    return mem.bigToNative(u16, self.sa.port);\n}","src":255,"more_decls":null}{"doc_comment":"`port` is native-endian.\nAsserts that the address is ip4 or ip6.","pl":"pub fn setPort(self: *Ip4Address, port: u16) void {\n    self.sa.port = mem.nativeToBig(u16, port);\n}","src":261,"more_decls":null}{"pl":"fn format(\n    self: Ip4Address,\n    comptime fmt: []const u8,\n    options: std.fmt.FormatOptions,\n    out_stream: anytype,\n) !void","src":265,"more_decls":null}{"pl":"pub fn getOsSockLen(self: Ip4Address) os.socklen_t {\n    return @sizeOf(os.sockaddr_in);\n}","src":281,"more_decls":null}}{"pl":"pub const Ip6Address = extern struct ","src":286,"more_decls":{"pl":"sa: os.sockaddr_in6","src":287,"more_decls":null}{"doc_comment":"Parse a given IPv6 address string into an Address.\nAssumes the Scope ID of the address is fully numeric.\nFor non-numeric addresses, see `resolveIp6`.","pl":"fn parse(buf: []const u8, port: u16) !Ip6Address","src":292,"more_decls":null}{"pl":"fn resolve(buf: []const u8, port: u16) !Ip6Address","src":398,"more_decls":null}{"pl":"fn init(addr: [16]u8, port: u16, flowinfo: u32, scope_id: u32) Ip6Address","src":528,"more_decls":null}{"doc_comment":"Returns the port in native endian.\nAsserts that the address is ip4 or ip6.","pl":"pub fn getPort(self: Ip6Address) u16 {\n    return mem.bigToNative(u16, self.sa.port);\n}","src":541,"more_decls":null}{"doc_comment":"`port` is native-endian.\nAsserts that the address is ip4 or ip6.","pl":"pub fn setPort(self: *Ip6Address, port: u16) void {\n    self.sa.port = mem.nativeToBig(u16, port);\n}","src":547,"more_decls":null}{"pl":"fn format(\n    self: Ip6Address,\n    comptime fmt: []const u8,\n    options: std.fmt.FormatOptions,\n    out_stream: anytype,\n) !void","src":551,"more_decls":null}{"pl":"pub fn getOsSockLen(self: Ip6Address) os.socklen_t {\n    return @sizeOf(os.sockaddr_in6);\n}","src":598,"more_decls":null}}{"pl":"pub const AddressList = struct ","src":640,"more_decls":{"pl":"arena: std.heap.ArenaAllocator","src":641,"more_decls":null}{"pl":"addrs: []Address","src":642,"more_decls":null}{"pl":"canon_name: ?[]u8","src":643,"more_decls":null}{"pl":"fn deinit(self: *AddressList) void","src":645,"more_decls":null}}{"pl":"pub const Stream = struct ","src":1587,"more_decls":{"pl":"handle: os.socket_t","src":1591,"more_decls":null}{"pl":"pub fn close(self: Stream) void {\n    os.closeSocket(self.handle);\n}","src":1593,"more_decls":null}{"pl":"pub fn reader(self: Stream) Reader {\n    return .{ .context = self };\n}","src":1603,"more_decls":null}{"pl":"pub fn writer(self: Stream) Writer {\n    return .{ .context = self };\n}","src":1607,"more_decls":null}{"pl":"fn read(self: Stream, buffer: []u8) ReadError!usize","src":1611,"more_decls":null}{"doc_comment":"TODO in evented I/O mode, this implementation incorrectly uses the event loop's\nfile system thread instead of non-blocking. It needs to be reworked to properly\nuse non-blocking I/O.","pl":"fn write(self: Stream, buffer: []const u8) WriteError!usize","src":1626,"more_decls":null}{"doc_comment":"See https://github.com/ziglang/zig/issues/7699\nSee equivalent function: `std.fs.File.writev`.","pl":"fn writev(self: Stream, iovecs: []const os.iovec_const) WriteError!usize","src":1640,"more_decls":null}{"doc_comment":"The `iovecs` parameter is mutable because this function needs to mutate the fields in\norder to handle partial writes from the underlying OS layer.\nSee https://github.com/ziglang/zig/issues/7699\nSee equivalent function: `std.fs.File.writevAll`.","pl":"fn writevAll(self: Stream, iovecs: []os.iovec_const) WriteError!void","src":1656,"more_decls":null}{"pl":"const ReadError = os.ReadError","src":1597,"more_decls":null}{"pl":"const WriteError = os.WriteError","src":1598,"more_decls":null}{"pl":"const Reader = io.Reader(Stream, ReadError, read)","src":1600,"more_decls":null}{"pl":"const Writer = io.Writer(Stream, WriteError, write)","src":1601,"more_decls":null}}{"pl":"pub const StreamServer = struct ","src":1673,"more_decls":{"doc_comment":"Copied from `Options` on `init`.","pl":"kernel_backlog: u31","src":1675,"more_decls":null}{"pl":"reuse_address: bool","src":1676,"more_decls":null}{"doc_comment":"`undefined` until `listen` returns successfully.","pl":"listen_address: Address","src":1679,"more_decls":null}{"pl":"sockfd: ?os.socket_t","src":1681,"more_decls":null}{"pl":"pub const Options = struct ","src":1683,"more_decls":{"doc_comment":"How many connections the kernel will accept on the application's behalf.\nIf more than this many connections pool in the kernel, clients will start\nseeing \"Connection refused\".","pl":"kernel_backlog: u31 = 128","src":1687,"more_decls":null}{"doc_comment":"Enable SO_REUSEADDR on the socket.","pl":"reuse_address: bool = false","src":1690,"more_decls":null}}{"pl":"pub const Connection = struct ","src":1778,"more_decls":{"pl":"stream: Stream","src":1779,"more_decls":null}{"pl":"address: Address","src":1780,"more_decls":null}}{"doc_comment":"After this call succeeds, resources have been acquired and must\nbe released with `deinit`.","pl":"fn init(options: Options) StreamServer","src":1695,"more_decls":null}{"doc_comment":"Release all resources. The `StreamServer` memory becomes `undefined`.","pl":"pub fn deinit(self: *StreamServer) void {\n    self.close();\n    self.* = undefined;\n}","src":1705,"more_decls":null}{"pl":"fn listen(self: *StreamServer, address: Address) !void","src":1710,"more_decls":null}{"doc_comment":"Stop listening. It is still necessary to call `deinit` after stopping listening.\nCalling `deinit` will automatically call `close`. It is safe to call `close` when\nnot listening.","pl":"fn close(self: *StreamServer) void","src":1740,"more_decls":null}{"doc_comment":"If this function succeeds, the returned `Connection` is a caller-managed resource.","pl":"fn accept(self: *StreamServer) AcceptError!Connection","src":1784,"more_decls":null}{"pl":"const AcceptError = error{\n        ConnectionAborted,\n\n        /// The per-process limit on the number of open file descriptors has been reached.\n        ProcessFdQuotaExceeded,\n\n        /// The system-wide limit on the total number of open files has been reached.\n        SystemFdQuotaExceeded,\n\n        /// Not enough free memory.  This often means that the memory allocation  is  limited\n        /// by the socket buffer limits, not by the system memory.\n        SystemResources,\n\n        /// Socket is not listening for new connections.\n        SocketNotListening,\n\n        ProtocolFailure,\n\n        /// Firewall rules forbid connection.\n        BlockedByFirewall,\n\n        FileDescriptorNotASocket,\n\n        ConnectionResetByPeer,\n\n        NetworkSubsystemFailed,\n\n        OperationNotSupported,\n    } || os.UnexpectedError","src":1748,"more_decls":null}}{"pl":"fn connectUnixSocket(path: []const u8) !Stream","src":603,"more_decls":null}{"doc_comment":"All memory allocated with `allocator` will be freed before this function returns.","pl":"fn tcpConnectToHost(allocator: *mem.Allocator, name: []const u8, port: u16) !Stream","src":655,"more_decls":null}{"pl":"fn tcpConnectToAddress(address: Address) !Stream","src":672,"more_decls":null}{"doc_comment":"Call `AddressList.deinit` on the result.","pl":"fn getAddressList(allocator: *mem.Allocator, name: []const u8, port: u16) !*AddressList","src":690,"more_decls":null}{"pl":"fn isValidHostName(hostname: []const u8) bool","src":1156,"more_decls":null}{"pl":"const has_unix_sockets = @hasDecl(os, \"sockaddr_un\") and\n    (builtin.os.tag != .windows or\n    std.Target.current.os.version_range.windows.isAtLeast(.win10_rs4) orelse false)","src":16,"more_decls":null}]