[{"doc_comment":"Type-tag of WASI preopen.\n\nWASI currently offers only `Dir` as a valid preopen resource.","pl":"pub const PreopenTypeTag = enum ","src":16,"more_decls":{"pl":"Dir","src":17,"more_decls":null}}{"doc_comment":"Type of WASI preopen.\n\nWASI currently offers only `Dir` as a valid preopen resource.","pl":"pub const PreopenType = union","src":23,"more_decls":{"doc_comment":"Preopened directory type.","pl":"Dir: []const u8","src":25,"more_decls":null}{"pl":"fn eql(self: Self, other: PreopenType) bool","src":29,"more_decls":null}{"pl":"fn format(self: Self, comptime fmt: []const u8, options: std.fmt.FormatOptions, out_stream: anytype) !void","src":37,"more_decls":null}}{"doc_comment":"WASI preopen struct. This struct consists of a WASI file descriptor\nand type of WASI preopen. It can be obtained directly from the WASI\nruntime using `PreopenList.populate()` method.","pl":"pub const Preopen = struct ","src":49,"more_decls":{"doc_comment":"WASI file descriptor.","pl":"fd: fd_t","src":51,"more_decls":null}{"doc_comment":"Type of the preopen.","pl":"@\"type\": PreopenType","src":54,"more_decls":null}{"doc_comment":"Construct new `Preopen` instance.","pl":"pub fn new(fd: fd_t, preopen_type: PreopenType) Preopen {\n    return Preopen{\n        .fd = fd,\n        .@\"type\" = preopen_type,\n    };\n}","src":57,"more_decls":null}}{"doc_comment":"Dynamically-sized array list of WASI preopens. This struct is a\nconvenience wrapper for issuing `std.os.wasi.fd_prestat_get` and\n`std.os.wasi.fd_prestat_dir_name` syscalls to the WASI runtime, and\ncollecting the returned preopens.\n\nThis struct is intended to be used in any WASI program which intends\nto use the capabilities as passed on by the user of the runtime.","pl":"pub const PreopenList = struct ","src":72,"more_decls":{"doc_comment":"Internal dynamically-sized buffer for storing the gathered preopens.","pl":"buffer: InnerList","src":76,"more_decls":null}{"doc_comment":"Deinitialize with `deinit`.","pl":"pub fn init(allocator: *Allocator) Self {\n    return Self{ .buffer = InnerList.init(allocator) };\n}","src":83,"more_decls":null}{"doc_comment":"Release all allocated memory.","pl":"fn deinit(pm: Self) void","src":88,"more_decls":null}{"doc_comment":"Populate the list with the preopens by issuing `std.os.wasi.fd_prestat_get`\nand `std.os.wasi.fd_prestat_dir_name` syscalls to the runtime.\n\nIf called more than once, it will clear its contents every time before\nissuing the syscalls.\n\nIn the unlinkely event of overflowing the number of available file descriptors,\nreturns `error.Overflow`. In this case, even though an error condition was reached\nthe preopen list still contains all valid preopened file descriptors that are valid\nfor use. Therefore, it is fine to call `find`, `asSlice`, or `toOwnedSlice`. Finally,\n`deinit` still must be called!","pl":"fn populate(self: *Self) Error!void","src":108,"more_decls":null}{"doc_comment":"Find preopen by type. If the preopen exists, return it.\nOtherwise, return `null`.","pl":"fn find(self: Self, preopen_type: PreopenType) ?*const Preopen","src":148,"more_decls":null}{"doc_comment":"Return the inner buffer as read-only slice.","pl":"pub fn asSlice(self: Self) []const Preopen {\n    return self.buffer.items;\n}","src":158,"more_decls":null}{"doc_comment":"The caller owns the returned memory. ArrayList becomes empty.","pl":"pub fn toOwnedSlice(self: *Self) []Preopen {\n    return self.buffer.toOwnedSlice();\n}","src":163,"more_decls":null}{"pl":"const Error = error{ OutOfMemory, Overflow } || os.UnexpectedError","src":80,"more_decls":null}}]