[{"pl":"pub const WindowsPath = struct ","src":275,"more_decls":{"pl":"is_abs: bool","src":276,"more_decls":null}{"pl":"kind: Kind","src":277,"more_decls":null}{"pl":"disk_designator: []const u8","src":278,"more_decls":null}{"pl":"pub const Kind = enum ","src":280,"more_decls":{"pl":"None","src":281,"more_decls":null}{"pl":"Drive","src":282,"more_decls":null}{"pl":"NetworkShare","src":283,"more_decls":null}}}{"doc_comment":"Returns if the given byte is a valid path separator","pl":"fn isSep(byte: u8) bool","src":31,"more_decls":null}{"doc_comment":"Naively combines a series of paths with the native path seperator.\nAllocates memory for the result, which must be freed by the caller.","pl":"pub fn join(allocator: *Allocator, paths: []const []const u8) ![]u8 {\n    return joinSepMaybeZ(allocator, sep, isSep, paths, false);\n}","src":87,"more_decls":null}{"doc_comment":"Naively combines a series of paths with the native path seperator and null terminator.\nAllocates memory for the result, which must be freed by the caller.","pl":"pub fn joinZ(allocator: *Allocator, paths: []const []const u8) ![:0]u8 {\n    const out = try joinSepMaybeZ(allocator, sep, isSep, paths, true);\n    return out[0 .. out.len - 1 :0];\n}","src":93,"more_decls":null}{"pl":"fn isAbsoluteZ(path_c: [*:0]const u8) bool","src":169,"more_decls":null}{"pl":"fn isAbsolute(path: []const u8) bool","src":177,"more_decls":null}{"pl":"pub fn isAbsoluteWindows(path: []const u8) bool {\n    return isAbsoluteWindowsImpl(u8, path);\n}","src":208,"more_decls":null}{"pl":"pub fn isAbsoluteWindowsW(path_w: [*:0]const u16) bool {\n    return isAbsoluteWindowsImpl(u16, mem.spanZ(path_w));\n}","src":212,"more_decls":null}{"pl":"pub fn isAbsoluteWindowsWTF16(path: []const u16) bool {\n    return isAbsoluteWindowsImpl(u16, path);\n}","src":216,"more_decls":null}{"pl":"pub fn isAbsoluteWindowsZ(path_c: [*:0]const u8) bool {\n    return isAbsoluteWindowsImpl(u8, mem.spanZ(path_c));\n}","src":222,"more_decls":null}{"pl":"pub fn isAbsolutePosix(path: []const u8) bool {\n    return path.len > 0 and path[0] == sep_posix;\n}","src":226,"more_decls":null}{"pl":"pub fn isAbsolutePosixZ(path_c: [*:0]const u8) bool {\n    return isAbsolutePosix(mem.spanZ(path_c));\n}","src":232,"more_decls":null}{"pl":"fn windowsParsePath(path: []const u8) WindowsPath","src":287,"more_decls":null}{"pl":"fn diskDesignator(path: []const u8) []const u8","src":366,"more_decls":null}{"pl":"pub fn diskDesignatorWindows(path: []const u8) []const u8 {\n    return windowsParsePath(path).disk_designator;\n}","src":374,"more_decls":null}{"doc_comment":"On Windows, this calls `resolveWindows` and on POSIX it calls `resolvePosix`.","pl":"fn resolve(allocator: *Allocator, paths: []const []const u8) ![]u8","src":431,"more_decls":null}{"doc_comment":"This function is like a series of `cd` statements executed one after another.\nIt resolves \".\" and \"..\".\nThe result does not have a trailing path separator.\nIf all paths are relative it uses the current working directory as a starting point.\nEach drive has its own current working directory.\nPath separators are canonicalized to '\\\\' and drives are canonicalized to capital letters.\nNote: all usage of this function should be audited due to the existence of symlinks.\nWithout performing actual syscalls, resolving `..` could be incorrect.","pl":"fn resolveWindows(allocator: *Allocator, paths: []const []const u8) ![]u8","src":447,"more_decls":null}{"doc_comment":"This function is like a series of `cd` statements executed one after another.\nIt resolves \".\" and \"..\".\nThe result does not have a trailing path separator.\nIf all paths are relative it uses the current working directory as a starting point.\nNote: all usage of this function should be audited due to the existence of symlinks.\nWithout performing actual syscalls, resolving `..` could be incorrect.","pl":"fn resolvePosix(allocator: *Allocator, paths: []const []const u8) ![]u8","src":628,"more_decls":null}{"doc_comment":"Strip the last component from a file path.\n\nIf the path is a file in the current directory (no directory component)\nthen returns null.\n\nIf the path is the root directory, returns null.","pl":"fn dirname(path: []const u8) ?[]const u8","src":789,"more_decls":null}{"pl":"fn dirnameWindows(path: []const u8) ?[]const u8","src":797,"more_decls":null}{"pl":"fn dirnamePosix(path: []const u8) ?[]const u8","src":831,"more_decls":null}{"pl":"fn basename(path: []const u8) []const u8","src":923,"more_decls":null}{"pl":"fn basenamePosix(path: []const u8) []const u8","src":931,"more_decls":null}{"pl":"fn basenameWindows(path: []const u8) []const u8","src":952,"more_decls":null}{"doc_comment":"Returns the relative path from `from` to `to`. If `from` and `to` each\nresolve to the same path (after calling `resolve` on each), a zero-length\nstring is returned.\nOn Windows this canonicalizes the drive to a capital letter and paths to `\\\\`.","pl":"fn relative(allocator: *Allocator, from: []const u8, to: []const u8) ![]u8","src":1039,"more_decls":null}{"pl":"fn relativeWindows(allocator: *Allocator, from: []const u8, to: []const u8) ![]u8","src":1047,"more_decls":null}{"pl":"fn relativePosix(allocator: *Allocator, from: []const u8, to: []const u8) ![]u8","src":1120,"more_decls":null}{"doc_comment":"Returns the extension of the file name (if any).\nThis function will search for the file extension (separated by a `.`) and will return the text after the `.`.\nFiles that end with `.` are considered to have no extension, files that start with `.`\nExamples:\n- `\"main.zig\"`     ⇒ `\".zig\"`\n- `\"src/main.zig\"` ⇒ `\".zig\"`\n- `\".gitignore\"`   ⇒ `\"\"`\n- `\"keep.\"`        ⇒ `\".\"`\n- `\"src.keep.me\"`  ⇒ `\".me\"`\n- `\"/src/keep.me\"`  ⇒ `\".me\"`\n- `\"/src/keep.me/\"`  ⇒ `\".me\"`\nThe returned slice is guaranteed to have its pointer within the start and end\npointer address range of `path`, even if it is length zero.","pl":"pub fn extension(path: []const u8) []const u8 {\n    const filename = basename(path);\n    const index = mem.lastIndexOfScalar(u8, filename, '.') orelse return path[path.len..];\n    if (index == 0) return path[path.len..];\n    return filename[index..];\n}","src":1236,"more_decls":null}{"pl":"const sep_windows = '\\\\'","src":18,"more_decls":null}{"pl":"const sep_posix = '/'","src":19,"more_decls":null}{"pl":"const sep = if (builtin.os.tag == .windows) sep_windows else sep_posix","src":20,"more_decls":null}{"pl":"const sep_str_windows = \"\\\\\"","src":22,"more_decls":null}{"pl":"const sep_str_posix = \"/\"","src":23,"more_decls":null}{"pl":"const sep_str = if (builtin.os.tag == .windows) sep_str_windows else sep_str_posix","src":24,"more_decls":null}{"pl":"const delimiter_windows = ';'","src":26,"more_decls":null}{"pl":"const delimiter_posix = ':'","src":27,"more_decls":null}{"pl":"const delimiter = if (builtin.os.tag == .windows) delimiter_windows else delimiter_posix","src":28,"more_decls":null}{"pl":"const isAbsoluteC = @compileError(\"deprecated: renamed to isAbsoluteZ\")","src":167,"more_decls":null}{"pl":"const isAbsoluteWindowsC = @compileError(\"deprecated: renamed to isAbsoluteWindowsZ\")","src":220,"more_decls":null}{"pl":"const isAbsolutePosixC = @compileError(\"deprecated: renamed to isAbsolutePosixZ\")","src":230,"more_decls":null}]