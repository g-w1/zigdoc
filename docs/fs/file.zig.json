[{"pl":"pub const File = struct ","src":17,"more_decls":{"doc_comment":"The OS-specific file descriptor or file handle.","pl":"handle: os.fd_t","src":19,"more_decls":null}{"doc_comment":"On some systems, such as Linux, file system file descriptors are incapable of non-blocking I/O.\nThis forces us to perform asynchronous I/O on a dedicated thread, to achieve non-blocking\nfile-system I/O. To do this, `File` must be aware of whether it is a file system file descriptor,\nor, more specifically, whether the I/O is always blocking.","pl":"capable_io_mode: io.ModeOverride = io.default_mode","src":25,"more_decls":null}{"doc_comment":"Furthermore, even when `std.io.mode` is async, it is still sometimes desirable to perform blocking I/O,\nalthough not by default. For example, when printing a stack trace to stderr.\nThis field tracks both by acting as an overriding I/O mode. When not building in async I/O mode,\nthe type only has the `.blocking` tag, making it a zero-bit type.","pl":"intended_io_mode: io.ModeOverride = io.default_mode","src":31,"more_decls":null}{"pl":"pub const Kind = enum ","src":36,"more_decls":{"pl":"BlockDevice","src":37,"more_decls":null}{"pl":"CharacterDevice","src":38,"more_decls":null}{"pl":"Directory","src":39,"more_decls":null}{"pl":"NamedPipe","src":40,"more_decls":null}{"pl":"SymLink","src":41,"more_decls":null}{"pl":"File","src":42,"more_decls":null}{"pl":"UnixDomainSocket","src":43,"more_decls":null}{"pl":"Whiteout","src":44,"more_decls":null}{"pl":"Unknown","src":45,"more_decls":null}}{"pl":"pub const Lock = enum ","src":69,"more_decls":{"pl":"None","src":69,"more_decls":null}{"pl":"Shared","src":69,"more_decls":null}{"pl":"Exclusive ","src":69,"more_decls":null}}{"doc_comment":"TODO https://github.com/ziglang/zig/issues/3802","pl":"pub const OpenFlags = struct ","src":72,"more_decls":{"pl":"read: bool = true","src":73,"more_decls":null}{"pl":"write: bool = false","src":74,"more_decls":null}{"doc_comment":"Open the file with a lock to prevent other processes from accessing it at the\nsame time. An exclusive lock will prevent other processes from acquiring a lock.\nA shared lock will prevent other processes from acquiring a exclusive lock, but\ndoesn't prevent other process from getting their own shared locks.\n\nNote that the lock is only advisory on Linux, except in very specific cirsumstances[1].\nThis means that a process that does not respect the locking API can still get access\nto the file, despite the lock.\n\nWindows' file locks are mandatory, and any process attempting to access the file will\nreceive an error.\n\n[1]: https://www.kernel.org/doc/Documentation/filesystems/mandatory-locking.txt","pl":"lock: Lock = .None","src":89,"more_decls":null}{"doc_comment":"Sets whether or not to wait until the file is locked to return. If set to true,\n`error.WouldBlock` will be returned. Otherwise, the file will wait until the file\nis available to proceed.\nIn async I/O mode, non-blocking at the OS level is\ndetermined by `intended_io_mode`, and `true` means `error.WouldBlock` is returned,\nand `false` means `error.WouldBlock` is handled by the event loop.","pl":"lock_nonblocking: bool = false","src":97,"more_decls":null}{"doc_comment":"Setting this to `.blocking` prevents `O_NONBLOCK` from being passed even\nif `std.io.is_async`. It allows the use of `nosuspend` when calling functions\nrelated to opening the file, reading, writing, and locking.","pl":"intended_io_mode: io.ModeOverride = io.default_mode","src":102,"more_decls":null}{"doc_comment":"Set this to allow the opened file to automatically become the\ncontrolling TTY for the current process.","pl":"allow_ctty: bool = false","src":106,"more_decls":null}}{"doc_comment":"TODO https://github.com/ziglang/zig/issues/3802","pl":"pub const CreateFlags = struct ","src":110,"more_decls":{"doc_comment":"Whether the file will be created with read access.","pl":"read: bool = false","src":112,"more_decls":null}{"doc_comment":"If the file already exists, and is a regular file, and the access\nmode allows writing, it will be truncated to length 0.","pl":"truncate: bool = true","src":116,"more_decls":null}{"doc_comment":"Ensures that this open call creates the file, otherwise causes\n`error.PathAlreadyExists` to be returned.","pl":"exclusive: bool = false","src":120,"more_decls":null}{"doc_comment":"Open the file with a lock to prevent other processes from accessing it at the\nsame time. An exclusive lock will prevent other processes from acquiring a lock.\nA shared lock will prevent other processes from acquiring a exclusive lock, but\ndoesn't prevent other process from getting their own shared locks.\n\nNote that the lock is only advisory on Linux, except in very specific cirsumstances[1].\nThis means that a process that does not respect the locking API can still get access\nto the file, despite the lock.\n\nWindows's file locks are mandatory, and any process attempting to access the file will\nreceive an error.\n\n[1]: https://www.kernel.org/doc/Documentation/filesystems/mandatory-locking.txt","pl":"lock: Lock = .None","src":135,"more_decls":null}{"doc_comment":"Sets whether or not to wait until the file is locked to return. If set to true,\n`error.WouldBlock` will be returned. Otherwise, the file will wait until the file\nis available to proceed.\nIn async I/O mode, non-blocking at the OS level is\ndetermined by `intended_io_mode`, and `true` means `error.WouldBlock` is returned,\nand `false` means `error.WouldBlock` is handled by the event loop.","pl":"lock_nonblocking: bool = false","src":143,"more_decls":null}{"doc_comment":"For POSIX systems this is the file system mode the file will\nbe created with.","pl":"mode: Mode = default_mode","src":147,"more_decls":null}{"doc_comment":"Setting this to `.blocking` prevents `O_NONBLOCK` from being passed even\nif `std.io.is_async`. It allows the use of `nosuspend` when calling functions\nrelated to opening the file, reading, writing, and locking.","pl":"intended_io_mode: io.ModeOverride = io.default_mode","src":152,"more_decls":null}}{"pl":"pub const Stat = struct ","src":250,"more_decls":{"doc_comment":"A number that the system uses to point to the file metadata. This number is not guaranteed to be\nunique across time, as some file systems may reuse an inode after its file has been deleted.\nSome systems may change the inode of a file over time.\n\nOn Linux, the inode is a structure that stores the metadata, and the inode _number_ is what\nyou see here: the index number of the inode.\n\nThe FileIndex on Windows is similar. It is a number for a file that is unique to each filesystem.","pl":"inode: INode","src":259,"more_decls":null}{"pl":"size: u64","src":260,"more_decls":null}{"pl":"mode: Mode","src":261,"more_decls":null}{"pl":"kind: Kind","src":262,"more_decls":null}{"doc_comment":"Access time in nanoseconds, relative to UTC 1970-01-01.","pl":"atime: i128","src":265,"more_decls":null}{"doc_comment":"Last modification time in nanoseconds, relative to UTC 1970-01-01.","pl":"mtime: i128","src":267,"more_decls":null}{"doc_comment":"Creation time in nanoseconds, relative to UTC 1970-01-01.","pl":"ctime: i128","src":269,"more_decls":null}}{"pl":"pub const WriteFileOptions = struct ","src":686,"more_decls":{"pl":"in_offset: u64 = 0","src":687,"more_decls":null}{"doc_comment":"`null` means the entire file. `0` means no bytes from the file.\nWhen this is `null`, trailers must be sent in a separate writev() call\ndue to a flaw in the BSD sendfile API. Other operating systems, such as\nLinux, already do this anyway due to API limitations.\nIf the size of the source file is known, passing the size here will save one syscall.","pl":"in_len: ?u64 = null","src":694,"more_decls":null}{"pl":"headers_and_trailers: []os.iovec_const = &[0]os.iovec_const{}","src":696,"more_decls":null}{"doc_comment":"The trailer count is inferred from `headers_and_trailers.len - header_count`","pl":"header_count: usize = 0","src":699,"more_decls":null}}{"doc_comment":"Upon success, the stream is in an uninitialized state. To continue using it,\nyou must use the open() function.","pl":"fn close(self: File) void","src":157,"more_decls":null}{"doc_comment":"Test whether the file refers to a terminal.\nSee also `supportsAnsiEscapeCodes`.","pl":"pub fn isTty(self: File) bool {\n    return os.isatty(self.handle);\n}","src":169,"more_decls":null}{"doc_comment":"Test whether ANSI escape codes will be treated as such.","pl":"fn supportsAnsiEscapeCodes(self: File) bool","src":174,"more_decls":null}{"doc_comment":"Shrinks or expands the file.\nThe file offset after this call is left unchanged.","pl":"pub fn setEndPos(self: File, length: u64) SetEndPosError!void {\n    try os.ftruncate(self.handle, length);\n}","src":201,"more_decls":null}{"doc_comment":"Repositions read/write file offset relative to the current offset.\nTODO: integrate with async I/O","pl":"pub fn seekBy(self: File, offset: i64) SeekError!void {\n    return os.lseek_CUR(self.handle, offset);\n}","src":209,"more_decls":null}{"doc_comment":"Repositions read/write file offset relative to the end.\nTODO: integrate with async I/O","pl":"pub fn seekFromEnd(self: File, offset: i64) SeekError!void {\n    return os.lseek_END(self.handle, offset);\n}","src":215,"more_decls":null}{"doc_comment":"Repositions read/write file offset relative to the beginning.\nTODO: integrate with async I/O","pl":"pub fn seekTo(self: File, offset: u64) SeekError!void {\n    return os.lseek_SET(self.handle, offset);\n}","src":221,"more_decls":null}{"doc_comment":"TODO: integrate with async I/O","pl":"pub fn getPos(self: File) GetPosError!u64 {\n    return os.lseek_CUR_get(self.handle);\n}","src":228,"more_decls":null}{"doc_comment":"TODO: integrate with async I/O","pl":"pub fn getEndPos(self: File) GetPosError!u64 {\n    if (builtin.os.tag == .windows) {\n        return windows.GetFileSizeEx(self.handle);\n    }\n    return (try self.stat()).size;\n}","src":233,"more_decls":null}{"doc_comment":"TODO: integrate with async I/O","pl":"pub fn mode(self: File) ModeError!Mode {\n    if (builtin.os.tag == .windows) {\n        return 0;\n    }\n    return (try self.stat()).mode;\n}","src":243,"more_decls":null}{"doc_comment":"TODO: integrate with async I/O","pl":"fn stat(self: File) StatError!Stat","src":275,"more_decls":null}{"doc_comment":"The underlying file system may have a different granularity than nanoseconds,\nand therefore this function cannot guarantee any precision will be stored.\nFurther, the maximum value is limited by the system ABI. When a value is provided\nthat exceeds this range, the value is clamped to the maximum.\nTODO: integrate with async I/O","pl":"fn updateTimes(\n    self: File,\n    /// access timestamp in nanoseconds\n    atime: i128,\n    /// last modification timestamp in nanoseconds\n    mtime: i128,\n) UpdateTimesError!void","src":340,"more_decls":null}{"doc_comment":"Reads all the bytes from the current position to the end of the file.\nOn success, caller owns returned buffer.\nIf the file is larger than `max_bytes`, returns `error.FileTooBig`.","pl":"pub fn readToEndAlloc(self: File, allocator: *mem.Allocator, max_bytes: usize) ![]u8 {\n    return self.readToEndAllocOptions(allocator, max_bytes, null, @alignOf(u8), null);\n}","src":368,"more_decls":null}{"doc_comment":"Reads all the bytes from the current position to the end of the file.\nOn success, caller owns returned buffer.\nIf the file is larger than `max_bytes`, returns `error.FileTooBig`.\nIf `size_hint` is specified the initial buffer size is calculated using\nthat value, otherwise an arbitrary value is used instead.\nAllows specifying alignment and a sentinel value.","pl":"fn readToEndAllocOptions(\n    self: File,\n    allocator: *mem.Allocator,\n    max_bytes: usize,\n    size_hint: ?usize,\n    comptime alignment: u29,\n    comptime optional_sentinel: ?u8,\n) !(if (optional_sentinel) |s| [:s]align(alignment) u8 else []align(alignment) u8)","src":378,"more_decls":null}{"pl":"fn read(self: File, buffer: []u8) ReadError!usize","src":413,"more_decls":null}{"doc_comment":"Returns the number of bytes read. If the number read is smaller than `buffer.len`, it\nmeans the file reached the end. Reaching the end of a file is not an error condition.","pl":"fn readAll(self: File, buffer: []u8) ReadError!usize","src":427,"more_decls":null}{"pl":"fn pread(self: File, buffer: []u8, offset: u64) PReadError!usize","src":437,"more_decls":null}{"doc_comment":"Returns the number of bytes read. If the number read is smaller than `buffer.len`, it\nmeans the file reached the end. Reaching the end of a file is not an error condition.","pl":"fn preadAll(self: File, buffer: []u8, offset: u64) PReadError!usize","src":451,"more_decls":null}{"doc_comment":"See https://github.com/ziglang/zig/issues/7699","pl":"fn readv(self: File, iovecs: []const os.iovec) ReadError!usize","src":462,"more_decls":null}{"doc_comment":"Returns the number of bytes read. If the number read is smaller than the total bytes\nfrom all the buffers, it means the file reached the end. Reaching the end of a file\nis not an error condition.\nThe `iovecs` parameter is mutable because this function needs to mutate the fields in\norder to handle partial reads from the underlying OS layer.\nSee https://github.com/ziglang/zig/issues/7699","pl":"fn readvAll(self: File, iovecs: []os.iovec) ReadError!usize","src":483,"more_decls":null}{"doc_comment":"See https://github.com/ziglang/zig/issues/7699","pl":"fn preadv(self: File, iovecs: []const os.iovec, offset: u64) PReadError!usize","src":505,"more_decls":null}{"doc_comment":"Returns the number of bytes read. If the number read is smaller than the total bytes\nfrom all the buffers, it means the file reached the end. Reaching the end of a file\nis not an error condition.\nThe `iovecs` parameter is mutable because this function needs to mutate the fields in\norder to handle partial reads from the underlying OS layer.\nSee https://github.com/ziglang/zig/issues/7699","pl":"fn preadvAll(self: File, iovecs: []const os.iovec, offset: u64) PReadError!void","src":526,"more_decls":null}{"pl":"fn write(self: File, bytes: []const u8) WriteError!usize","src":550,"more_decls":null}{"pl":"pub fn writeAll(self: File, bytes: []const u8) WriteError!void {\n    var index: usize = 0;\n    while (index < bytes.len) {\n        index += try self.write(bytes[index..]);\n    }\n}","src":562,"more_decls":null}{"pl":"fn pwrite(self: File, bytes: []const u8, offset: u64) PWriteError!usize","src":569,"more_decls":null}{"pl":"pub fn pwriteAll(self: File, bytes: []const u8, offset: u64) PWriteError!void {\n    var index: usize = 0;\n    while (index < bytes.len) {\n        index += try self.pwrite(bytes[index..], offset + index);\n    }\n}","src":581,"more_decls":null}{"doc_comment":"See https://github.com/ziglang/zig/issues/7699\nSee equivalent function: `std.net.Stream.writev`.","pl":"fn writev(self: File, iovecs: []const os.iovec_const) WriteError!usize","src":590,"more_decls":null}{"doc_comment":"The `iovecs` parameter is mutable because this function needs to mutate the fields in\norder to handle partial writes from the underlying OS layer.\nSee https://github.com/ziglang/zig/issues/7699\nSee equivalent function: `std.net.Stream.writevAll`.","pl":"fn writevAll(self: File, iovecs: []os.iovec_const) WriteError!void","src":609,"more_decls":null}{"doc_comment":"See https://github.com/ziglang/zig/issues/7699","pl":"fn pwritev(self: File, iovecs: []os.iovec_const, offset: u64) PWriteError!usize","src":626,"more_decls":null}{"doc_comment":"The `iovecs` parameter is mutable because this function needs to mutate the fields in\norder to handle partial writes from the underlying OS layer.\nSee https://github.com/ziglang/zig/issues/7699","pl":"fn pwritevAll(self: File, iovecs: []os.iovec_const, offset: u64) PWriteError!void","src":644,"more_decls":null}{"pl":"pub fn copyRange(in: File, in_offset: u64, out: File, out_offset: u64, len: u64) CopyRangeError!u64 {\n    const adjusted_len = math.cast(usize, len) catch math.maxInt(usize);\n    const result = try os.copy_file_range(in.handle, in_offset, out.handle, out_offset, adjusted_len, 0);\n    return result;\n}","src":664,"more_decls":null}{"doc_comment":"Returns the number of bytes copied. If the number read is smaller than `buffer.len`, it\nmeans the in file reached the end. Reaching the end of a file is not an error condition.","pl":"fn copyRangeAll(in: File, in_offset: u64, out: File, out_offset: u64, len: u64) CopyRangeError!u64","src":672,"more_decls":null}{"pl":"fn writeFileAll(self: File, in_file: File, args: WriteFileOptions) WriteFileError!void","src":704,"more_decls":null}{"doc_comment":"Does not try seeking in either of the File parameters.\nSee `writeFileAll` as an alternative to calling this.","pl":"fn writeFileAllUnseekable(self: File, in_file: File, args: WriteFileOptions) WriteFileError!void","src":720,"more_decls":null}{"pl":"pub fn reader(file: File) Reader {\n    return .{ .context = file };\n}","src":808,"more_decls":null}{"pl":"pub fn writer(file: File) Writer {\n    return .{ .context = file };\n}","src":814,"more_decls":null}{"pl":"pub fn seekableStream(file: File) SeekableStream {\n    return .{ .context = file };\n}","src":828,"more_decls":null}{"pl":"const Mode = os.mode_t","src":33,"more_decls":null}{"pl":"const INode = os.ino_t","src":34,"more_decls":null}{"pl":"const default_mode = switch (builtin.os.tag) {\n        .windows => 0,\n        .wasi => 0,\n        else => 0o666,\n    }","src":48,"more_decls":null}{"pl":"const OpenError = error{\n        SharingViolation,\n        PathAlreadyExists,\n        FileNotFound,\n        AccessDenied,\n        PipeBusy,\n        NameTooLong,\n        /// On Windows, file paths must be valid Unicode.\n        InvalidUtf8,\n        /// On Windows, file paths cannot contain these characters:\n        /// '/', '*', '?', '\"', '<', '>', '|'\n        BadPathName,\n        Unexpected,\n    } || os.OpenError || os.FlockError","src":54,"more_decls":null}{"pl":"const SetEndPosError = os.TruncateError","src":197,"more_decls":null}{"pl":"const SeekError = os.SeekError","src":205,"more_decls":null}{"pl":"const GetPosError = os.SeekError || os.FStatError","src":225,"more_decls":null}{"pl":"const ModeError = os.FStatError","src":240,"more_decls":null}{"pl":"const StatError = os.FStatError","src":272,"more_decls":null}{"pl":"const UpdateTimesError = os.FutimensError || windows.SetFileTimeError","src":333,"more_decls":null}{"pl":"const ReadError = os.ReadError","src":410,"more_decls":null}{"pl":"const PReadError = os.PReadError","src":411,"more_decls":null}{"pl":"const WriteError = os.WriteError","src":547,"more_decls":null}{"pl":"const PWriteError = os.PWriteError","src":548,"more_decls":null}{"pl":"const CopyRangeError = os.CopyFileRangeError","src":662,"more_decls":null}{"pl":"const WriteFileError = ReadError || error{EndOfStream} || WriteError","src":702,"more_decls":null}{"pl":"const Reader = io.Reader(File, ReadError, read)","src":806,"more_decls":null}{"pl":"const Writer = io.Writer(File, WriteError, write)","src":812,"more_decls":null}{"pl":"const SeekableStream = io.SeekableStream(\n        File,\n        SeekError,\n        GetPosError,\n        seekTo,\n        seekBy,\n        getPos,\n        getEndPos,\n    )","src":818,"more_decls":null}}]