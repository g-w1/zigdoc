[{"pl":"pub const Random = struct ","src":36,"more_decls":{"pl":"fillFn: fn (r: *Random, buf: []u8) void","src":37,"more_decls":null}{"doc_comment":"Read random bytes into the specified buffer until full.","pl":"pub fn bytes(r: *Random, buf: []u8) void {\n    r.fillFn(r, buf);\n}","src":40,"more_decls":null}{"pl":"pub fn boolean(r: *Random) bool {\n    return r.int(u1) != 0;\n}","src":44,"more_decls":null}{"doc_comment":"Returns a random int `i` such that `0 <= i <= maxInt(T)`.\n`i` is evenly distributed.","pl":"fn int(r: *Random, comptime T: type) T","src":50,"more_decls":null}{"doc_comment":"Constant-time implementation off `uintLessThan`.\nThe results of this function may be biased.","pl":"fn uintLessThanBiased(r: *Random, comptime T: type, less_than: T) T","src":68,"more_decls":null}{"doc_comment":"Returns an evenly distributed random unsigned integer `0 <= i < less_than`.\nThis function assumes that the underlying `fillFn` produces evenly distributed values.\nWithin this assumption, the runtime of this function is exponentially distributed.\nIf `fillFn` were backed by a true random generator,\nthe runtime of this function would technically be unbounded.\nHowever, if `fillFn` is backed by any evenly distributed pseudo random number generator,\nthis function is guaranteed to return.\nIf you need deterministic runtime bounds, use `uintLessThanBiased`.","pl":"fn uintLessThan(r: *Random, comptime T: type, less_than: T) T","src":88,"more_decls":null}{"doc_comment":"Constant-time implementation off `uintAtMost`.\nThe results of this function may be biased.","pl":"fn uintAtMostBiased(r: *Random, comptime T: type, at_most: T) T","src":128,"more_decls":null}{"doc_comment":"Returns an evenly distributed random unsigned integer `0 <= i <= at_most`.\nSee `uintLessThan`, which this function uses in most cases,\nfor commentary on the runtime of this function.","pl":"fn uintAtMost(r: *Random, comptime T: type, at_most: T) T","src":140,"more_decls":null}{"doc_comment":"Constant-time implementation off `intRangeLessThan`.\nThe results of this function may be biased.","pl":"fn intRangeLessThanBiased(r: *Random, comptime T: type, at_least: T, less_than: T) T","src":151,"more_decls":null}{"doc_comment":"Returns an evenly distributed random integer `at_least <= i < less_than`.\nSee `uintLessThan`, which this function uses in most cases,\nfor commentary on the runtime of this function.","pl":"fn intRangeLessThan(r: *Random, comptime T: type, at_least: T, less_than: T) T","src":170,"more_decls":null}{"doc_comment":"Constant-time implementation off `intRangeAtMostBiased`.\nThe results of this function may be biased.","pl":"fn intRangeAtMostBiased(r: *Random, comptime T: type, at_least: T, at_most: T) T","src":188,"more_decls":null}{"doc_comment":"Returns an evenly distributed random integer `at_least <= i <= at_most`.\nSee `uintLessThan`, which this function uses in most cases,\nfor commentary on the runtime of this function.","pl":"fn intRangeAtMost(r: *Random, comptime T: type, at_least: T, at_most: T) T","src":207,"more_decls":null}{"doc_comment":"Return a floating point value evenly distributed in the range [0, 1).","pl":"fn float(r: *Random, comptime T: type) T","src":228,"more_decls":null}{"doc_comment":"Return a floating point value normally distributed with mean = 0, stddev = 1.\n\nTo use different parameters, use: floatNorm(...) * desiredStddev + desiredMean.","pl":"fn floatNorm(r: *Random, comptime T: type) T","src":249,"more_decls":null}{"doc_comment":"Return an exponentially distributed float with a rate parameter of 1.\n\nTo use a different rate parameter, use: floatExp(...) / desiredRate.","pl":"fn floatExp(r: *Random, comptime T: type) T","src":261,"more_decls":null}{"doc_comment":"Shuffle a slice into a random order.","pl":"fn shuffle(r: *Random, comptime T: type, buf: []T) void","src":271,"more_decls":null}{"pl":"const scalar = @compileError(\"deprecated; use boolean() or int() instead\")","src":223,"more_decls":null}{"pl":"const range = @compileError(\"deprecated; use intRangeLessThan()\")","src":225,"more_decls":null}}{"pl":"pub const SplitMix64 = struct ","src":491,"more_decls":{"pl":"s: u64","src":492,"more_decls":null}{"pl":"pub fn init(seed: u64) SplitMix64 {\n    return SplitMix64{ .s = seed };\n}","src":494,"more_decls":null}{"pl":"fn next(self: *SplitMix64) u64","src":498,"more_decls":null}}{"doc_comment":"Convert a random integer 0 <= random_int <= maxValue(T),\ninto an integer 0 <= result < less_than.\nThis function introduces a minor bias.","pl":"fn limitRangeBiased(comptime T: type, random_int: T, less_than: T) T","src":287,"more_decls":null}{"doc_comment":"Fast unbiased random numbers.","pl":"const DefaultPrng = Xoroshiro128","src":25,"more_decls":null}{"doc_comment":"Cryptographically secure random numbers.","pl":"const DefaultCsprng = Gimli","src":28,"more_decls":null}{"pl":"const Isaac64 = @import(\"rand/Isaac64.zig\")","src":30,"more_decls":null}{"pl":"const Gimli = @import(\"rand/Gimli.zig\")","src":31,"more_decls":null}{"pl":"const Pcg = @import(\"rand/Pcg.zig\")","src":32,"more_decls":null}{"pl":"const Xoroshiro128 = @import(\"rand/Xoroshiro128.zig\")","src":33,"more_decls":null}{"pl":"const Sfc64 = @import(\"rand/Sfc64.zig\")","src":34,"more_decls":null}]