[{"pl":"pub const LinearFifoBufferType = union(enum) ","src":16,"more_decls":{"doc_comment":"The buffer is internal to the fifo; it is of the specified size.","pl":"Static: usize","src":18,"more_decls":null}{"doc_comment":"The buffer is passed as a slice to the initialiser.","pl":"Slice","src":21,"more_decls":null}{"doc_comment":"The buffer is managed dynamically using a `mem.Allocator`.","pl":"Dynamic","src":24,"more_decls":null}}{"pl":"fn LinearFifo(\n    comptime T: type,\n    comptime buffer_type: LinearFifoBufferType,\n) type","sub_container_type":"struct ","src":27,"more_decls":{"pl":"allocator: if (buffer_type == .Dynamic) *Allocator else void","src":40,"more_decls":null}{"pl":"buf: if (buffer_type == .Static) [buffer_type.Static]T else []T","src":41,"more_decls":null}{"pl":"head: usize","src":42,"more_decls":null}{"pl":"count: usize","src":43,"more_decls":null}{"pl":"pub fn deinit(self: Self) void {\n    if (buffer_type == .Dynamic) self.allocator.free(self.buf);\n}","src":87,"more_decls":null}{"pl":"fn realign(self: *Self) void","src":91,"more_decls":null}{"doc_comment":"Reduce allocated capacity to `size`.","pl":"fn shrink(self: *Self, size: usize) void","src":116,"more_decls":null}{"doc_comment":"Ensure that the buffer can fit at least `size` items","pl":"fn ensureCapacity(self: *Self, size: usize) !void","src":127,"more_decls":null}{"doc_comment":"Makes sure at least `size` items are unused","pl":"pub fn ensureUnusedCapacity(self: *Self, size: usize) error{OutOfMemory}!void {\n    if (self.writableLength() >= size) return;\n\n    return try self.ensureCapacity(math.add(usize, self.count, size) catch return error.OutOfMemory);\n}","src":139,"more_decls":null}{"doc_comment":"Returns number of items currently in fifo","pl":"pub fn readableLength(self: Self) usize {\n    return self.count;\n}","src":146,"more_decls":null}{"doc_comment":"Returns a readable slice from `offset`","pl":"pub fn readableSlice(self: SliceSelfArg, offset: usize) []const T {\n    return self.readableSliceMut(offset);\n}","src":165,"more_decls":null}{"doc_comment":"Discard first `count` items in the fifo","pl":"fn discard(self: *Self, count: usize) void","src":170,"more_decls":null}{"doc_comment":"Read the next item from the fifo","pl":"fn readItem(self: *Self) ?T","src":202,"more_decls":null}{"doc_comment":"Read data from the fifo into `dst`, returns number of items copied.","pl":"fn read(self: *Self, dst: []T) usize","src":211,"more_decls":null}{"pl":"pub fn reader(self: *Self) Reader {\n    return .{ .context = self };\n}","src":232,"more_decls":null}{"doc_comment":"Returns number of items available in fifo","pl":"pub fn writableLength(self: Self) usize {\n    return self.buf.len - self.count;\n}","src":237,"more_decls":null}{"doc_comment":"Returns the first section of writable buffer\nNote that this may be of length 0","pl":"fn writableSlice(self: SliceSelfArg, offset: usize) []T","src":243,"more_decls":null}{"doc_comment":"Returns a writable buffer of at least `size` items, allocating memory as needed.\nUse `fifo.update` once you've written data to it.","pl":"fn writableWithSize(self: *Self, size: usize) ![]T","src":256,"more_decls":null}{"doc_comment":"Update the tail location of the buffer (usually follows use of writable/writableWithSize)","pl":"pub fn update(self: *Self, count: usize) void {\n    assert(self.count + count <= self.buf.len);\n    self.count += count;\n}","src":269,"more_decls":null}{"doc_comment":"Appends the data in `src` to the fifo.\nYou must have ensured there is enough space.","pl":"fn writeAssumeCapacity(self: *Self, src: []const T) void","src":276,"more_decls":null}{"doc_comment":"Write a single item to the fifo","pl":"pub fn writeItem(self: *Self, item: T) !void {\n    try self.ensureUnusedCapacity(1);\n    return self.writeItemAssumeCapacity(item);\n}","src":291,"more_decls":null}{"pl":"fn writeItemAssumeCapacity(self: *Self, item: T) void","src":296,"more_decls":null}{"doc_comment":"Appends the data in `src` to the fifo.\nAllocates more memory as necessary","pl":"pub fn write(self: *Self, src: []const T) !void {\n    try self.ensureUnusedCapacity(src.len);\n\n    return self.writeAssumeCapacity(src);\n}","src":309,"more_decls":null}{"pl":"pub fn writer(self: *Self) Writer {\n    return .{ .context = self };\n}","src":322,"more_decls":null}{"doc_comment":"Place data back into the read stream","pl":"fn unget(self: *Self, src: []const T) !void","src":341,"more_decls":null}{"doc_comment":"Returns the item at `offset`.\nAsserts offset is within bounds.","pl":"fn peekItem(self: Self, offset: usize) T","src":358,"more_decls":null}{"doc_comment":"Pump data from a reader into a writer\nstops when reader returns 0 bytes (EOF)\nBuffer size must be set before calling; a buffer length of 0 is invalid.","pl":"fn pump(self: *Self, src_reader: anytype, dest_writer: anytype) !void","src":373,"more_decls":null}{"pl":"const Reader = std.io.Reader(*Self, error{}, readFn)","src":46,"more_decls":null}{"pl":"const Writer = std.io.Writer(*Self, error{OutOfMemory}, appendWrite)","src":47,"more_decls":null}}]