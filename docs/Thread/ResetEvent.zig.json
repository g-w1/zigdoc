[{"pl":"impl: Impl","src":23,"more_decls":null}{"pl":"pub const TimedWaitResult = enum ","src":70,"more_decls":{"pl":"event_set","src":70,"more_decls":null}{"pl":"timed_out ","src":70,"more_decls":null}}{"doc_comment":"Apple has decided to not support POSIX semaphores, so we go with a\ndifferent approach using Grand Central Dispatch. This API is exposed\nby libSystem so it is guaranteed to be available on all Darwin platforms.","pl":"pub const DarwinEvent = struct ","src":86,"more_decls":{"pl":"sem: c.dispatch_semaphore_t = undefined","src":87,"more_decls":null}{"pl":"pub fn init(ev: *DarwinEvent) !void {\n    ev.* = .{\n        .sem = c.dispatch_semaphore_create(0) orelse return error.SystemResources,\n    };\n}","src":89,"more_decls":null}{"pl":"pub fn deinit(ev: *DarwinEvent) void {\n    c.dispatch_release(ev.sem);\n    ev.* = undefined;\n}","src":95,"more_decls":null}{"pl":"pub fn set(ev: *DarwinEvent) void {\n    // Empirically this returns the numerical value of the semaphore.\n    _ = c.dispatch_semaphore_signal(ev.sem);\n}","src":100,"more_decls":null}{"pl":"pub fn wait(ev: *DarwinEvent) void {\n    assert(c.dispatch_semaphore_wait(ev.sem, c.DISPATCH_TIME_FOREVER) == 0);\n}","src":105,"more_decls":null}{"pl":"fn timedWait(ev: *DarwinEvent, timeout_ns: u64) TimedWaitResult","src":109,"more_decls":null}{"pl":"pub fn reset(ev: *DarwinEvent) void {\n    // Keep calling until the semaphore goes back down to 0.\n    while (c.dispatch_semaphore_wait(ev.sem, c.DISPATCH_TIME_NOW) == 0) {}\n}","src":118,"more_decls":null}}{"doc_comment":"POSIX semaphores must be initialized at runtime because they are allowed to\nbe implemented as file descriptors, in which case initialization would require\na syscall to open the fd.","pl":"pub const PosixEvent = struct ","src":127,"more_decls":{"pl":"sem: c.sem_t = undefined","src":128,"more_decls":null}{"pl":"pub fn init(ev: *PosixEvent) !void {\n    switch (c.getErrno(c.sem_init(&ev.sem, 0, 0))) {\n        0 => return,\n        else => return error.SystemResources,\n    }\n}","src":130,"more_decls":null}{"pl":"pub fn deinit(ev: *PosixEvent) void {\n    assert(c.sem_destroy(&ev.sem) == 0);\n    ev.* = undefined;\n}","src":137,"more_decls":null}{"pl":"pub fn set(ev: *PosixEvent) void {\n    assert(c.sem_post(&ev.sem) == 0);\n}","src":142,"more_decls":null}{"pl":"fn wait(ev: *PosixEvent) void","src":146,"more_decls":null}{"pl":"fn timedWait(ev: *PosixEvent, timeout_ns: u64) TimedWaitResult","src":157,"more_decls":null}{"pl":"fn reset(ev: *PosixEvent) void","src":176,"more_decls":null}}{"doc_comment":"After `init`, it is legal to call any other function.","pl":"pub fn init(ev: *ResetEvent) InitError!void {\n    return ev.impl.init();\n}","src":37,"more_decls":null}{"doc_comment":"This function is not thread-safe.\nAfter `deinit`, the only legal function to call is `init`.","pl":"pub fn deinit(ev: *ResetEvent) void {\n    return ev.impl.deinit();\n}","src":43,"more_decls":null}{"doc_comment":"Sets the event if not already set and wakes up all the threads waiting on\nthe event. It is safe to call `set` multiple times before calling `wait`.\nHowever it is illegal to call `set` after `wait` is called until the event\nis `reset`. This function is thread-safe.","pl":"pub fn set(ev: *ResetEvent) void {\n    return ev.impl.set();\n}","src":51,"more_decls":null}{"doc_comment":"Resets the event to its original, unset state.\nThis function is *not* thread-safe. It is equivalent to calling\n`deinit` followed by `init` but without the possibility of failure.","pl":"pub fn reset(ev: *ResetEvent) void {\n    return ev.impl.reset();\n}","src":58,"more_decls":null}{"doc_comment":"Wait for the event to be set by blocking the current thread.\nThread-safe. No spurious wakeups.\nUpon return from `wait`, the only functions available to be called\nin `ResetEvent` are `reset` and `deinit`.","pl":"pub fn wait(ev: *ResetEvent) void {\n    return ev.impl.wait();\n}","src":66,"more_decls":null}{"doc_comment":"Wait for the event to be set by blocking the current thread.\nA timeout in nanoseconds can be provided as a hint for how\nlong the thread should block on the unset event before returning\n`TimedWaitResult.timed_out`.\nThread-safe. No precision of timing is guaranteed.\nUpon return from `wait`, the only functions available to be called\nin `ResetEvent` are `reset` and `deinit`.","pl":"pub fn timedWait(ev: *ResetEvent, timeout_ns: u64) TimedWaitResult {\n    return ev.impl.timedWait(timeout_ns);\n}","src":79,"more_decls":null}{"pl":"const Impl = if (builtin.single_threaded)\n    std.Thread.StaticResetEvent.DebugEvent\nelse if (std.Target.current.isDarwin())\n    DarwinEvent\nelse if (std.Thread.use_pthreads)\n    PosixEvent\nelse\n    std.Thread.StaticResetEvent.AtomicEvent","src":25,"more_decls":null}{"pl":"const InitError = error{SystemResources}","src":34,"more_decls":null}]