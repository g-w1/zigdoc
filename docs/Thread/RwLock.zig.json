[{"doc_comment":"A lock that supports one writer or many readers.\nThis API is for kernel threads, not evented I/O.\nThis API requires being initialized at runtime, and initialization\ncan fail. Once initialized, the core operations cannot fail.","pl":"impl: Impl","src":11,"more_decls":null}{"doc_comment":"Single-threaded applications use this for deadlock checks in\ndebug mode, and no-ops in release modes.","pl":"pub const SingleThreadedRwLock = struct ","src":71,"more_decls":{"pl":"state: enum { unlocked, locked_exclusive, locked_shared }","src":72,"more_decls":null}{"pl":"shared_count: usize","src":73,"more_decls":null}{"pl":"pub fn init(rwl: *SingleThreadedRwLock) void {\n    rwl.* = .{\n        .state = .unlocked,\n        .shared_count = 0,\n    };\n}","src":75,"more_decls":null}{"pl":"pub fn deinit(rwl: *SingleThreadedRwLock) void {\n    assert(rwl.state == .unlocked);\n    assert(rwl.shared_count == 0);\n}","src":82,"more_decls":null}{"doc_comment":"Attempts to obtain exclusive lock ownership.\nReturns `true` if the lock is obtained, `false` otherwise.","pl":"fn tryLock(rwl: *SingleThreadedRwLock) bool","src":89,"more_decls":null}{"doc_comment":"Blocks until exclusive lock ownership is acquired.","pl":"pub fn lock(rwl: *SingleThreadedRwLock) void {\n    assert(rwl.state == .unlocked); // deadlock detected\n    assert(rwl.shared_count == 0); // corrupted state detected\n    rwl.state = .locked_exclusive;\n}","src":101,"more_decls":null}{"doc_comment":"Releases a held exclusive lock.\nAsserts the lock is held exclusively.","pl":"pub fn unlock(rwl: *SingleThreadedRwLock) void {\n    assert(rwl.state == .locked_exclusive);\n    assert(rwl.shared_count == 0); // corrupted state detected\n    rwl.state = .unlocked;\n}","src":109,"more_decls":null}{"doc_comment":"Attempts to obtain shared lock ownership.\nReturns `true` if the lock is obtained, `false` otherwise.","pl":"fn tryLockShared(rwl: *SingleThreadedRwLock) bool","src":117,"more_decls":null}{"doc_comment":"Blocks until shared lock ownership is acquired.","pl":"fn lockShared(rwl: *SingleThreadedRwLock) void","src":130,"more_decls":null}{"doc_comment":"Releases a held shared lock.","pl":"fn unlockShared(rwl: *SingleThreadedRwLock) void","src":145,"more_decls":null}}{"pl":"pub const PthreadRwLock = struct ","src":159,"more_decls":{"pl":"rwlock: pthread_rwlock_t","src":160,"more_decls":null}{"pl":"pub fn init(rwl: *PthreadRwLock) void {\n    rwl.* = .{ .rwlock = .{} };\n}","src":162,"more_decls":null}{"pl":"fn deinit(rwl: *PthreadRwLock) void","src":166,"more_decls":null}{"pl":"pub fn tryLock(rwl: *PthreadRwLock) bool {\n    return pthread_rwlock_trywrlock(&rwl.rwlock) == 0;\n}","src":178,"more_decls":null}{"pl":"pub fn lock(rwl: *PthreadRwLock) void {\n    const rc = pthread_rwlock_wrlock(&rwl.rwlock);\n    assert(rc == 0);\n}","src":182,"more_decls":null}{"pl":"pub fn unlock(rwl: *PthreadRwLock) void {\n    const rc = pthread_rwlock_unlock(&rwl.rwlock);\n    assert(rc == 0);\n}","src":187,"more_decls":null}{"pl":"pub fn tryLockShared(rwl: *PthreadRwLock) bool {\n    return pthread_rwlock_tryrdlock(&rwl.rwlock) == 0;\n}","src":192,"more_decls":null}{"pl":"pub fn lockShared(rwl: *PthreadRwLock) void {\n    const rc = pthread_rwlock_rdlock(&rwl.rwlock);\n    assert(rc == 0);\n}","src":196,"more_decls":null}{"pl":"pub fn unlockShared(rwl: *PthreadRwLock) void {\n    const rc = pthread_rwlock_unlock(&rwl.rwlock);\n    assert(rc == 0);\n}","src":201,"more_decls":null}}{"pl":"pub const DefaultRwLock = struct ","src":207,"more_decls":{"pl":"state: usize","src":208,"more_decls":null}{"pl":"mutex: Mutex","src":209,"more_decls":null}{"pl":"semaphore: Semaphore","src":210,"more_decls":null}{"pl":"fn init(rwl: *DefaultRwLock) void","src":219,"more_decls":null}{"pl":"pub fn deinit(rwl: *DefaultRwLock) void {\n    rwl.semaphore.deinit();\n    rwl.mutex.deinit();\n    rwl.* = undefined;\n}","src":227,"more_decls":null}{"pl":"fn tryLock(rwl: *DefaultRwLock) bool","src":233,"more_decls":null}{"pl":"fn lock(rwl: *DefaultRwLock) void","src":247,"more_decls":null}{"pl":"pub fn unlock(rwl: *DefaultRwLock) void {\n    _ = @atomicRmw(usize, &rwl.state, .And, ~IS_WRITING, .SeqCst);\n    rwl.mutex.unlock();\n}","src":256,"more_decls":null}{"pl":"fn tryLockShared(rwl: *DefaultRwLock) bool","src":261,"more_decls":null}{"pl":"fn lockShared(rwl: *DefaultRwLock) void","src":283,"more_decls":null}{"pl":"pub fn unlockShared(rwl: *DefaultRwLock) void {\n    const state = @atomicRmw(usize, &rwl.state, .Sub, READER, .SeqCst);\n\n    if ((state & READER_MASK == READER) and (state & IS_WRITING != 0))\n        rwl.semaphore.post();\n}","src":301,"more_decls":null}}{"pl":"pub fn init(rwl: *RwLock) void {\n    return rwl.impl.init();\n}","src":28,"more_decls":null}{"pl":"pub fn deinit(rwl: *RwLock) void {\n    return rwl.impl.deinit();\n}","src":32,"more_decls":null}{"doc_comment":"Attempts to obtain exclusive lock ownership.\nReturns `true` if the lock is obtained, `false` otherwise.","pl":"pub fn tryLock(rwl: *RwLock) bool {\n    return rwl.impl.tryLock();\n}","src":38,"more_decls":null}{"doc_comment":"Blocks until exclusive lock ownership is acquired.","pl":"pub fn lock(rwl: *RwLock) void {\n    return rwl.impl.lock();\n}","src":43,"more_decls":null}{"doc_comment":"Releases a held exclusive lock.\nAsserts the lock is held exclusively.","pl":"pub fn unlock(rwl: *RwLock) void {\n    return rwl.impl.unlock();\n}","src":49,"more_decls":null}{"doc_comment":"Attempts to obtain shared lock ownership.\nReturns `true` if the lock is obtained, `false` otherwise.","pl":"pub fn tryLockShared(rwl: *RwLock) bool {\n    return rwl.impl.tryLockShared();\n}","src":55,"more_decls":null}{"doc_comment":"Blocks until shared lock ownership is acquired.","pl":"pub fn lockShared(rwl: *RwLock) void {\n    return rwl.impl.lockShared();\n}","src":60,"more_decls":null}{"doc_comment":"Releases a held shared lock.","pl":"pub fn unlockShared(rwl: *RwLock) void {\n    return rwl.impl.unlockShared();\n}","src":65,"more_decls":null}{"pl":"const Impl = if (builtin.single_threaded)\n    SingleThreadedRwLock\nelse if (std.Thread.use_pthreads)\n    PthreadRwLock\nelse\n    DefaultRwLock","src":21,"more_decls":null}]