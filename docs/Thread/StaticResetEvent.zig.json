[{"pl":"impl: Impl = .{}","src":24,"more_decls":null}{"doc_comment":"For single-threaded builds, we use this to detect deadlocks.\nIn unsafe modes this ends up being no-ops.","pl":"pub const DebugEvent = struct ","src":69,"more_decls":{"pl":"state: State = State.unset","src":70,"more_decls":null}{"doc_comment":"This function is provided so that this type can be re-used inside\n`std.Thread.ResetEvent`.","pl":"pub fn init(ev: *DebugEvent) void {\n    ev.* = .{};\n}","src":80,"more_decls":null}{"doc_comment":"This function is provided so that this type can be re-used inside\n`std.Thread.ResetEvent`.","pl":"pub fn deinit(ev: *DebugEvent) void {\n    ev.* = undefined;\n}","src":86,"more_decls":null}{"pl":"fn set(ev: *DebugEvent) void","src":90,"more_decls":null}{"pl":"fn wait(ev: *DebugEvent) void","src":98,"more_decls":null}{"pl":"fn timedWait(ev: *DebugEvent, timeout: u64) TimedWaitResult","src":106,"more_decls":null}{"pl":"pub fn reset(ev: *DebugEvent) void {\n    ev.state = .unset;\n}","src":114,"more_decls":null}}{"pl":"pub const AtomicEvent = struct ","src":119,"more_decls":{"pl":"waiters: u32 = 0","src":120,"more_decls":null}{"pl":"pub const SpinFutex = struct ","src":175,"more_decls":}{"pl":"pub const LinuxFutex = struct ","src":193,"more_decls":}{"pl":"pub const WindowsFutex = struct ","src":228,"more_decls":{"pl":"fn wake(waiters: *u32, wake_count: u32) void","src":229,"more_decls":null}{"pl":"fn wait(waiters: *u32, timeout: ?u64) !void","src":240,"more_decls":null}{"pl":"fn getEventHandle() ?windows.HANDLE","src":282,"more_decls":null}}{"doc_comment":"This function is provided so that this type can be re-used inside\n`std.Thread.ResetEvent`.","pl":"pub fn init(ev: *AtomicEvent) void {\n    ev.* = .{};\n}","src":127,"more_decls":null}{"doc_comment":"This function is provided so that this type can be re-used inside\n`std.Thread.ResetEvent`.","pl":"pub fn deinit(ev: *AtomicEvent) void {\n    ev.* = undefined;\n}","src":133,"more_decls":null}{"pl":"pub fn set(ev: *AtomicEvent) void {\n    const waiters = @atomicRmw(u32, &ev.waiters, .Xchg, WAKE, .Release);\n    if (waiters >= WAIT) {\n        return Futex.wake(&ev.waiters, waiters >> 1);\n    }\n}","src":137,"more_decls":null}{"pl":"pub fn wait(ev: *AtomicEvent) void {\n    switch (ev.timedWait(null)) {\n        .timed_out => unreachable,\n        .event_set => return,\n    }\n}","src":144,"more_decls":null}{"pl":"fn timedWait(ev: *AtomicEvent, timeout: ?u64) TimedWaitResult","src":151,"more_decls":null}{"pl":"pub fn reset(ev: *AtomicEvent) void {\n    @atomicStore(u32, &ev.waiters, 0, .Monotonic);\n}","src":165,"more_decls":null}{"pl":"const Futex = switch (std.Target.current.os.tag) {\n        .windows => WindowsFutex,\n        .linux => LinuxFutex,\n        else => SpinFutex,\n    }","src":169,"more_decls":null}}{"doc_comment":"Sets the event if not already set and wakes up all the threads waiting on\nthe event. It is safe to call `set` multiple times before calling `wait`.\nHowever it is illegal to call `set` after `wait` is called until the event\nis `reset`. This function is thread-safe.","pl":"pub fn set(ev: *StaticResetEvent) void {\n    return ev.impl.set();\n}","src":35,"more_decls":null}{"doc_comment":"Wait for the event to be set by blocking the current thread.\nThread-safe. No spurious wakeups.\nUpon return from `wait`, the only function available to be called\nin `StaticResetEvent` is `reset`.","pl":"pub fn wait(ev: *StaticResetEvent) void {\n    return ev.impl.wait();\n}","src":43,"more_decls":null}{"doc_comment":"Resets the event to its original, unset state.\nThis function is *not* thread-safe. It is equivalent to calling\n`deinit` followed by `init` but without the possibility of failure.","pl":"pub fn reset(ev: *StaticResetEvent) void {\n    return ev.impl.reset();\n}","src":50,"more_decls":null}{"doc_comment":"Wait for the event to be set by blocking the current thread.\nA timeout in nanoseconds can be provided as a hint for how\nlong the thread should block on the unset event before returning\n`TimedWaitResult.timed_out`.\nThread-safe. No precision of timing is guaranteed.\nUpon return from `timedWait`, the only function available to be called\nin `StaticResetEvent` is `reset`.","pl":"pub fn timedWait(ev: *StaticResetEvent, timeout_ns: u64) TimedWaitResult {\n    return ev.impl.timedWait(timeout_ns);\n}","src":63,"more_decls":null}{"pl":"const Impl = if (std.builtin.single_threaded)\n    DebugEvent\nelse\n    AtomicEvent","src":26,"more_decls":null}{"pl":"const TimedWaitResult = std.Thread.ResetEvent.TimedWaitResult","src":54,"more_decls":null}]