[{"doc_comment":"Lock may be held only once. If the same thread tries to acquire\nthe same mutex twice, it deadlocks.  This type supports static\ninitialization and is at most `@sizeOf(usize)` in size.  When an\napplication is built in single threaded release mode, all the\nfunctions are no-ops. In single threaded debug mode, there is\ndeadlock detection.\n\nExample usage:\nvar m = Mutex{};\n\nconst lock = m.acquire();\ndefer lock.release();\n... critical code\n\nNon-blocking:\nif (m.tryAcquire) |lock| {\ndefer lock.release();\n// ... critical section\n} else {\n// ... lock not acquired\n}","pl":"impl: Impl = .{}","src":28,"more_decls":null}{"pl":"pub const AtomicMutex = struct ","src":61,"more_decls":{"pl":"state: State = .unlocked","src":62,"more_decls":null}{"pl":"pub const Held = struct ","src":70,"more_decls":{"pl":"mutex: *AtomicMutex","src":71,"more_decls":null}{"pl":"fn release(held: Held) void","src":73,"more_decls":null}}{"pl":"fn tryAcquire(m: *AtomicMutex) ?Held","src":82,"more_decls":null}{"pl":"fn acquire(m: *AtomicMutex) Held","src":97,"more_decls":null}}{"pl":"pub const PthreadMutex = struct ","src":176,"more_decls":{"pl":"pthread_mutex: std.c.pthread_mutex_t = .{}","src":177,"more_decls":null}{"pl":"pub const Held = struct ","src":179,"more_decls":{"pl":"mutex: *PthreadMutex","src":180,"more_decls":null}{"pl":"fn release(held: Held) void","src":182,"more_decls":null}}{"doc_comment":"Try to acquire the mutex without blocking. Returns null if\nthe mutex is unavailable. Otherwise returns Held. Call\nrelease on Held.","pl":"fn tryAcquire(m: *PthreadMutex) ?Held","src":196,"more_decls":null}{"doc_comment":"Acquire the mutex. Will deadlock if the mutex is already\nheld by the calling thread.","pl":"fn acquire(m: *PthreadMutex) Held","src":206,"more_decls":null}}{"doc_comment":"This has the sematics as `Mutex`, however it does not actually do any\nsynchronization. Operations are safety-checked no-ops.","pl":"pub const Dummy = struct ","src":221,"more_decls":{"pl":"lock: @TypeOf(lock_init) = lock_init","src":222,"more_decls":null}{"pl":"pub const Held = struct ","src":226,"more_decls":{"pl":"mutex: *Dummy","src":227,"more_decls":null}{"pl":"pub fn release(held: Held) void {\n    if (std.debug.runtime_safety) {\n        held.mutex.lock = false;\n    }\n}","src":229,"more_decls":null}}{"doc_comment":"Try to acquire the mutex without blocking. Returns null if\nthe mutex is unavailable. Otherwise returns Held. Call\nrelease on Held.","pl":"fn tryAcquire(m: *Dummy) ?Held","src":239,"more_decls":null}{"doc_comment":"Acquire the mutex. Will deadlock if the mutex is already\nheld by the calling thread.","pl":"pub fn acquire(m: *Dummy) Held {\n    return m.tryAcquire() orelse @panic(\"deadlock detected\");\n}","src":249,"more_decls":null}}{"doc_comment":"Try to acquire the mutex without blocking. Returns `null` if the mutex is\nunavailable. Otherwise returns `Held`. Call `release` on `Held`.","pl":"pub fn tryAcquire(m: *Mutex) ?Impl.Held {\n    return m.impl.tryAcquire();\n}","src":42,"more_decls":null}{"doc_comment":"Acquire the mutex. Deadlocks if the mutex is already\nheld by the calling thread.","pl":"pub fn acquire(m: *Mutex) Impl.Held {\n    return m.impl.acquire();\n}","src":48,"more_decls":null}]