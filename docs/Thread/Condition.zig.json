[{"doc_comment":"A condition provides a way for a kernel thread to block until it is signaled\nto wake up. Spurious wakeups are possible.\nThis API supports static initialization and does not require deinitialization.","pl":"impl: Impl = .{}","src":10,"more_decls":null}{"pl":"pub const SingleThreadedCondition = struct ","src":40,"more_decls":{"pl":"pub fn wait(cond: *SingleThreadedCondition, mutex: *Mutex) void {\n    unreachable; // deadlock detected\n}","src":41,"more_decls":null}{"pl":"pub fn signal(cond: *SingleThreadedCondition) void {}","src":45,"more_decls":null}{"pl":"pub fn broadcast(cond: *SingleThreadedCondition) void {}","src":47,"more_decls":null}}{"pl":"pub const WindowsCondition = struct ","src":50,"more_decls":{"pl":"cond: windows.CONDITION_VARIABLE = windows.CONDITION_VARIABLE_INIT","src":51,"more_decls":null}{"pl":"fn wait(cond: *WindowsCondition, mutex: *Mutex) void","src":53,"more_decls":null}{"pl":"pub fn signal(cond: *WindowsCondition) void {\n    windows.kernel32.WakeConditionVariable(&cond.cond);\n}","src":63,"more_decls":null}{"pl":"pub fn broadcast(cond: *WindowsCondition) void {\n    windows.kernel32.WakeAllConditionVariable(&cond.cond);\n}","src":67,"more_decls":null}}{"pl":"pub const PthreadCondition = struct ","src":72,"more_decls":{"pl":"cond: std.c.pthread_cond_t = .{}","src":73,"more_decls":null}{"pl":"pub fn wait(cond: *PthreadCondition, mutex: *Mutex) void {\n    const rc = std.c.pthread_cond_wait(&cond.cond, &mutex.impl.pthread_mutex);\n    assert(rc == 0);\n}","src":75,"more_decls":null}{"pl":"pub fn signal(cond: *PthreadCondition) void {\n    const rc = std.c.pthread_cond_signal(&cond.cond);\n    assert(rc == 0);\n}","src":80,"more_decls":null}{"pl":"pub fn broadcast(cond: *PthreadCondition) void {\n    const rc = std.c.pthread_cond_broadcast(&cond.cond);\n    assert(rc == 0);\n}","src":85,"more_decls":null}}{"pl":"pub const AtomicCondition = struct ","src":91,"more_decls":{"pl":"pending: bool = false","src":92,"more_decls":null}{"pl":"queue_mutex: Mutex = .{}","src":93,"more_decls":null}{"pl":"queue_list: QueueList = .{}","src":94,"more_decls":null}{"pl":"pub const QueueItem = struct ","src":98,"more_decls":{"pl":"futex: i32 = 0","src":99,"more_decls":null}}{"pl":"fn wait(cond: *AtomicCondition, mutex: *Mutex) void","src":142,"more_decls":null}{"pl":"fn signal(cond: *AtomicCondition) void","src":158,"more_decls":null}{"pl":"fn broadcast(cond: *AtomicCondition) void","src":175,"more_decls":null}{"pl":"const QueueList = std.SinglyLinkedList(QueueItem)","src":96,"more_decls":null}}{"pl":"pub fn wait(cond: *Condition, mutex: *Mutex) void {\n    cond.impl.wait(mutex);\n}","src":19,"more_decls":null}{"pl":"pub fn signal(cond: *Condition) void {\n    cond.impl.signal();\n}","src":23,"more_decls":null}{"pl":"pub fn broadcast(cond: *Condition) void {\n    cond.impl.broadcast();\n}","src":27,"more_decls":null}]