[{"doc_comment":"Similar to `StaticResetEvent` but on `set()` it also (atomically) does `reset()`.\nUnlike StaticResetEvent, `wait()` can only be called by one thread (MPSC-like).\n\nAutoResetEvent has 3 possible states:\n- UNSET: the AutoResetEvent is currently unset\n- SET: the AutoResetEvent was notified before a wait() was called\n- <StaticResetEvent pointer>: there is an active waiter waiting for a notification.\n\nWhen attempting to wait:\nif the event is unset, it registers a ResetEvent pointer to be notified when the event is set\nif the event is already set, then it consumes the notification and resets the event.\n\nWhen attempting to notify:\nif the event is unset, then we set the event\nif theres a waiting ResetEvent, then we unset the event and notify the ResetEvent\n\nThis ensures that the event is automatically reset after a wait() has been issued\nand avoids the race condition when using StaticResetEvent in the following scenario:\nthread 1                  | thread 2\nStaticResetEvent.wait()   |\n| StaticResetEvent.set()\n| StaticResetEvent.set()\nStaticResetEvent.reset()  |\nStaticResetEvent.wait()   | (missed the second .set() notification above)","pl":"state: usize = UNSET","src":31,"more_decls":null}{"pl":"pub fn wait(self: *AutoResetEvent) void {\n    self.waitFor(null) catch unreachable;\n}","src":46,"more_decls":null}{"pl":"pub fn timedWait(self: *AutoResetEvent, timeout: u64) error{TimedOut}!void {\n    return self.waitFor(timeout);\n}","src":50,"more_decls":null}{"pl":"fn set(self: *AutoResetEvent) void","src":131,"more_decls":null}]