[{"pl":"pub fn AutoArrayHashMap(comptime K: type, comptime V: type) type {\n    return ArrayHashMap(K, V, getAutoHashFn(K), getAutoEqlFn(K), autoEqlIsCheap(K));\n}","src":19,"more_decls":null}{"pl":"pub fn AutoArrayHashMapUnmanaged(comptime K: type, comptime V: type) type {\n    return ArrayHashMapUnmanaged(K, V, getAutoHashFn(K), getAutoEqlFn(K), autoEqlIsCheap(K));\n}","src":23,"more_decls":null}{"doc_comment":"Builtin hashmap for strings as keys.","pl":"pub fn StringArrayHashMap(comptime V: type) type {\n    return ArrayHashMap([]const u8, V, hashString, eqlString, true);\n}","src":28,"more_decls":null}{"pl":"pub fn StringArrayHashMapUnmanaged(comptime V: type) type {\n    return ArrayHashMapUnmanaged([]const u8, V, hashString, eqlString, true);\n}","src":32,"more_decls":null}{"pl":"pub fn eqlString(a: []const u8, b: []const u8) bool {\n    return mem.eql(u8, a, b);\n}","src":36,"more_decls":null}{"pl":"pub fn hashString(s: []const u8) u32 {\n    return @truncate(u32, std.hash.Wyhash.hash(0, s));\n}","src":40,"more_decls":null}{"doc_comment":"Insertion order is preserved.\nDeletions perform a \"swap removal\" on the entries list.\nModifying the hash map while iterating is allowed, however one must understand\nthe (well defined) behavior when mixing insertions and deletions with iteration.\nFor a hash map that can be initialized directly that does not store an Allocator\nfield, see `ArrayHashMapUnmanaged`.\nWhen `store_hash` is `false`, this data structure is biased towards cheap `eql`\nfunctions. It does not store each item's hash in the table. Setting `store_hash`\nto `true` incurs slightly more memory cost by storing each key's hash in the table\nbut only has to call `eql` for hash collisions.\nIf typical operations (except iteration over entries) need to be faster, prefer\nthe alternative `std.HashMap`.","pl":"fn ArrayHashMap(\n    comptime K: type,\n    comptime V: type,\n    comptime hash: fn (key: K) u32,\n    comptime eql: fn (a: K, b: K) bool,\n    comptime store_hash: bool,\n) type","sub_container_type":"struct ","src":56,"more_decls":{"pl":"unmanaged: Unmanaged","src":64,"more_decls":null}{"pl":"allocator: *Allocator","src":65,"more_decls":null}{"doc_comment":"Deprecated. Iterate using `items`.","pl":"pub const Iterator = struct ","src":73,"more_decls":{"pl":"hm: *const Self","src":74,"more_decls":null}{"doc_comment":"Iterator through the entry array.","pl":"index: usize","src":76,"more_decls":null}{"pl":"pub fn next(it: *Iterator) ?*Entry {\n    if (it.index >= it.hm.unmanaged.entries.items.len) return null;\n    const result = &it.hm.unmanaged.entries.items[it.index];\n    it.index += 1;\n    return result;\n}","src":78,"more_decls":null}{"doc_comment":"Reset the iterator to the initial index","pl":"pub fn reset(it: *Iterator) void {\n    it.index = 0;\n}","src":86,"more_decls":null}}{"pl":"pub fn init(allocator: *Allocator) Self {\n    return .{\n        .unmanaged = .{},\n        .allocator = allocator,\n    };\n}","src":94,"more_decls":null}{"doc_comment":"`ArrayHashMap` takes ownership of the passed in array list. The array list must have\nbeen allocated with `allocator`.\nDeinitialize with `deinit`.","pl":"pub fn fromOwnedArrayList(allocator: *Allocator, entries: std.ArrayListUnmanaged(Entry)) !Self {\n    return Self{\n        .unmanaged = try Unmanaged.fromOwnedArrayList(allocator, entries),\n        .allocator = allocator,\n    };\n}","src":104,"more_decls":null}{"pl":"pub fn deinit(self: *Self) void {\n    self.unmanaged.deinit(self.allocator);\n    self.* = undefined;\n}","src":111,"more_decls":null}{"pl":"pub fn clearRetainingCapacity(self: *Self) void {\n    return self.unmanaged.clearRetainingCapacity();\n}","src":116,"more_decls":null}{"pl":"pub fn clearAndFree(self: *Self) void {\n    return self.unmanaged.clearAndFree(self.allocator);\n}","src":120,"more_decls":null}{"pl":"pub fn count(self: Self) usize {\n    return self.unmanaged.count();\n}","src":124,"more_decls":null}{"pl":"pub fn iterator(self: *const Self) Iterator {\n    return Iterator{\n        .hm = self,\n        .index = 0,\n    };\n}","src":128,"more_decls":null}{"doc_comment":"If key exists this function cannot fail.\nIf there is an existing item with `key`, then the result\n`Entry` pointer points to it, and found_existing is true.\nOtherwise, puts a new item with undefined value, and\nthe `Entry` pointer points to it. Caller should then initialize\nthe value (but not the key).","pl":"pub fn getOrPut(self: *Self, key: K) !GetOrPutResult {\n    return self.unmanaged.getOrPut(self.allocator, key);\n}","src":141,"more_decls":null}{"doc_comment":"If there is an existing item with `key`, then the result\n`Entry` pointer points to it, and found_existing is true.\nOtherwise, puts a new item with undefined value, and\nthe `Entry` pointer points to it. Caller should then initialize\nthe value (but not the key).\nIf a new entry needs to be stored, this function asserts there\nis enough capacity to store it.","pl":"pub fn getOrPutAssumeCapacity(self: *Self, key: K) GetOrPutResult {\n    return self.unmanaged.getOrPutAssumeCapacity(key);\n}","src":152,"more_decls":null}{"pl":"pub fn getOrPutValue(self: *Self, key: K, value: V) !*Entry {\n    return self.unmanaged.getOrPutValue(self.allocator, key, value);\n}","src":156,"more_decls":null}{"doc_comment":"Increases capacity, guaranteeing that insertions up until the\n`expected_count` will not cause an allocation, and therefore cannot fail.","pl":"pub fn ensureCapacity(self: *Self, new_capacity: usize) !void {\n    return self.unmanaged.ensureCapacity(self.allocator, new_capacity);\n}","src":162,"more_decls":null}{"doc_comment":"Returns the number of total elements which may be present before it is\nno longer guaranteed that no allocations will be performed.","pl":"pub fn capacity(self: *Self) usize {\n    return self.unmanaged.capacity();\n}","src":168,"more_decls":null}{"doc_comment":"Clobbers any existing data. To detect if a put would clobber\nexisting data, see `getOrPut`.","pl":"pub fn put(self: *Self, key: K, value: V) !void {\n    return self.unmanaged.put(self.allocator, key, value);\n}","src":174,"more_decls":null}{"doc_comment":"Inserts a key-value pair into the hash map, asserting that no previous\nentry with the same key is already present","pl":"pub fn putNoClobber(self: *Self, key: K, value: V) !void {\n    return self.unmanaged.putNoClobber(self.allocator, key, value);\n}","src":180,"more_decls":null}{"doc_comment":"Asserts there is enough capacity to store the new key-value pair.\nClobbers any existing data. To detect if a put would clobber\nexisting data, see `getOrPutAssumeCapacity`.","pl":"pub fn putAssumeCapacity(self: *Self, key: K, value: V) void {\n    return self.unmanaged.putAssumeCapacity(key, value);\n}","src":187,"more_decls":null}{"doc_comment":"Asserts there is enough capacity to store the new key-value pair.\nAsserts that it does not clobber any existing data.\nTo detect if a put would clobber existing data, see `getOrPutAssumeCapacity`.","pl":"pub fn putAssumeCapacityNoClobber(self: *Self, key: K, value: V) void {\n    return self.unmanaged.putAssumeCapacityNoClobber(key, value);\n}","src":194,"more_decls":null}{"doc_comment":"Inserts a new `Entry` into the hash map, returning the previous one, if any.","pl":"pub fn fetchPut(self: *Self, key: K, value: V) !?Entry {\n    return self.unmanaged.fetchPut(self.allocator, key, value);\n}","src":199,"more_decls":null}{"doc_comment":"Inserts a new `Entry` into the hash map, returning the previous one, if any.\nIf insertion happuns, asserts there is enough capacity without allocating.","pl":"pub fn fetchPutAssumeCapacity(self: *Self, key: K, value: V) ?Entry {\n    return self.unmanaged.fetchPutAssumeCapacity(key, value);\n}","src":205,"more_decls":null}{"pl":"pub fn getEntry(self: Self, key: K) ?*Entry {\n    return self.unmanaged.getEntry(key);\n}","src":209,"more_decls":null}{"pl":"pub fn getIndex(self: Self, key: K) ?usize {\n    return self.unmanaged.getIndex(key);\n}","src":213,"more_decls":null}{"pl":"pub fn get(self: Self, key: K) ?V {\n    return self.unmanaged.get(key);\n}","src":217,"more_decls":null}{"pl":"pub fn contains(self: Self, key: K) bool {\n    return self.unmanaged.contains(key);\n}","src":221,"more_decls":null}{"doc_comment":"If there is an `Entry` with a matching key, it is deleted from\nthe hash map, and then returned from this function. The entry is\nremoved from the underlying array by swapping it with the last\nelement.","pl":"pub fn swapRemove(self: *Self, key: K) ?Entry {\n    return self.unmanaged.swapRemove(key);\n}","src":229,"more_decls":null}{"doc_comment":"If there is an `Entry` with a matching key, it is deleted from\nthe hash map, and then returned from this function. The entry is\nremoved from the underlying array by shifting all elements forward\nthereby maintaining the current ordering.","pl":"pub fn orderedRemove(self: *Self, key: K) ?Entry {\n    return self.unmanaged.orderedRemove(key);\n}","src":237,"more_decls":null}{"doc_comment":"TODO: deprecated: call swapRemoveAssertDiscard instead.","pl":"pub fn removeAssertDiscard(self: *Self, key: K) void {\n    return self.unmanaged.removeAssertDiscard(key);\n}","src":242,"more_decls":null}{"doc_comment":"Asserts there is an `Entry` with matching key, deletes it from the hash map\nby swapping it with the last element, and discards it.","pl":"pub fn swapRemoveAssertDiscard(self: *Self, key: K) void {\n    return self.unmanaged.swapRemoveAssertDiscard(key);\n}","src":248,"more_decls":null}{"doc_comment":"Asserts there is an `Entry` with matching key, deletes it from the hash map\nby by shifting all elements forward thereby maintaining the current ordering.","pl":"pub fn orderedRemoveAssertDiscard(self: *Self, key: K) void {\n    return self.unmanaged.orderedRemoveAssertDiscard(key);\n}","src":254,"more_decls":null}{"pl":"pub fn items(self: Self) []Entry {\n    return self.unmanaged.items();\n}","src":258,"more_decls":null}{"pl":"pub fn clone(self: Self) !Self {\n    var other = try self.unmanaged.clone(self.allocator);\n    return other.promote(self.allocator);\n}","src":262,"more_decls":null}{"doc_comment":"Rebuilds the key indexes. If the underlying entries has been modified directly, users\ncan call `reIndex` to update the indexes to account for these new entries.","pl":"pub fn reIndex(self: *Self) !void {\n    return self.unmanaged.reIndex(self.allocator);\n}","src":269,"more_decls":null}{"doc_comment":"Shrinks the underlying `Entry` array to `new_len` elements and discards any associated\nindex entries. Keeps capacity the same.","pl":"pub fn shrinkRetainingCapacity(self: *Self, new_len: usize) void {\n    return self.unmanaged.shrinkRetainingCapacity(new_len);\n}","src":275,"more_decls":null}{"doc_comment":"Shrinks the underlying `Entry` array to `new_len` elements and discards any associated\nindex entries. Reduces allocated capacity.","pl":"pub fn shrinkAndFree(self: *Self, new_len: usize) void {\n    return self.unmanaged.shrinkAndFree(self.allocator, new_len);\n}","src":281,"more_decls":null}{"doc_comment":"Removes the last inserted `Entry` in the hash map and returns it.","pl":"pub fn pop(self: *Self) Entry {\n    return self.unmanaged.pop();\n}","src":286,"more_decls":null}{"pl":"const Unmanaged = ArrayHashMapUnmanaged(K, V, hash, eql, store_hash)","src":67,"more_decls":null}{"pl":"const Entry = Unmanaged.Entry","src":68,"more_decls":null}{"pl":"const Hash = Unmanaged.Hash","src":69,"more_decls":null}{"pl":"const GetOrPutResult = Unmanaged.GetOrPutResult","src":70,"more_decls":null}}{"doc_comment":"General purpose hash table.\nInsertion order is preserved.\nDeletions perform a \"swap removal\" on the entries list.\nModifying the hash map while iterating is allowed, however one must understand\nthe (well defined) behavior when mixing insertions and deletions with iteration.\nThis type does not store an Allocator field - the Allocator must be passed in\nwith each function call that requires it. See `ArrayHashMap` for a type that stores\nan Allocator field for convenience.\nCan be initialized directly using the default field values.\nThis type is designed to have low overhead for small numbers of entries. When\n`store_hash` is `false` and the number of entries in the map is less than 9,\nthe overhead cost of using `ArrayHashMapUnmanaged` rather than `std.ArrayList` is\nonly a single pointer-sized integer.\nWhen `store_hash` is `false`, this data structure is biased towards cheap `eql`\nfunctions. It does not store each item's hash in the table. Setting `store_hash`\nto `true` incurs slightly more memory cost by storing each key's hash in the table\nbut guarantees only one call to `eql` per insertion/deletion.","pl":"fn ArrayHashMapUnmanaged(\n    comptime K: type,\n    comptime V: type,\n    comptime hash: fn (key: K) u32,\n    comptime eql: fn (a: K, b: K) bool,\n    comptime store_hash: bool,\n) type","sub_container_type":"struct ","src":309,"more_decls":{"doc_comment":"It is permitted to access this field directly.","pl":"entries: std.ArrayListUnmanaged(Entry) = .{}","src":318,"more_decls":null}{"doc_comment":"When entries length is less than `linear_scan_max`, this remains `null`.\nOnce entries length grows big enough, this field is allocated. There is\nan IndexHeader followed by an array of Index(I) structs, where I is defined\nby how many total indexes there are.","pl":"index_header: ?*IndexHeader = null","src":324,"more_decls":null}{"doc_comment":"Modifying the key is illegal behavior.\nModifying the value is allowed.\nEntry pointers become invalid whenever this ArrayHashMap is modified,\nunless `ensureCapacity` was previously used.","pl":"pub const Entry = struct ","src":330,"more_decls":{"doc_comment":"This field is `void` if `store_hash` is `false`.","pl":"hash: Hash","src":332,"more_decls":null}{"pl":"key: K","src":333,"more_decls":null}{"pl":"value: V","src":334,"more_decls":null}}{"pl":"pub const GetOrPutResult = struct ","src":339,"more_decls":{"pl":"entry: *Entry","src":340,"more_decls":null}{"pl":"found_existing: bool","src":341,"more_decls":null}{"pl":"index: usize","src":342,"more_decls":null}}{"pl":"pub fn promote(self: Self, allocator: *Allocator) Managed {\n    return .{\n        .unmanaged = self,\n        .allocator = allocator,\n    };\n}","src":357,"more_decls":null}{"doc_comment":"`ArrayHashMapUnmanaged` takes ownership of the passed in array list. The array list must\nhave been allocated with `allocator`.\nDeinitialize with `deinit`.","pl":"pub fn fromOwnedArrayList(allocator: *Allocator, entries: std.ArrayListUnmanaged(Entry)) !Self {\n    var array_hash_map = Self{ .entries = entries };\n    try array_hash_map.reIndex(allocator);\n    return array_hash_map;\n}","src":367,"more_decls":null}{"pl":"fn deinit(self: *Self, allocator: *Allocator) void","src":373,"more_decls":null}{"pl":"fn clearRetainingCapacity(self: *Self) void","src":381,"more_decls":null}{"pl":"fn clearAndFree(self: *Self, allocator: *Allocator) void","src":394,"more_decls":null}{"pl":"pub fn count(self: Self) usize {\n    return self.entries.items.len;\n}","src":402,"more_decls":null}{"doc_comment":"If key exists this function cannot fail.\nIf there is an existing item with `key`, then the result\n`Entry` pointer points to it, and found_existing is true.\nOtherwise, puts a new item with undefined value, and\nthe `Entry` pointer points to it. Caller should then initialize\nthe value (but not the key).","pl":"fn getOrPut(self: *Self, allocator: *Allocator, key: K) !GetOrPutResult","src":412,"more_decls":null}{"doc_comment":"If there is an existing item with `key`, then the result\n`Entry` pointer points to it, and found_existing is true.\nOtherwise, puts a new item with undefined value, and\nthe `Entry` pointer points to it. Caller should then initialize\nthe value (but not the key).\nIf a new entry needs to be stored, this function asserts there\nis enough capacity to store it.","pl":"fn getOrPutAssumeCapacity(self: *Self, key: K) GetOrPutResult","src":432,"more_decls":null}{"pl":"fn getOrPutValue(self: *Self, allocator: *Allocator, key: K, value: V) !*Entry","src":466,"more_decls":null}{"doc_comment":"Increases capacity, guaranteeing that insertions up until the\n`expected_count` will not cause an allocation, and therefore cannot fail.","pl":"fn ensureCapacity(self: *Self, allocator: *Allocator, new_capacity: usize) !void","src":476,"more_decls":null}{"doc_comment":"Returns the number of total elements which may be present before it is\nno longer guaranteed that no allocations will be performed.","pl":"pub fn capacity(self: Self) usize {\n    const entry_cap = self.entries.capacity;\n    const header = self.index_header orelse return math.min(linear_scan_max, entry_cap);\n    const indexes_cap = (header.indexes_len + 1) * 3 / 4;\n    return math.min(entry_cap, indexes_cap);\n}","src":505,"more_decls":null}{"doc_comment":"Clobbers any existing data. To detect if a put would clobber\nexisting data, see `getOrPut`.","pl":"pub fn put(self: *Self, allocator: *Allocator, key: K, value: V) !void {\n    const result = try self.getOrPut(allocator, key);\n    result.entry.value = value;\n}","src":514,"more_decls":null}{"doc_comment":"Inserts a key-value pair into the hash map, asserting that no previous\nentry with the same key is already present","pl":"pub fn putNoClobber(self: *Self, allocator: *Allocator, key: K, value: V) !void {\n    const result = try self.getOrPut(allocator, key);\n    assert(!result.found_existing);\n    result.entry.value = value;\n}","src":521,"more_decls":null}{"doc_comment":"Asserts there is enough capacity to store the new key-value pair.\nClobbers any existing data. To detect if a put would clobber\nexisting data, see `getOrPutAssumeCapacity`.","pl":"pub fn putAssumeCapacity(self: *Self, key: K, value: V) void {\n    const result = self.getOrPutAssumeCapacity(key);\n    result.entry.value = value;\n}","src":530,"more_decls":null}{"doc_comment":"Asserts there is enough capacity to store the new key-value pair.\nAsserts that it does not clobber any existing data.\nTo detect if a put would clobber existing data, see `getOrPutAssumeCapacity`.","pl":"pub fn putAssumeCapacityNoClobber(self: *Self, key: K, value: V) void {\n    const result = self.getOrPutAssumeCapacity(key);\n    assert(!result.found_existing);\n    result.entry.value = value;\n}","src":538,"more_decls":null}{"doc_comment":"Inserts a new `Entry` into the hash map, returning the previous one, if any.","pl":"fn fetchPut(self: *Self, allocator: *Allocator, key: K, value: V) !?Entry","src":545,"more_decls":null}{"doc_comment":"Inserts a new `Entry` into the hash map, returning the previous one, if any.\nIf insertion happens, asserts there is enough capacity without allocating.","pl":"fn fetchPutAssumeCapacity(self: *Self, key: K, value: V) ?Entry","src":557,"more_decls":null}{"pl":"pub fn getEntry(self: Self, key: K) ?*Entry {\n    const index = self.getIndex(key) orelse return null;\n    return &self.entries.items[index];\n}","src":567,"more_decls":null}{"pl":"fn getIndex(self: Self, key: K) ?usize","src":572,"more_decls":null}{"pl":"pub fn get(self: Self, key: K) ?V {\n    return if (self.getEntry(key)) |entry| entry.value else null;\n}","src":591,"more_decls":null}{"pl":"pub fn contains(self: Self, key: K) bool {\n    return self.getEntry(key) != null;\n}","src":595,"more_decls":null}{"doc_comment":"If there is an `Entry` with a matching key, it is deleted from\nthe hash map, and then returned from this function. The entry is\nremoved from the underlying array by swapping it with the last\nelement.","pl":"pub fn swapRemove(self: *Self, key: K) ?Entry {\n    return self.removeInternal(key, .swap);\n}","src":603,"more_decls":null}{"doc_comment":"If there is an `Entry` with a matching key, it is deleted from\nthe hash map, and then returned from this function. The entry is\nremoved from the underlying array by shifting all elements forward\nthereby maintaining the current ordering.","pl":"pub fn orderedRemove(self: *Self, key: K) ?Entry {\n    return self.removeInternal(key, .ordered);\n}","src":611,"more_decls":null}{"doc_comment":"TODO deprecated: call swapRemoveAssertDiscard instead.","pl":"pub fn removeAssertDiscard(self: *Self, key: K) void {\n    return self.swapRemoveAssertDiscard(key);\n}","src":616,"more_decls":null}{"doc_comment":"Asserts there is an `Entry` with matching key, deletes it from the hash map\nby swapping it with the last element, and discards it.","pl":"pub fn swapRemoveAssertDiscard(self: *Self, key: K) void {\n    assert(self.swapRemove(key) != null);\n}","src":622,"more_decls":null}{"doc_comment":"Asserts there is an `Entry` with matching key, deletes it from the hash map\nby by shifting all elements forward thereby maintaining the current ordering.","pl":"pub fn orderedRemoveAssertDiscard(self: *Self, key: K) void {\n    assert(self.orderedRemove(key) != null);\n}","src":628,"more_decls":null}{"pl":"pub fn items(self: Self) []Entry {\n    return self.entries.items;\n}","src":632,"more_decls":null}{"pl":"fn clone(self: Self, allocator: *Allocator) !Self","src":636,"more_decls":null}{"doc_comment":"Rebuilds the key indexes. If the underlying entries has been modified directly, users\ncan call `reIndex` to update the indexes to account for these new entries.","pl":"fn reIndex(self: *Self, allocator: *Allocator) !void","src":650,"more_decls":null}{"doc_comment":"Shrinks the underlying `Entry` array to `new_len` elements and discards any associated\nindex entries. Keeps capacity the same.","pl":"fn shrinkRetainingCapacity(self: *Self, new_len: usize) void","src":665,"more_decls":null}{"doc_comment":"Shrinks the underlying `Entry` array to `new_len` elements and discards any associated\nindex entries. Reduces allocated capacity.","pl":"fn shrinkAndFree(self: *Self, allocator: *Allocator, new_len: usize) void","src":677,"more_decls":null}{"doc_comment":"Removes the last inserted `Entry` in the hash map and returns it.","pl":"pub fn pop(self: *Self) Entry {\n    const top = self.entries.items[self.entries.items.len - 1];\n    _ = self.removeWithHash(top.key, top.hash, .index_only);\n    self.entries.items.len -= 1;\n    return top;\n}","src":688,"more_decls":null}{"pl":"const Hash = if (store_hash) u32 else void","src":337,"more_decls":null}{"pl":"const Managed = ArrayHashMap(K, V, hash, eql, store_hash)","src":345,"more_decls":null}}{"pl":"fn getHashPtrAddrFn(comptime K: type) (fn (K) u32)","src":1340,"more_decls":null}{"pl":"fn getTrivialEqlFn(comptime K: type) (fn (K, K) bool)","src":1348,"more_decls":null}{"pl":"fn getAutoHashFn(comptime K: type) (fn (K) u32)","src":1356,"more_decls":null}{"pl":"fn getAutoEqlFn(comptime K: type) (fn (K, K) bool)","src":1370,"more_decls":null}{"pl":"fn autoEqlIsCheap(comptime K: type) bool","src":1378,"more_decls":null}{"pl":"fn getAutoHashStratFn(comptime K: type, comptime strategy: std.hash.Strategy) (fn (K) u32)","src":1396,"more_decls":null}]