[{"doc_comment":"Writes JSON ([RFC8259](https://tools.ietf.org/html/rfc8259)) formatted data\nto a stream. `max_depth` is a comptime-known upper bound on the nesting depth.\nTODO A future iteration of this API will allow passing `null` for this value,\nand disable safety checks in release builds.","pl":"fn WriteStream(comptime OutStream: type, comptime max_depth: usize) type","sub_container_type":"struct ","src":22,"more_decls":{"pl":"whitespace: std.json.StringifyOptions.Whitespace = std.json.StringifyOptions.Whitespace{\n            .indent_level = 0,\n            .indent = .{ .Space = 1 },\n        }","src":28,"more_decls":null}{"pl":"stream: OutStream","src":33,"more_decls":null}{"pl":"state_index: usize","src":34,"more_decls":null}{"pl":"state: [max_depth]State","src":35,"more_decls":null}{"pl":"fn init(stream: OutStream) Self","src":37,"more_decls":null}{"pl":"pub fn beginArray(self: *Self) !void {\n    assert(self.state[self.state_index] == State.Value); // need to call arrayElem or objectField\n    try self.stream.writeByte('[');\n    self.state[self.state_index] = State.ArrayStart;\n    self.whitespace.indent_level += 1;\n}","src":48,"more_decls":null}{"pl":"pub fn beginObject(self: *Self) !void {\n    assert(self.state[self.state_index] == State.Value); // need to call arrayElem or objectField\n    try self.stream.writeByte('{');\n    self.state[self.state_index] = State.ObjectStart;\n    self.whitespace.indent_level += 1;\n}","src":55,"more_decls":null}{"pl":"fn arrayElem(self: *Self) !void","src":62,"more_decls":null}{"pl":"fn objectField(self: *Self, name: []const u8) !void","src":80,"more_decls":null}{"pl":"fn endArray(self: *Self) !void","src":103,"more_decls":null}{"pl":"fn endObject(self: *Self) !void","src":123,"more_decls":null}{"pl":"pub fn emitNull(self: *Self) !void {\n    assert(self.state[self.state_index] == State.Value);\n    try self.stringify(null);\n    self.popState();\n}","src":143,"more_decls":null}{"pl":"pub fn emitBool(self: *Self, value: bool) !void {\n    assert(self.state[self.state_index] == State.Value);\n    try self.stringify(value);\n    self.popState();\n}","src":149,"more_decls":null}{"pl":"fn emitNumber(\n    self: *Self,\n    /// An integer, float, or `std.math.BigInt`. Emitted as a bare number if it fits losslessly\n    /// in a IEEE 754 double float, otherwise emitted as a string to the full precision.\n    value: anytype,\n) !void","src":155,"more_decls":null}{"pl":"pub fn emitString(self: *Self, string: []const u8) !void {\n    assert(self.state[self.state_index] == State.Value);\n    try self.writeEscapedString(string);\n    self.popState();\n}","src":189,"more_decls":null}{"doc_comment":"Writes the complete json into the output stream","pl":"pub fn emitJson(self: *Self, json: std.json.Value) Stream.Error!void {\n    assert(self.state[self.state_index] == State.Value);\n    try self.stringify(json);\n    self.popState();\n}","src":201,"more_decls":null}{"pl":"const Stream = OutStream","src":26,"more_decls":null}}{"pl":"pub fn writeStream(\n    out_stream: anytype,\n    comptime max_depth: usize,\n) WriteStream(@TypeOf(out_stream), max_depth) {\n    return WriteStream(@TypeOf(out_stream), max_depth).init(out_stream);\n}","src":230,"more_decls":null}]