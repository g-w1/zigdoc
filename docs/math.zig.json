[{"doc_comment":"See also `CompareOperator`.","pl":"pub const Order = enum ","src":1194,"more_decls":{"doc_comment":"Less than (`<`)","pl":"lt","src":1196,"more_decls":null}{"doc_comment":"Equal (`==`)","pl":"eq","src":1199,"more_decls":null}{"doc_comment":"Greater than (`>`)","pl":"gt","src":1202,"more_decls":null}{"pl":"fn invert(self: Order) Order","src":1204,"more_decls":null}{"pl":"fn compare(self: Order, op: CompareOperator) bool","src":1212,"more_decls":null}}{"doc_comment":"See also `Order`.","pl":"pub const CompareOperator = enum ","src":1256,"more_decls":{"doc_comment":"Less than (`<`)","pl":"lt","src":1258,"more_decls":null}{"doc_comment":"Less than or equal (`<=`)","pl":"lte","src":1260,"more_decls":null}{"doc_comment":"Equal (`==`)","pl":"eq","src":1262,"more_decls":null}{"doc_comment":"Greater than or equal (`>=`)","pl":"gte","src":1264,"more_decls":null}{"doc_comment":"Greater than (`>`)","pl":"gt","src":1266,"more_decls":null}{"doc_comment":"Not equal (`!=`)","pl":"neq","src":1268,"more_decls":null}}{"doc_comment":"Performs an approximate comparison of two floating point values `x` and `y`.\nReturns true if the absolute difference between them is less or equal than\nthe specified tolerance.\n\nThe `tolerance` parameter is the absolute tolerance used when determining if\nthe two numbers are close enough, a good value for this parameter is a small\nmultiple of `epsilon(T)`.\n\nNote that this function is recommended for for comparing small numbers\naround zero, using `approxEqRel` is suggested otherwise.\n\nNaN values are never considered equal to any value.","pl":"fn approxEqAbs(comptime T: type, x: T, y: T, tolerance: T) bool","src":120,"more_decls":null}{"doc_comment":"Performs an approximate comparison of two floating point values `x` and `y`.\nReturns true if the absolute difference between them is less or equal than\n`max(|x|, |y|) * tolerance`, where `tolerance` is a positive number greater\nthan zero.\n\nThe `tolerance` parameter is the relative tolerance used when determining if\nthe two numbers are close enough, a good value for this parameter is usually\n`sqrt(epsilon(T))`, meaning that the two numbers are considered equal if at\nleast half of the digits are equal.\n\nNote that for comparisons of small numbers around zero this function won't\ngive meaningful results, use `approxEqAbs` instead.\n\nNaN values are never considered equal to any value.","pl":"fn approxEqRel(comptime T: type, x: T, y: T, tolerance: T) bool","src":148,"more_decls":null}{"pl":"fn doNotOptimizeAway(value: anytype) void","src":196,"more_decls":null}{"pl":"pub fn raiseInvalid() void {\n    // Raise INVALID fpu exception\n}","src":205,"more_decls":null}{"pl":"pub fn raiseUnderflow() void {\n    // Raise UNDERFLOW fpu exception\n}","src":209,"more_decls":null}{"pl":"pub fn raiseOverflow() void {\n    // Raise OVERFLOW fpu exception\n}","src":213,"more_decls":null}{"pl":"pub fn raiseInexact() void {\n    // Raise INEXACT fpu exception\n}","src":217,"more_decls":null}{"pl":"pub fn raiseDivByZero() void {\n    // Raise INEXACT fpu exception\n}","src":221,"more_decls":null}{"pl":"fn floatMantissaBits(comptime T: type) comptime_int","src":284,"more_decls":null}{"pl":"fn floatExponentBits(comptime T: type) comptime_int","src":297,"more_decls":null}{"doc_comment":"Given two types, returns the smallest one which is capable of holding the\nfull range of the minimum value.","pl":"fn Min(comptime A: type, comptime B: type) type","src":312,"more_decls":null}{"doc_comment":"Returns the smaller number. When one of the parameter's type's full range fits in the other,\nthe return type is the smaller type.","pl":"fn min(x: anytype, y: anytype) Min(@TypeOf(x), @TypeOf(y))","src":331,"more_decls":null}{"pl":"pub fn max(x: anytype, y: anytype) @TypeOf(x, y) {\n    return if (x > y) x else y;\n}","src":382,"more_decls":null}{"pl":"pub fn clamp(val: anytype, lower: anytype, upper: anytype) @TypeOf(val, lower, upper) {\n    assert(lower <= upper);\n    return max(lower, min(val, upper));\n}","src":390,"more_decls":null}{"pl":"pub fn mul(comptime T: type, a: T, b: T) (error{Overflow}!T) {\n    var answer: T = undefined;\n    return if (@mulWithOverflow(T, a, b, &answer)) error.Overflow else answer;\n}","src":411,"more_decls":null}{"pl":"pub fn add(comptime T: type, a: T, b: T) (error{Overflow}!T) {\n    if (T == comptime_int) return a + b;\n    var answer: T = undefined;\n    return if (@addWithOverflow(T, a, b, &answer)) error.Overflow else answer;\n}","src":416,"more_decls":null}{"pl":"pub fn sub(comptime T: type, a: T, b: T) (error{Overflow}!T) {\n    var answer: T = undefined;\n    return if (@subWithOverflow(T, a, b, &answer)) error.Overflow else answer;\n}","src":422,"more_decls":null}{"pl":"pub fn negate(x: anytype) !@TypeOf(x) {\n    return sub(@TypeOf(x), 0, x);\n}","src":427,"more_decls":null}{"pl":"pub fn shlExact(comptime T: type, a: T, shift_amt: Log2Int(T)) !T {\n    var answer: T = undefined;\n    return if (@shlWithOverflow(T, a, shift_amt, &answer)) error.Overflow else answer;\n}","src":431,"more_decls":null}{"doc_comment":"Shifts left. Overflowed bits are truncated.\nA negative shift amount results in a right shift.","pl":"fn shl(comptime T: type, a: T, shift_amt: anytype) T","src":438,"more_decls":null}{"doc_comment":"Shifts right. Overflowed bits are truncated.\nA negative shift amount results in a left shift.","pl":"fn shr(comptime T: type, a: T, shift_amt: anytype) T","src":478,"more_decls":null}{"doc_comment":"Rotates right. Only unsigned values can be rotated.\nNegative shift values results in shift modulo the bit count.","pl":"fn rotr(comptime T: type, x: T, r: anytype) T","src":518,"more_decls":null}{"doc_comment":"Rotates left. Only unsigned values can be rotated.\nNegative shift values results in shift modulo the bit count.","pl":"fn rotl(comptime T: type, x: T, r: anytype) T","src":546,"more_decls":null}{"pl":"fn Log2Int(comptime T: type) type","src":572,"more_decls":null}{"pl":"fn IntFittingRange(comptime from: comptime_int, comptime to: comptime_int) type","src":583,"more_decls":null}{"pl":"fn absInt(x: anytype) !@TypeOf(x)","src":658,"more_decls":null}{"pl":"pub fn divTrunc(comptime T: type, numerator: T, denominator: T) !T {\n    @setRuntimeSafety(false);\n    if (denominator == 0) return error.DivisionByZero;\n    if (@typeInfo(T) == .Int and @typeInfo(T).Int.signedness == .signed and numerator == minInt(T) and denominator == -1) return error.Overflow;\n    return @divTrunc(numerator, denominator);\n}","src":691,"more_decls":null}{"pl":"pub fn divFloor(comptime T: type, numerator: T, denominator: T) !T {\n    @setRuntimeSafety(false);\n    if (denominator == 0) return error.DivisionByZero;\n    if (@typeInfo(T) == .Int and @typeInfo(T).Int.signedness == .signed and numerator == minInt(T) and denominator == -1) return error.Overflow;\n    return @divFloor(numerator, denominator);\n}","src":712,"more_decls":null}{"pl":"fn divCeil(comptime T: type, numerator: T, denominator: T) !T","src":733,"more_decls":null}{"pl":"fn divExact(comptime T: type, numerator: T, denominator: T) !T","src":786,"more_decls":null}{"pl":"pub fn mod(comptime T: type, numerator: T, denominator: T) !T {\n    @setRuntimeSafety(false);\n    if (denominator == 0) return error.DivisionByZero;\n    if (denominator < 0) return error.NegativeDenominator;\n    return @mod(numerator, denominator);\n}","src":811,"more_decls":null}{"pl":"pub fn rem(comptime T: type, numerator: T, denominator: T) !T {\n    @setRuntimeSafety(false);\n    if (denominator == 0) return error.DivisionByZero;\n    if (denominator < 0) return error.NegativeDenominator;\n    return @rem(numerator, denominator);\n}","src":834,"more_decls":null}{"doc_comment":"Returns the absolute value of the integer parameter.\nResult is an unsigned integer.","pl":"fn absCast(x: anytype) switch (@typeInfo(@TypeOf(x))) {\n    .ComptimeInt => comptime_int,\n    .Int => |intInfo| std.meta.Int(.unsigned, intInfo.bits),\n    else => @compileError(\"absCast only accepts integers\"),\n}","src":859,"more_decls":null}{"doc_comment":"Returns the negation of the integer parameter.\nResult is a signed integer.","pl":"fn negateCast(x: anytype) !std.meta.Int(.signed, std.meta.bitCount(@TypeOf(x)))","src":894,"more_decls":null}{"doc_comment":"Cast an integer to a different integer type. If the value doesn't fit,\nreturn an error.\nTODO make this an optional not an error.","pl":"fn cast(comptime T: type, x: anytype) (error{Overflow}!T)","src":918,"more_decls":null}{"doc_comment":"Align cast a pointer but return an error if it's the wrong alignment","pl":"fn alignCast(comptime alignment: u29, ptr: anytype) AlignCastError!@TypeOf(@alignCast(alignment, ptr))","src":943,"more_decls":null}{"pl":"pub fn isPowerOfTwo(v: anytype) bool {\n    assert(v != 0);\n    return (v & (v - 1)) == 0;\n}","src":951,"more_decls":null}{"pl":"fn floorPowerOfTwo(comptime T: type, value: T) T","src":956,"more_decls":null}{"doc_comment":"Returns the next power of two (if the value is not already a power of two).\nOnly unsigned integers can be used. Zero is not an allowed input.\nResult is a type with 1 more bit than the input type.","pl":"fn ceilPowerOfTwoPromote(comptime T: type, value: T) std.meta.Int(@typeInfo(T).Int.signedness, @typeInfo(T).Int.bits + 1)","src":984,"more_decls":null}{"doc_comment":"Returns the next power of two (if the value is not already a power of two).\nOnly unsigned integers can be used. Zero is not an allowed input.\nIf the value doesn't fit, returns an error.","pl":"fn ceilPowerOfTwo(comptime T: type, value: T) (error{Overflow}!T)","src":996,"more_decls":null}{"pl":"pub fn ceilPowerOfTwoAssert(comptime T: type, value: T) T {\n    return ceilPowerOfTwo(T, value) catch unreachable;\n}","src":1009,"more_decls":null}{"pl":"pub fn log2_int(comptime T: type, x: T) Log2Int(T) {\n    assert(x != 0);\n    return @intCast(Log2Int(T), @typeInfo(T).Int.bits - 1 - @clz(T, x));\n}","src":1047,"more_decls":null}{"pl":"fn log2_int_ceil(comptime T: type, x: T) Log2Int(T)","src":1052,"more_decls":null}{"doc_comment":"Cast a value to a different type. If the value doesn't fit in, or can't be perfectly represented by,\nthe new type, it will be converted to the closest possible representation.","pl":"fn lossyCast(comptime T: type, value: anytype) T","src":1075,"more_decls":null}{"pl":"pub fn maxInt(comptime T: type) comptime_int {\n    const info = @typeInfo(T);\n    const bit_count = info.Int.bits;\n    if (bit_count == 0) return 0;\n    return (1 << (bit_count - @boolToInt(info.Int.signedness == .signed))) - 1;\n}","src":1125,"more_decls":null}{"pl":"fn minInt(comptime T: type) comptime_int","src":1132,"more_decls":null}{"pl":"pub fn mulWide(comptime T: type, a: T, b: T) std.meta.Int(@typeInfo(T).Int.signedness, @typeInfo(T).Int.bits * 2) {\n    const ResultInt = std.meta.Int(@typeInfo(T).Int.signedness, @typeInfo(T).Int.bits * 2);\n    return @as(ResultInt, a) * @as(ResultInt, b);\n}","src":1182,"more_decls":null}{"doc_comment":"Given two numbers, this function returns the order they are with respect to each other.","pl":"fn order(a: anytype, b: anytype) Order","src":1243,"more_decls":null}{"doc_comment":"This function does the same thing as comparison operators, however the\noperator is a runtime-known enum value. Works on any operands that\nsupport comparison operators.","pl":"fn compare(a: anytype, op: CompareOperator, b: anytype) bool","src":1274,"more_decls":null}{"doc_comment":"Returns a mask of all ones if value is true,\nand a mask of all zeroes if value is false.\nCompiles to one instruction for register sized integers.","pl":"fn boolMask(comptime MaskInt: type, value: bool) callconv(.Inline) MaskInt","src":1336,"more_decls":null}{"doc_comment":"Euler's number (e)","pl":"const e = 2.71828182845904523536028747135266249775724709369995","src":11,"more_decls":null}{"doc_comment":"Archimedes' constant (π)","pl":"const pi = 3.14159265358979323846264338327950288419716939937510","src":14,"more_decls":null}{"doc_comment":"Circle constant (τ)","pl":"const tau = 2 * pi","src":17,"more_decls":null}{"doc_comment":"log2(e)","pl":"const log2e = 1.442695040888963407359924681001892137","src":20,"more_decls":null}{"doc_comment":"log10(e)","pl":"const log10e = 0.434294481903251827651128918916605082","src":23,"more_decls":null}{"doc_comment":"ln(2)","pl":"const ln2 = 0.693147180559945309417232121458176568","src":26,"more_decls":null}{"doc_comment":"ln(10)","pl":"const ln10 = 2.302585092994045684017991454684364208","src":29,"more_decls":null}{"doc_comment":"2/sqrt(π)","pl":"const two_sqrtpi = 1.128379167095512573896158903121545172","src":32,"more_decls":null}{"doc_comment":"sqrt(2)","pl":"const sqrt2 = 1.414213562373095048801688724209698079","src":35,"more_decls":null}{"doc_comment":"1/sqrt(2)","pl":"const sqrt1_2 = 0.707106781186547524400844362104849039","src":38,"more_decls":null}{"pl":"const f128_true_min = @bitCast(f128, @as(u128, 0x00000000000000000000000000000001))","src":41,"more_decls":null}{"pl":"const f128_min = @bitCast(f128, @as(u128, 0x00010000000000000000000000000000))","src":42,"more_decls":null}{"pl":"const f128_max = @bitCast(f128, @as(u128, 0x7FFEFFFFFFFFFFFFFFFFFFFFFFFFFFFF))","src":43,"more_decls":null}{"pl":"const f128_epsilon = @bitCast(f128, @as(u128, 0x3F8F0000000000000000000000000000))","src":44,"more_decls":null}{"pl":"const f128_toint = 1.0 / f128_epsilon","src":45,"more_decls":null}{"pl":"const f64_true_min = 4.94065645841246544177e-324","src":48,"more_decls":null}{"pl":"const f64_min = 2.2250738585072014e-308","src":49,"more_decls":null}{"pl":"const f64_max = 1.79769313486231570815e+308","src":50,"more_decls":null}{"pl":"const f64_epsilon = 2.22044604925031308085e-16","src":51,"more_decls":null}{"pl":"const f64_toint = 1.0 / f64_epsilon","src":52,"more_decls":null}{"pl":"const f32_true_min = 1.40129846432481707092e-45","src":54,"more_decls":null}{"pl":"const f32_min = 1.17549435082228750797e-38","src":55,"more_decls":null}{"pl":"const f32_max = 3.40282346638528859812e+38","src":56,"more_decls":null}{"pl":"const f32_epsilon = 1.1920928955078125e-07","src":57,"more_decls":null}{"pl":"const f32_toint = 1.0 / f32_epsilon","src":58,"more_decls":null}{"pl":"const f16_true_min = 0.000000059604644775390625","src":60,"more_decls":null}{"pl":"const f16_min = 0.00006103515625","src":61,"more_decls":null}{"pl":"const f16_max = 65504","src":62,"more_decls":null}{"pl":"const f16_epsilon = 0.0009765625","src":63,"more_decls":null}{"pl":"const f16_toint = 1.0 / f16_epsilon","src":64,"more_decls":null}{"pl":"const epsilon = @import(\"math/epsilon.zig\").epsilon","src":66,"more_decls":null}{"pl":"const nan_u16 = @as(u16, 0x7C01)","src":68,"more_decls":null}{"pl":"const nan_f16 = @bitCast(f16, nan_u16)","src":69,"more_decls":null}{"pl":"const qnan_u16 = @as(u16, 0x7E00)","src":71,"more_decls":null}{"pl":"const qnan_f16 = @bitCast(f16, qnan_u16)","src":72,"more_decls":null}{"pl":"const inf_u16 = @as(u16, 0x7C00)","src":74,"more_decls":null}{"pl":"const inf_f16 = @bitCast(f16, inf_u16)","src":75,"more_decls":null}{"pl":"const nan_u32 = @as(u32, 0x7F800001)","src":77,"more_decls":null}{"pl":"const nan_f32 = @bitCast(f32, nan_u32)","src":78,"more_decls":null}{"pl":"const qnan_u32 = @as(u32, 0x7FC00000)","src":80,"more_decls":null}{"pl":"const qnan_f32 = @bitCast(f32, qnan_u32)","src":81,"more_decls":null}{"pl":"const inf_u32 = @as(u32, 0x7F800000)","src":83,"more_decls":null}{"pl":"const inf_f32 = @bitCast(f32, inf_u32)","src":84,"more_decls":null}{"pl":"const nan_u64 = @as(u64, 0x7FF << 52) | 1","src":86,"more_decls":null}{"pl":"const nan_f64 = @bitCast(f64, nan_u64)","src":87,"more_decls":null}{"pl":"const qnan_u64 = @as(u64, 0x7ff8000000000000)","src":89,"more_decls":null}{"pl":"const qnan_f64 = @bitCast(f64, qnan_u64)","src":90,"more_decls":null}{"pl":"const inf_u64 = @as(u64, 0x7FF << 52)","src":92,"more_decls":null}{"pl":"const inf_f64 = @bitCast(f64, inf_u64)","src":93,"more_decls":null}{"pl":"const nan_u128 = @as(u128, 0x7fff0000000000000000000000000001)","src":95,"more_decls":null}{"pl":"const nan_f128 = @bitCast(f128, nan_u128)","src":96,"more_decls":null}{"pl":"const qnan_u128 = @as(u128, 0x7fff8000000000000000000000000000)","src":98,"more_decls":null}{"pl":"const qnan_f128 = @bitCast(f128, qnan_u128)","src":99,"more_decls":null}{"pl":"const inf_u128 = @as(u128, 0x7fff0000000000000000000000000000)","src":101,"more_decls":null}{"pl":"const inf_f128 = @bitCast(f128, inf_u128)","src":102,"more_decls":null}{"pl":"const nan = @import(\"math/nan.zig\").nan","src":104,"more_decls":null}{"pl":"const snan = @import(\"math/nan.zig\").snan","src":105,"more_decls":null}{"pl":"const inf = @import(\"math/inf.zig\").inf","src":106,"more_decls":null}{"doc_comment":"Deprecated, use `approxEqAbs` or `approxEqRel`.","pl":"const approxEq = approxEqAbs","src":163,"more_decls":null}{"pl":"const isNan = @import(\"math/isnan.zig\").isNan","src":225,"more_decls":null}{"pl":"const isSignalNan = @import(\"math/isnan.zig\").isSignalNan","src":226,"more_decls":null}{"pl":"const fabs = @import(\"math/fabs.zig\").fabs","src":227,"more_decls":null}{"pl":"const ceil = @import(\"math/ceil.zig\").ceil","src":228,"more_decls":null}{"pl":"const floor = @import(\"math/floor.zig\").floor","src":229,"more_decls":null}{"pl":"const trunc = @import(\"math/trunc.zig\").trunc","src":230,"more_decls":null}{"pl":"const round = @import(\"math/round.zig\").round","src":231,"more_decls":null}{"pl":"const frexp = @import(\"math/frexp.zig\").frexp","src":232,"more_decls":null}{"pl":"const frexp32_result = @import(\"math/frexp.zig\").frexp32_result","src":233,"more_decls":null}{"pl":"const frexp64_result = @import(\"math/frexp.zig\").frexp64_result","src":234,"more_decls":null}{"pl":"const modf = @import(\"math/modf.zig\").modf","src":235,"more_decls":null}{"pl":"const modf32_result = @import(\"math/modf.zig\").modf32_result","src":236,"more_decls":null}{"pl":"const modf64_result = @import(\"math/modf.zig\").modf64_result","src":237,"more_decls":null}{"pl":"const copysign = @import(\"math/copysign.zig\").copysign","src":238,"more_decls":null}{"pl":"const isFinite = @import(\"math/isfinite.zig\").isFinite","src":239,"more_decls":null}{"pl":"const isInf = @import(\"math/isinf.zig\").isInf","src":240,"more_decls":null}{"pl":"const isPositiveInf = @import(\"math/isinf.zig\").isPositiveInf","src":241,"more_decls":null}{"pl":"const isNegativeInf = @import(\"math/isinf.zig\").isNegativeInf","src":242,"more_decls":null}{"pl":"const isNormal = @import(\"math/isnormal.zig\").isNormal","src":243,"more_decls":null}{"pl":"const signbit = @import(\"math/signbit.zig\").signbit","src":244,"more_decls":null}{"pl":"const scalbn = @import(\"math/scalbn.zig\").scalbn","src":245,"more_decls":null}{"pl":"const pow = @import(\"math/pow.zig\").pow","src":246,"more_decls":null}{"pl":"const powi = @import(\"math/powi.zig\").powi","src":247,"more_decls":null}{"pl":"const sqrt = @import(\"math/sqrt.zig\").sqrt","src":248,"more_decls":null}{"pl":"const cbrt = @import(\"math/cbrt.zig\").cbrt","src":249,"more_decls":null}{"pl":"const acos = @import(\"math/acos.zig\").acos","src":250,"more_decls":null}{"pl":"const asin = @import(\"math/asin.zig\").asin","src":251,"more_decls":null}{"pl":"const atan = @import(\"math/atan.zig\").atan","src":252,"more_decls":null}{"pl":"const atan2 = @import(\"math/atan2.zig\").atan2","src":253,"more_decls":null}{"pl":"const hypot = @import(\"math/hypot.zig\").hypot","src":254,"more_decls":null}{"pl":"const exp = @import(\"math/exp.zig\").exp","src":255,"more_decls":null}{"pl":"const exp2 = @import(\"math/exp2.zig\").exp2","src":256,"more_decls":null}{"pl":"const expm1 = @import(\"math/expm1.zig\").expm1","src":257,"more_decls":null}{"pl":"const ilogb = @import(\"math/ilogb.zig\").ilogb","src":258,"more_decls":null}{"pl":"const ln = @import(\"math/ln.zig\").ln","src":259,"more_decls":null}{"pl":"const log = @import(\"math/log.zig\").log","src":260,"more_decls":null}{"pl":"const log2 = @import(\"math/log2.zig\").log2","src":261,"more_decls":null}{"pl":"const log10 = @import(\"math/log10.zig\").log10","src":262,"more_decls":null}{"pl":"const log1p = @import(\"math/log1p.zig\").log1p","src":263,"more_decls":null}{"pl":"const fma = @import(\"math/fma.zig\").fma","src":264,"more_decls":null}{"pl":"const asinh = @import(\"math/asinh.zig\").asinh","src":265,"more_decls":null}{"pl":"const acosh = @import(\"math/acosh.zig\").acosh","src":266,"more_decls":null}{"pl":"const atanh = @import(\"math/atanh.zig\").atanh","src":267,"more_decls":null}{"pl":"const sinh = @import(\"math/sinh.zig\").sinh","src":268,"more_decls":null}{"pl":"const cosh = @import(\"math/cosh.zig\").cosh","src":269,"more_decls":null}{"pl":"const tanh = @import(\"math/tanh.zig\").tanh","src":270,"more_decls":null}{"pl":"const cos = @import(\"math/cos.zig\").cos","src":271,"more_decls":null}{"pl":"const sin = @import(\"math/sin.zig\").sin","src":272,"more_decls":null}{"pl":"const tan = @import(\"math/tan.zig\").tan","src":273,"more_decls":null}{"pl":"const complex = @import(\"math/complex.zig\")","src":275,"more_decls":null}{"pl":"const Complex = complex.Complex","src":276,"more_decls":null}{"pl":"const big = @import(\"math/big.zig\")","src":278,"more_decls":null}{"pl":"const absFloat = fabs","src":680,"more_decls":null}{"pl":"const AlignCastError = error{UnalignedMemory}","src":940,"more_decls":null}]