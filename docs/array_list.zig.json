[{"doc_comment":"A contiguous, growable list of items in memory.\nThis is a wrapper around an array of T values. Initialize with `init`.\n\nThis struct internally stores a `std.mem.Allocator` for memory management.\nTo manually specify an allocator with each method call see `ArrayListUnmanaged`.","pl":"pub fn ArrayList(comptime T: type) type {\n    return ArrayListAligned(T, null);\n}","src":17,"more_decls":null}{"doc_comment":"A contiguous, growable list of arbitrarily aligned items in memory.\nThis is a wrapper around an array of T values aligned to `alignment`-byte\naddresses. If the specified alignment is `null`, then `@alignOf(T)` is used.\nInitialize with `init`.\n\nThis struct internally stores a `std.mem.Allocator` for memory management.\nTo manually specify an allocator with each method call see `ArrayListAlignedUnmanaged`.","pl":"fn ArrayListAligned(comptime T: type, comptime alignment: ?u29) type","sub_container_type":"struct ","src":28,"more_decls":{"doc_comment":"Contents of the list. Pointers to elements in this slice are\n**invalid after resizing operations** on the ArrayList, unless the\noperation explicitly either: (1) states otherwise or (2) lists the\ninvalidated pointers.\n\nThe allocator used determines how element pointers are\ninvalidated, so the behavior may vary between lists. To avoid\nillegal behavior, take into account the above paragraph plus the\nexplicit statements given in each method.","pl":"items: Slice","src":45,"more_decls":null}{"doc_comment":"How many T values this list can hold without allocating\nadditional memory.","pl":"capacity: usize","src":48,"more_decls":null}{"pl":"allocator: *Allocator","src":49,"more_decls":null}{"doc_comment":"Deinitialize with `deinit` or use `toOwnedSlice`.","pl":"fn init(allocator: *Allocator) Self","src":55,"more_decls":null}{"doc_comment":"Initialize with capacity to hold at least `num` elements.\nDeinitialize with `deinit` or use `toOwnedSlice`.","pl":"fn initCapacity(allocator: *Allocator, num: usize) !Self","src":65,"more_decls":null}{"doc_comment":"Release all allocated memory.","pl":"pub fn deinit(self: Self) void {\n    self.allocator.free(self.allocatedSlice());\n}","src":76,"more_decls":null}{"doc_comment":"ArrayList takes ownership of the passed in slice. The slice must have been\nallocated with `allocator`.\nDeinitialize with `deinit` or use `toOwnedSlice`.","pl":"fn fromOwnedSlice(allocator: *Allocator, slice: Slice) Self","src":92,"more_decls":null}{"doc_comment":"Initializes an ArrayListUnmanaged with the `items` and `capacity` fields\nof this ArrayList. This ArrayList retains ownership of underlying memory.\nDeprecated: use `moveToUnmanaged` which has different semantics.","pl":"pub fn toUnmanaged(self: Self) ArrayListAlignedUnmanaged(T, alignment) {\n    return .{ .items = self.items, .capacity = self.capacity };\n}","src":103,"more_decls":null}{"doc_comment":"Initializes an ArrayListUnmanaged with the `items` and `capacity` fields\nof this ArrayList. Empties this ArrayList.","pl":"pub fn moveToUnmanaged(self: *Self) ArrayListAlignedUnmanaged(T, alignment) {\n    const allocator = self.allocator;\n    const result = .{ .items = self.items, .capacity = self.capacity };\n    self.* = init(allocator);\n    return result;\n}","src":109,"more_decls":null}{"doc_comment":"The caller owns the returned memory. Empties this ArrayList.","pl":"pub fn toOwnedSlice(self: *Self) Slice {\n    const allocator = self.allocator;\n    const result = allocator.shrink(self.allocatedSlice(), self.items.len);\n    self.* = init(allocator);\n    return result;\n}","src":117,"more_decls":null}{"doc_comment":"The caller owns the returned memory. Empties this ArrayList.","pl":"pub fn toOwnedSliceSentinel(self: *Self, comptime sentinel: T) ![:sentinel]T {\n    try self.append(sentinel);\n    const result = self.toOwnedSlice();\n    return result[0 .. result.len - 1 :sentinel];\n}","src":125,"more_decls":null}{"doc_comment":"Insert `item` at index `n` by moving `list[n .. list.len]` to make room.\nThis operation is O(N).","pl":"fn insert(self: *Self, n: usize, item: T) !void","src":133,"more_decls":null}{"doc_comment":"Insert slice `items` at index `i` by moving `list[i .. list.len]` to make room.\nThis operation is O(N).","pl":"fn insertSlice(self: *Self, i: usize, items: SliceConst) !void","src":143,"more_decls":null}{"doc_comment":"Replace range of elements `list[start..start+len]` with `new_items`.\nGrows list if `len < new_items.len`.\nShrinks list if `len > new_items.len`.\nInvalidates pointers if this ArrayList is resized.","pl":"fn replaceRange(self: *Self, start: usize, len: usize, new_items: SliceConst) !void","src":155,"more_decls":null}{"doc_comment":"Extend the list by 1 element. Allocates more memory as necessary.","pl":"pub fn append(self: *Self, item: T) !void {\n    const new_item_ptr = try self.addOne();\n    new_item_ptr.* = item;\n}","src":180,"more_decls":null}{"doc_comment":"Extend the list by 1 element, but assert `self.capacity`\nis sufficient to hold an additional item. **Does not**\ninvalidate pointers.","pl":"pub fn appendAssumeCapacity(self: *Self, item: T) void {\n    const new_item_ptr = self.addOneAssumeCapacity();\n    new_item_ptr.* = item;\n}","src":188,"more_decls":null}{"doc_comment":"Remove the element at index `i`, shift elements after index\n`i` forward, and return the removed element.\nAsserts the array has at least one item.\nInvalidates pointers to end of list.\nThis operation is O(N).","pl":"fn orderedRemove(self: *Self, i: usize) T","src":198,"more_decls":null}{"doc_comment":"Removes the element at the specified index and returns it.\nThe empty slot is filled from the end of the list.\nThis operation is O(1).","pl":"fn swapRemove(self: *Self, i: usize) T","src":212,"more_decls":null}{"doc_comment":"Append the slice of items to the list. Allocates more\nmemory as necessary.","pl":"pub fn appendSlice(self: *Self, items: SliceConst) !void {\n    try self.ensureCapacity(self.items.len + items.len);\n    self.appendSliceAssumeCapacity(items);\n}","src":222,"more_decls":null}{"doc_comment":"Append the slice of items to the list, asserting the capacity is already\nenough to store the new items. **Does not** invalidate pointers.","pl":"pub fn appendSliceAssumeCapacity(self: *Self, items: SliceConst) void {\n    const oldlen = self.items.len;\n    const newlen = self.items.len + items.len;\n    self.items.len = newlen;\n    mem.copy(T, self.items[oldlen..], items);\n}","src":229,"more_decls":null}{"doc_comment":"Append a value to the list `n` times.\nAllocates more memory as necessary.","pl":"pub fn appendNTimes(self: *Self, value: T, n: usize) !void {\n    const old_len = self.items.len;\n    try self.resize(self.items.len + n);\n    mem.set(T, self.items[old_len..self.items.len], value);\n}","src":254,"more_decls":null}{"doc_comment":"Append a value to the list `n` times.\nAsserts the capacity is enough. **Does not** invalidate pointers.","pl":"pub fn appendNTimesAssumeCapacity(self: *Self, value: T, n: usize) void {\n    const new_len = self.items.len + n;\n    assert(new_len <= self.capacity);\n    mem.set(T, self.items.ptr[self.items.len..new_len], value);\n    self.items.len = new_len;\n}","src":262,"more_decls":null}{"doc_comment":"Adjust the list's length to `new_len`.\nDoes not initialize added items if any.","pl":"pub fn resize(self: *Self, new_len: usize) !void {\n    try self.ensureCapacity(new_len);\n    self.items.len = new_len;\n}","src":271,"more_decls":null}{"doc_comment":"Reduce allocated capacity to `new_len`.\nMay invalidate element pointers.","pl":"fn shrinkAndFree(self: *Self, new_len: usize) void","src":278,"more_decls":null}{"doc_comment":"Reduce length to `new_len`.\nInvalidates pointers for the elements `items[new_len..]`.","pl":"pub fn shrinkRetainingCapacity(self: *Self, new_len: usize) void {\n    assert(new_len <= self.items.len);\n    self.items.len = new_len;\n}","src":292,"more_decls":null}{"doc_comment":"Modify the array so that it can hold at least `new_capacity` items.\nInvalidates pointers if additional memory is needed.","pl":"fn ensureCapacity(self: *Self, new_capacity: usize) !void","src":299,"more_decls":null}{"doc_comment":"Increases the array's length to match the full capacity that is already allocated.\nThe new elements have `undefined` values. **Does not** invalidate pointers.","pl":"pub fn expandToCapacity(self: *Self) void {\n    self.items.len = self.capacity;\n}","src":316,"more_decls":null}{"doc_comment":"Increase length by 1, returning pointer to the new item.\nThe returned pointer becomes invalid when the list resized.","pl":"pub fn addOne(self: *Self) !*T {\n    const newlen = self.items.len + 1;\n    try self.ensureCapacity(newlen);\n    return self.addOneAssumeCapacity();\n}","src":322,"more_decls":null}{"doc_comment":"Increase length by 1, returning pointer to the new item.\nAsserts that there is already space for the new item without allocating more.\nThe returned pointer becomes invalid when the list is resized.\n**Does not** invalidate element pointers.","pl":"pub fn addOneAssumeCapacity(self: *Self) *T {\n    assert(self.items.len < self.capacity);\n\n    self.items.len += 1;\n    return &self.items[self.items.len - 1];\n}","src":332,"more_decls":null}{"doc_comment":"Resize the array, adding `n` new elements, which have `undefined` values.\nThe return value is an array pointing to the newly allocated elements.\nThe returned pointer becomes invalid when the list is resized.\nResizes list if `self.capacity` is not large enough.","pl":"pub fn addManyAsArray(self: *Self, comptime n: usize) !*[n]T {\n    const prev_len = self.items.len;\n    try self.resize(self.items.len + n);\n    return self.items[prev_len..][0..n];\n}","src":343,"more_decls":null}{"doc_comment":"Resize the array, adding `n` new elements, which have `undefined` values.\nThe return value is an array pointing to the newly allocated elements.\nAsserts that there is already space for the new item without allocating more.\n**Does not** invalidate element pointers.\nThe returned pointer becomes invalid when the list is resized.","pl":"pub fn addManyAsArrayAssumeCapacity(self: *Self, comptime n: usize) *[n]T {\n    assert(self.items.len + n <= self.capacity);\n    const prev_len = self.items.len;\n    self.items.len += n;\n    return self.items[prev_len..][0..n];\n}","src":354,"more_decls":null}{"doc_comment":"Remove and return the last element from the list.\nAsserts the list has at least one item.\nInvalidates pointers to the removed element.","pl":"pub fn pop(self: *Self) T {\n    const val = self.items[self.items.len - 1];\n    self.items.len -= 1;\n    return val;\n}","src":364,"more_decls":null}{"doc_comment":"Remove and return the last element from the list, or\nreturn `null` if list is empty.\nInvalidates pointers to the removed element, if any.","pl":"pub fn popOrNull(self: *Self) ?T {\n    if (self.items.len == 0) return null;\n    return self.pop();\n}","src":373,"more_decls":null}{"doc_comment":"Returns a slice of all the items plus the extra capacity, whose memory\ncontents are `undefined`.","pl":"pub fn allocatedSlice(self: Self) Slice {\n    // For a nicer API, `items.len` is the length, not the capacity.\n    // This requires \"unsafe\" slicing.\n    return self.items.ptr[0..self.capacity];\n}","src":380,"more_decls":null}{"doc_comment":"Returns a slice of only the extra capacity after items.\nThis can be useful for writing directly into an ArrayList.\nNote that such an operation must be followed up with a direct\nmodification of `self.items.len`.","pl":"pub fn unusedCapacitySlice(self: Self) Slice {\n    return self.allocatedSlice()[self.items.len..];\n}","src":390,"more_decls":null}{"pl":"const Slice = if (alignment) |a| ([]align(a) T) else []T","src":51,"more_decls":null}{"pl":"const SliceConst = if (alignment) |a| ([]align(a) const T) else []const T","src":52,"more_decls":null}{"pl":"const span = @compileError(\"deprecated: use `items` field directly\")","src":80,"more_decls":null}{"pl":"const toSlice = @compileError(\"deprecated: use `items` field directly\")","src":81,"more_decls":null}{"pl":"const toSliceConst = @compileError(\"deprecated: use `items` field directly\")","src":82,"more_decls":null}{"pl":"const at = @compileError(\"deprecated: use `list.items[i]`\")","src":83,"more_decls":null}{"pl":"const ptrAt = @compileError(\"deprecated: use `&list.items[i]`\")","src":84,"more_decls":null}{"pl":"const setOrError = @compileError(\"deprecated: use `if (i >= list.items.len) return error.OutOfBounds else list.items[i] = item`\")","src":85,"more_decls":null}{"pl":"const set = @compileError(\"deprecated: use `list.items[i] = item`\")","src":86,"more_decls":null}{"pl":"const swapRemoveOrError = @compileError(\"deprecated: use `if (i >= list.items.len) return error.OutOfBounds else list.swapRemove(i)`\")","src":87,"more_decls":null}}{"doc_comment":"An ArrayList, but the allocator is passed as a parameter to the relevant functions\nrather than stored in the struct itself. The same allocator **must** be used throughout\nthe entire lifetime of an ArrayListUnmanaged. Initialize directly or with\n`initCapacity`, and deinitialize with `deinit` or use `toOwnedSlice`.","pl":"pub fn ArrayListUnmanaged(comptime T: type) type {\n    return ArrayListAlignedUnmanaged(T, null);\n}","src":400,"more_decls":null}{"doc_comment":"An ArrayListAligned, but the allocator is passed as a parameter to the relevant\nfunctions rather than stored  in the struct itself. The same allocator **must**\nbe used throughout the entire lifetime of an ArrayListAlignedUnmanaged.\nInitialize directly or with `initCapacity`, and deinitialize with `deinit` or use `toOwnedSlice`.","pl":"fn ArrayListAlignedUnmanaged(comptime T: type, comptime alignment: ?u29) type","sub_container_type":"struct ","src":408,"more_decls":{"doc_comment":"Contents of the list. Pointers to elements in this slice are\n**invalid after resizing operations** on the ArrayList, unless the\noperation explicitly either: (1) states otherwise or (2) lists the\ninvalidated pointers.\n\nThe allocator used determines how element pointers are\ninvalidated, so the behavior may vary between lists. To avoid\nillegal behavior, take into account the above paragraph plus the\nexplicit statements given in each method.","pl":"items: Slice = &[_]T{}","src":425,"more_decls":null}{"doc_comment":"How many T values this list can hold without allocating\nadditional memory.","pl":"capacity: usize = 0","src":428,"more_decls":null}{"doc_comment":"Initialize with capacity to hold at least num elements.\nDeinitialize with `deinit` or use `toOwnedSlice`.","pl":"fn initCapacity(allocator: *Allocator, num: usize) !Self","src":435,"more_decls":null}{"doc_comment":"Release all allocated memory.","pl":"pub fn deinit(self: *Self, allocator: *Allocator) void {\n    allocator.free(self.allocatedSlice());\n    self.* = undefined;\n}","src":446,"more_decls":null}{"doc_comment":"Convert this list into an analogous memory-managed one.\nThe returned list has ownership of the underlying memory.","pl":"pub fn toManaged(self: *Self, allocator: *Allocator) ArrayListAligned(T, alignment) {\n    return .{ .items = self.items, .capacity = self.capacity, .allocator = allocator };\n}","src":453,"more_decls":null}{"doc_comment":"The caller owns the returned memory. ArrayList becomes empty.","pl":"pub fn toOwnedSlice(self: *Self, allocator: *Allocator) Slice {\n    const result = allocator.shrink(self.allocatedSlice(), self.items.len);\n    self.* = Self{};\n    return result;\n}","src":458,"more_decls":null}{"doc_comment":"The caller owns the returned memory. ArrayList becomes empty.","pl":"pub fn toOwnedSliceSentinel(self: *Self, allocator: *Allocator, comptime sentinel: T) ![:sentinel]T {\n    try self.append(allocator, sentinel);\n    const result = self.toOwnedSlice(allocator);\n    return result[0 .. result.len - 1 :sentinel];\n}","src":465,"more_decls":null}{"doc_comment":"Insert `item` at index `n`. Moves `list[n .. list.len]`\nto higher indices to make room.\nThis operation is O(N).","pl":"fn insert(self: *Self, allocator: *Allocator, n: usize, item: T) !void","src":474,"more_decls":null}{"doc_comment":"Insert slice `items` at index `i`. Moves `list[i .. list.len]` to\nhigher indicices make room.\nThis operation is O(N).","pl":"fn insertSlice(self: *Self, allocator: *Allocator, i: usize, items: SliceConst) !void","src":485,"more_decls":null}{"doc_comment":"Replace range of elements `list[start..start+len]` with `new_items`\nGrows list if `len < new_items.len`.\nShrinks list if `len > new_items.len`\nInvalidates pointers if this ArrayList is resized.","pl":"pub fn replaceRange(self: *Self, allocator: *Allocator, start: usize, len: usize, new_items: SliceConst) !void {\n    var managed = self.toManaged(allocator);\n    try managed.replaceRange(start, len, new_items);\n    self.* = managed.toUnmanaged();\n}","src":497,"more_decls":null}{"doc_comment":"Extend the list by 1 element. Allocates more memory as necessary.","pl":"pub fn append(self: *Self, allocator: *Allocator, item: T) !void {\n    const new_item_ptr = try self.addOne(allocator);\n    new_item_ptr.* = item;\n}","src":504,"more_decls":null}{"doc_comment":"Extend the list by 1 element, but asserting `self.capacity`\nis sufficient to hold an additional item.","pl":"pub fn appendAssumeCapacity(self: *Self, item: T) void {\n    const new_item_ptr = self.addOneAssumeCapacity();\n    new_item_ptr.* = item;\n}","src":511,"more_decls":null}{"doc_comment":"Remove the element at index `i` from the list and return its value.\nAsserts the array has at least one item. Invalidates pointers to\nlast element.\nThis operation is O(N).","pl":"fn orderedRemove(self: *Self, i: usize) T","src":520,"more_decls":null}{"doc_comment":"Removes the element at the specified index and returns it.\nThe empty slot is filled from the end of the list.\nInvalidates pointers to last element.\nThis operation is O(1).","pl":"fn swapRemove(self: *Self, i: usize) T","src":535,"more_decls":null}{"doc_comment":"Append the slice of items to the list. Allocates more\nmemory as necessary.","pl":"pub fn appendSlice(self: *Self, allocator: *Allocator, items: SliceConst) !void {\n    try self.ensureCapacity(allocator, self.items.len + items.len);\n    self.appendSliceAssumeCapacity(items);\n}","src":545,"more_decls":null}{"doc_comment":"Append the slice of items to the list, asserting the capacity is enough\nto store the new items.","pl":"fn appendSliceAssumeCapacity(self: *Self, items: SliceConst) void","src":552,"more_decls":null}{"doc_comment":"Append a value to the list `n` times.\nAllocates more memory as necessary.","pl":"pub fn appendNTimes(self: *Self, allocator: *Allocator, value: T, n: usize) !void {\n    const old_len = self.items.len;\n    try self.resize(allocator, self.items.len + n);\n    mem.set(T, self.items[old_len..self.items.len], value);\n}","src":562,"more_decls":null}{"doc_comment":"Append a value to the list `n` times.\n**Does not** invalidate pointers.\nAsserts the capacity is enough.","pl":"pub fn appendNTimesAssumeCapacity(self: *Self, value: T, n: usize) void {\n    const new_len = self.items.len + n;\n    assert(new_len <= self.capacity);\n    mem.set(T, self.items.ptr[self.items.len..new_len], value);\n    self.items.len = new_len;\n}","src":571,"more_decls":null}{"doc_comment":"Adjust the list's length to `new_len`.\nDoes not initialize added items, if any.","pl":"pub fn resize(self: *Self, allocator: *Allocator, new_len: usize) !void {\n    try self.ensureCapacity(allocator, new_len);\n    self.items.len = new_len;\n}","src":580,"more_decls":null}{"doc_comment":"Reduce allocated capacity to `new_len`.","pl":"fn shrinkAndFree(self: *Self, allocator: *Allocator, new_len: usize) void","src":586,"more_decls":null}{"doc_comment":"Reduce length to `new_len`.\nInvalidates pointers to elements `items[new_len..]`.\nKeeps capacity the same.","pl":"pub fn shrinkRetainingCapacity(self: *Self, new_len: usize) void {\n    assert(new_len <= self.items.len);\n    self.items.len = new_len;\n}","src":601,"more_decls":null}{"doc_comment":"Modify the array so that it can hold at least `new_capacity` items.\nInvalidates pointers if additional memory is needed.","pl":"fn ensureCapacity(self: *Self, allocator: *Allocator, new_capacity: usize) !void","src":608,"more_decls":null}{"doc_comment":"Increases the array's length to match the full capacity that is already allocated.\nThe new elements have `undefined` values.\n**Does not** invalidate pointers.","pl":"pub fn expandToCapacity(self: *Self) void {\n    self.items.len = self.capacity;\n}","src":625,"more_decls":null}{"doc_comment":"Increase length by 1, returning pointer to the new item.\nThe returned pointer becomes invalid when the list resized.","pl":"pub fn addOne(self: *Self, allocator: *Allocator) !*T {\n    const newlen = self.items.len + 1;\n    try self.ensureCapacity(allocator, newlen);\n    return self.addOneAssumeCapacity();\n}","src":631,"more_decls":null}{"doc_comment":"Increase length by 1, returning pointer to the new item.\nAsserts that there is already space for the new item without allocating more.\n**Does not** invalidate pointers.\nThe returned pointer becomes invalid when the list resized.","pl":"pub fn addOneAssumeCapacity(self: *Self) *T {\n    assert(self.items.len < self.capacity);\n\n    self.items.len += 1;\n    return &self.items[self.items.len - 1];\n}","src":641,"more_decls":null}{"doc_comment":"Resize the array, adding `n` new elements, which have `undefined` values.\nThe return value is an array pointing to the newly allocated elements.\nThe returned pointer becomes invalid when the list is resized.","pl":"pub fn addManyAsArray(self: *Self, allocator: *Allocator, comptime n: usize) !*[n]T {\n    const prev_len = self.items.len;\n    try self.resize(allocator, self.items.len + n);\n    return self.items[prev_len..][0..n];\n}","src":651,"more_decls":null}{"doc_comment":"Resize the array, adding `n` new elements, which have `undefined` values.\nThe return value is an array pointing to the newly allocated elements.\nAsserts that there is already space for the new item without allocating more.\n**Does not** invalidate pointers.\nThe returned pointer becomes invalid when the list is resized.","pl":"pub fn addManyAsArrayAssumeCapacity(self: *Self, comptime n: usize) *[n]T {\n    assert(self.items.len + n <= self.capacity);\n    const prev_len = self.items.len;\n    self.items.len += n;\n    return self.items[prev_len..][0..n];\n}","src":662,"more_decls":null}{"doc_comment":"Remove and return the last element from the list.\nAsserts the list has at least one item.\nInvalidates pointers to last element.","pl":"pub fn pop(self: *Self) T {\n    const val = self.items[self.items.len - 1];\n    self.items.len -= 1;\n    return val;\n}","src":672,"more_decls":null}{"doc_comment":"Remove and return the last element from the list.\nIf the list is empty, returns `null`.\nInvalidates pointers to last element.","pl":"pub fn popOrNull(self: *Self) ?T {\n    if (self.items.len == 0) return null;\n    return self.pop();\n}","src":681,"more_decls":null}{"pl":"const Slice = if (alignment) |a| ([]align(a) T) else []T","src":430,"more_decls":null}{"pl":"const SliceConst = if (alignment) |a| ([]align(a) const T) else []const T","src":431,"more_decls":null}}]