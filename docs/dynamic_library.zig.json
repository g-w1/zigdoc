[{"pl":"pub const ElfDynLib = struct ","src":102,"more_decls":{"pl":"strings: [*:0]u8","src":103,"more_decls":null}{"pl":"syms: [*]elf.Sym","src":104,"more_decls":null}{"pl":"hashtab: [*]os.Elf_Symndx","src":105,"more_decls":null}{"pl":"versym: ?[*]u16","src":106,"more_decls":null}{"pl":"verdef: ?*elf.Verdef","src":107,"more_decls":null}{"pl":"memory: []align(mem.page_size) u8","src":108,"more_decls":null}{"doc_comment":"Trusts the file. Malicious file will be able to execute arbitrary code.","pl":"fn open(path: []const u8) !ElfDynLib","src":120,"more_decls":null}{"doc_comment":"Trusts the file. Malicious file will be able to execute arbitrary code.","pl":"pub fn openZ(path_c: [*:0]const u8) !ElfDynLib {\n    return open(mem.spanZ(path_c));\n}","src":258,"more_decls":null}{"doc_comment":"Trusts the file","pl":"pub fn close(self: *ElfDynLib) void {\n    os.munmap(self.memory);\n    self.* = undefined;\n}","src":263,"more_decls":null}{"pl":"fn lookup(self: *ElfDynLib, comptime T: type, name: [:0]const u8) ?T","src":268,"more_decls":null}{"doc_comment":"Returns the address of the symbol","pl":"fn lookupAddress(self: *const ElfDynLib, vername: []const u8, name: []const u8) ?usize","src":277,"more_decls":null}{"pl":"const Error = error{\n        NotElfFile,\n        NotDynamicLibrary,\n        MissingDynamicLinkingInformation,\n        ElfStringSectionNotFound,\n        ElfSymSectionNotFound,\n        ElfHashTableNotFound,\n    }","src":110,"more_decls":null}{"pl":"const openC = @compileError(\"deprecated: renamed to openZ\")","src":255,"more_decls":null}}{"pl":"pub const WindowsDynLib = struct ","src":322,"more_decls":{"pl":"dll: windows.HMODULE","src":325,"more_decls":null}{"pl":"pub fn open(path: []const u8) !WindowsDynLib {\n    const path_w = try windows.sliceToPrefixedFileW(path);\n    return openW(path_w.span().ptr);\n}","src":327,"more_decls":null}{"pl":"pub fn openZ(path_c: [*:0]const u8) !WindowsDynLib {\n    const path_w = try windows.cStrToPrefixedFileW(path_c);\n    return openW(path_w.span().ptr);\n}","src":334,"more_decls":null}{"pl":"fn openW(path_w: [*:0]const u16) !WindowsDynLib","src":339,"more_decls":null}{"pl":"pub fn close(self: *WindowsDynLib) void {\n    windows.FreeLibrary(self.dll);\n    self.* = undefined;\n}","src":351,"more_decls":null}{"pl":"fn lookup(self: *WindowsDynLib, comptime T: type, name: [:0]const u8) ?T","src":356,"more_decls":null}{"pl":"const Error = error{FileNotFound}","src":323,"more_decls":null}{"pl":"const openC = @compileError(\"deprecated: renamed to openZ\")","src":332,"more_decls":null}}{"pl":"pub const DlDynlib = struct ","src":365,"more_decls":{"pl":"handle: *c_void","src":368,"more_decls":null}{"pl":"pub fn open(path: []const u8) !DlDynlib {\n    const path_c = try os.toPosixPath(path);\n    return openZ(&path_c);\n}","src":370,"more_decls":null}{"pl":"fn openZ(path_c: [*:0]const u8) !DlDynlib","src":377,"more_decls":null}{"pl":"pub fn close(self: *DlDynlib) void {\n    _ = system.dlclose(self.handle);\n    self.* = undefined;\n}","src":385,"more_decls":null}{"pl":"fn lookup(self: *DlDynlib, comptime T: type, name: [:0]const u8) ?T","src":390,"more_decls":null}{"pl":"const Error = error{FileNotFound}","src":366,"more_decls":null}{"pl":"const openC = @compileError(\"deprecated: renamed to openZ\")","src":375,"more_decls":null}}{"doc_comment":"TODO make it possible to reference this same external symbol 2x so we don't need this\nhelper function.","pl":"pub fn get_DYNAMIC() ?[*]elf.Dyn {\n    return @extern([*]elf.Dyn, .{ .name = \"_DYNAMIC\", .linkage = .Weak });\n}","src":63,"more_decls":null}{"pl":"fn linkmap_iterator(phdrs: []elf.Phdr) !LinkMap.Iterator","src":67,"more_decls":null}{"pl":"const DynLib = switch (builtin.os.tag) {\n    .linux => if (builtin.link_libc) DlDynlib else ElfDynLib,\n    .windows => WindowsDynLib,\n    .macos, .tvos, .watchos, .ios, .freebsd, .openbsd => DlDynlib,\n    else => void,\n}","src":18,"more_decls":null}]