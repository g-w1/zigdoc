<style type="text/css" >
.more-decls {
    padding-left: 50px;
}
.anal-decl {
 background-color: #F7A41D77;
}
code {
 background-color: #F7A41D77;
}
</style><style type="text/css" >
pre > code {
  display: block;
  overflow: auto;
  padding: 0.5em;
  color: black;
}

details {
  margin-bottom: 0.5em;
  -webkit-touch-callout: none; /* iOS Safari */
    -webkit-user-select: none; /* Safari */
     -khtml-user-select: none; /* Konqueror HTML */
       -moz-user-select: none; /* Old versions of Firefox */
        -ms-user-select: none; /* Internet Explorer/Edge */
            user-select: none; /* Non-prefixed version, currently
                                  supported by Chrome, Edge, Opera and Firefox */
}

.tok {
  color: #333;
  font-style: normal;
}

.code {
  font-family: monospace;
  font-size: 0.8em;
}

.tok-kw {
  color: #333;
  font-weight: bold;
}

.tok-str {
  color: #d14;
}

.tok-builtin {
  color: #0086b3;
}

code.zig {
  color: #777;
  font-style: italic;
}

.tok-fn {
  color: #900;
  font-weight: bold;
}

.tok-null {
  color: #008080;
}

.tok-number {
  color: #008080;
}

.tok-type {
  color: #458;
  font-weight: bold;
}
</style><html><a href="null//array_hash_map.zig"><h1>/array_hash_map.zig</h1></a><div class="more-decls"></div><h2 style="color: orange;">types:</h2><div class="more-decls"><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">const</span> <span class="tok">StringContext</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">struct</span></code></pre><details><summary>funcs</summary><div class="md-funcs more-decls"><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">hash</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-builtin">@This</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">,</span> <span class="tok">s</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">u32</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">hashString</span><span class="tok tok-symbol">(</span><span class="tok">s</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">eql</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-builtin">@This</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">,</span> <span class="tok">a</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span><span class="tok tok-symbol">,</span> <span class="tok">b</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">eqlString</span><span class="tok tok-symbol">(</span><span class="tok">a</span><span class="tok tok-symbol">,</span> <span class="tok">b</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div></div></details></div></div><h2 style="color: orange;">funcs:</h2><div class="more-decls"><div class="anal-decl"><b>An ArrayHashMap with default hash and equal functions.
See AutoContext for a description of the hash and equal implementations.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">AutoArrayHashMap</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">K</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok tok-kw">comptime</span> <span class="tok">V</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">type</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">ArrayHashMap</span><span class="tok tok-symbol">(</span><span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">V</span><span class="tok tok-symbol">,</span> <span class="tok">AutoContext</span><span class="tok tok-symbol">(</span><span class="tok">K</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">,</span> <span class="tok tok-symbol">!</span><span class="tok">autoEqlIsCheap</span><span class="tok tok-symbol">(</span><span class="tok">K</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>An ArrayHashMapUnmanaged with default hash and equal functions.
See AutoContext for a description of the hash and equal implementations.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">AutoArrayHashMapUnmanaged</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">K</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok tok-kw">comptime</span> <span class="tok">V</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">type</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">ArrayHashMapUnmanaged</span><span class="tok tok-symbol">(</span><span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">V</span><span class="tok tok-symbol">,</span> <span class="tok">AutoContext</span><span class="tok tok-symbol">(</span><span class="tok">K</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">,</span> <span class="tok tok-symbol">!</span><span class="tok">autoEqlIsCheap</span><span class="tok tok-symbol">(</span><span class="tok">K</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Builtin hashmap for strings as keys.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">StringArrayHashMap</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">V</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">type</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">ArrayHashMap</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span><span class="tok tok-symbol">,</span> <span class="tok">V</span><span class="tok tok-symbol">,</span> <span class="tok">StringContext</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">true</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">StringArrayHashMapUnmanaged</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">V</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">type</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">ArrayHashMapUnmanaged</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span><span class="tok tok-symbol">,</span> <span class="tok">V</span><span class="tok tok-symbol">,</span> <span class="tok">StringContext</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">true</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">eqlString</span><span class="tok tok-symbol">(</span><span class="tok">a</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span><span class="tok tok-symbol">,</span> <span class="tok">b</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">mem</span><span class="tok tok-symbol">.</span><span class="tok">eql</span><span class="tok tok-symbol">(</span><span class="tok tok-type">u8</span><span class="tok tok-symbol">,</span> <span class="tok">a</span><span class="tok tok-symbol">,</span> <span class="tok">b</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">hashString</span><span class="tok tok-symbol">(</span><span class="tok">s</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">u32</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok tok-builtin">@truncate</span><span class="tok tok-symbol">(</span><span class="tok tok-type">u32</span><span class="tok tok-symbol">,</span> <span class="tok">std</span><span class="tok tok-symbol">.</span><span class="tok">hash</span><span class="tok tok-symbol">.</span><span class="tok">Wyhash</span><span class="tok tok-symbol">.</span><span class="tok">hash</span><span class="tok tok-symbol">(</span><span class="tok tok-number">0</span><span class="tok tok-symbol">,</span> <span class="tok">s</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Insertion order is preserved.
Deletions perform a &quot;swap removal&quot; on the entries list.
Modifying the hash map while iterating is allowed, however one must understand
the (well defined) behavior when mixing insertions and deletions with iteration.
For a hash map that can be initialized directly that does not store an Allocator
field, see `ArrayHashMapUnmanaged`.
When `store_hash` is `false`, this data structure is biased towards cheap `eql`
functions. It does not store each item's hash in the table. Setting `store_hash`
to `true` incurs slightly more memory cost by storing each key's hash in the table
but only has to call `eql` for hash collisions.
If typical operations (except iteration over entries) need to be faster, prefer
the alternative `std.HashMap`.
Context must be a struct type with two member functions:
hash(self, K) u32
eql(self, K, K) bool
Adapted variants of many functions are provided.  These variants
take a pseudo key instead of a key.  Their context must have the functions:
hash(self, PseudoKey) u32
eql(self, PseudoKey, K) bool
</b><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">ArrayHashMap</span><span class="tok tok-symbol">(</span>
    <span class="tok tok-kw">comptime</span> <span class="tok">K</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-kw">comptime</span> <span class="tok">V</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-kw">comptime</span> <span class="tok">Context</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-kw">comptime</span> <span class="tok">store_hash</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">bool</span><span class="tok tok-symbol">,</span>
<span class="tok tok-symbol">)</span> <span class="tok tok-type">type</span></code></pre><details><summary>fields:</summary><div class="md-fields more-decls"><div class="anal-decl"><pre><code class="zig"><span class="tok">unmanaged</span><span class="tok tok-symbol">:</span> <span class="tok">Unmanaged</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span></code></pre></div></div></details><details><summary>funcs</summary><div class="md-funcs more-decls"><div class="anal-decl"><b>Create an ArrayHashMap instance which will use a specified allocator.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">init</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">)</span> <span class="tok">Self</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call initContext instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">initContext</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">initContext</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok">Self</span></code></pre></div><div class="anal-decl"><b>Frees the backing allocation and leaves the map in an undefined state.
Note that this does not free keys or values.  You must take care of that
before calling this function, if it is needed.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">deinit</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">deinit</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocator</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">self</span><span class="tok tok-symbol">.*</span> <span class="tok tok-symbol">=</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Clears the map but retains the backing allocation for future use.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">clearRetainingCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">clearRetainingCapacity</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Clears the map and releases the backing allocation
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">clearAndFree</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">clearAndFree</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocator</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Returns the number of KV pairs stored in this map.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">count</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">usize</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">count</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Returns the backing array of keys in this map.
Modifying the map may invalidate this array.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">keys</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok">K</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">keys</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Returns the backing array of values in this map.
Modifying the map may invalidate this array.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">values</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok">V</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">values</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Returns an iterator over the pairs in this map.
Modifying the map may invalidate this iterator.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">iterator</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok tok-kw">const</span> <span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok">Iterator</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">iterator</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>If key exists this function cannot fail.
If there is an existing item with `key`, then the result
`Entry` pointer points to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the `Entry` pointer points to it. Caller should then initialize
the value (but not the key).
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">getOrPut</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok">GetOrPutResult</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">getOrPutContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">getOrPutAdapted</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok">GetOrPutResult</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">getOrPutContextAdapted</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>If there is an existing item with `key`, then the result
`Entry` pointer points to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the `Entry` pointer points to it. Caller should then initialize
the value (but not the key).
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">getOrPutAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok">GetOrPutResult</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">getOrPutAssumeCapacityContext</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">getOrPutAssumeCapacityAdapted</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok">GetOrPutResult</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">getOrPutAssumeCapacityAdapted</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">getOrPutValue</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok">GetOrPutResult</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">getOrPutValueContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Increases capacity, guaranteeing that insertions up until the
`expected_count` will not cause an allocation, and therefore cannot fail.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">ensureTotalCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">new_capacity</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">ensureTotalCapacityContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">new_capacity</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Increases capacity, guaranteeing that insertions up until
`additional_count` **more** items will not cause an allocation, and
therefore cannot fail.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">ensureUnusedCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">additional_count</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">ensureUnusedCapacityContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">additional_count</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Returns the number of total elements which may be present before it is
no longer guaranteed that no allocations will be performed.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">capacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">usize</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">capacity</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Clobbers any existing data. To detect if a put would clobber
existing data, see `getOrPut`.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">put</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">putContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Inserts a key-value pair into the hash map, asserting that no previous
entry with the same key is already present
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">putNoClobber</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">putNoClobberContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Asserts there is enough capacity to store the new key-value pair.
Clobbers any existing data. To detect if a put would clobber
existing data, see `getOrPutAssumeCapacity`.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">putAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">putAssumeCapacityContext</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Asserts there is enough capacity to store the new key-value pair.
Asserts that it does not clobber any existing data.
To detect if a put would clobber existing data, see `getOrPutAssumeCapacity`.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">putAssumeCapacityNoClobber</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">putAssumeCapacityNoClobberContext</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Inserts a new `Entry` into the hash map, returning the previous one, if any.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">fetchPut</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-symbol">?</span><span class="tok">KV</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">fetchPutContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Inserts a new `Entry` into the hash map, returning the previous one, if any.
If insertion happuns, asserts there is enough capacity without allocating.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">fetchPutAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">KV</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">fetchPutAssumeCapacityContext</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Finds pointers to the key and value storage associated with a key.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">getEntry</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">Entry</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">getEntryContext</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">getEntryAdapted</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">Entry</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">getEntryAdapted</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Finds the index in the `entries` array where a key is stored
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">getIndex</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok tok-type">usize</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">getIndexContext</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">getIndexAdapted</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok tok-type">usize</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">getIndexAdapted</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Find the value associated with a key
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">get</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">V</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">getContext</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">getAdapted</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">V</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">getAdapted</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Find a pointer to the value associated with a key
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">getPtr</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok tok-symbol">*</span><span class="tok">V</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">getPtrContext</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">getPtrAdapted</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok tok-symbol">*</span><span class="tok">V</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">getPtrAdapted</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Check whether a key is stored in the map
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">contains</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">containsContext</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">containsAdapted</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">containsAdapted</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>If there is an `Entry` with a matching key, it is deleted from
the hash map, and then returned from this function. The entry is
removed from the underlying array by swapping it with the last
element.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">fetchSwapRemove</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">KV</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">fetchSwapRemoveContext</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">fetchSwapRemoveAdapted</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">KV</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">fetchSwapRemoveContextAdapted</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>If there is an `Entry` with a matching key, it is deleted from
the hash map, and then returned from this function. The entry is
removed from the underlying array by shifting all elements forward
thereby maintaining the current ordering.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">fetchOrderedRemove</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">KV</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">fetchOrderedRemoveContext</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">fetchOrderedRemoveAdapted</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">KV</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">fetchOrderedRemoveContextAdapted</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>If there is an `Entry` with a matching key, it is deleted from
the hash map. The entry is removed from the underlying array
by swapping it with the last element.  Returns true if an entry
was removed, false otherwise.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">swapRemove</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">swapRemoveContext</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">swapRemoveAdapted</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">swapRemoveContextAdapted</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>If there is an `Entry` with a matching key, it is deleted from
the hash map. The entry is removed from the underlying array
by shifting all elements forward, thereby maintaining the
current ordering.  Returns true if an entry was removed, false otherwise.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">orderedRemove</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">orderedRemoveContext</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">orderedRemoveAdapted</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">orderedRemoveContextAdapted</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Deletes the item at the specified index in `entries` from
the hash map. The entry is removed from the underlying array
by swapping it with the last element.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">swapRemoveAt</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">index</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">swapRemoveAtContext</span><span class="tok tok-symbol">(</span><span class="tok">index</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Deletes the item at the specified index in `entries` from
the hash map. The entry is removed from the underlying array
by shifting all elements forward, thereby maintaining the
current ordering.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">orderedRemoveAt</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">index</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">orderedRemoveAtContext</span><span class="tok tok-symbol">(</span><span class="tok">index</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Create a copy of the hash map which can be modified separately.
The copy uses the same context and allocator as this instance.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">clone</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok">Self</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">var</span> <span class="tok">other</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">try</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">cloneContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">other</span><span class="tok tok-symbol">.</span><span class="tok">promoteContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Create a copy of the hash map which can be modified separately.
The copy uses the same context as this instance, but the specified
allocator.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">cloneWithAllocator</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok">Self</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">var</span> <span class="tok">other</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">try</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">cloneContext</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">other</span><span class="tok tok-symbol">.</span><span class="tok">promoteContext</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Create a copy of the hash map which can be modified separately.
The copy uses the same allocator as this instance, but the
specified context.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">cloneWithContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok">ArrayHashMap</span><span class="tok tok-symbol">(</span><span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">V</span><span class="tok tok-symbol">,</span> <span class="tok tok-builtin">@TypeOf</span><span class="tok tok-symbol">(</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">,</span> <span class="tok">store_hash</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">var</span> <span class="tok">other</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">try</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">cloneContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">other</span><span class="tok tok-symbol">.</span><span class="tok">promoteContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Create a copy of the hash map which can be modified separately.
The copy uses the specified allocator and context.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">cloneWithAllocatorAndContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok">ArrayHashMap</span><span class="tok tok-symbol">(</span><span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">V</span><span class="tok tok-symbol">,</span> <span class="tok tok-builtin">@TypeOf</span><span class="tok tok-symbol">(</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">,</span> <span class="tok">store_hash</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">var</span> <span class="tok">other</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">try</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">cloneContext</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">other</span><span class="tok tok-symbol">.</span><span class="tok">promoteContext</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Rebuilds the key indexes. If the underlying entries has been modified directly, users
can call `reIndex` to update the indexes to account for these new entries.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">reIndex</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">reIndexContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Shrinks the underlying `Entry` array to `new_len` elements and discards any associated
index entries. Keeps capacity the same.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">shrinkRetainingCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">new_len</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">shrinkRetainingCapacityContext</span><span class="tok tok-symbol">(</span><span class="tok">new_len</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Shrinks the underlying `Entry` array to `new_len` elements and discards any associated
index entries. Reduces allocated capacity.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">shrinkAndFree</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">new_len</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">shrinkAndFreeContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">new_len</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Removes the last inserted `Entry` in the hash map and returns it.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">pop</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok">KV</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">popContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div></div></details><details><summary>values:</summary><div class="md-vals more-decls"><div class="anal-decl"><b>The ArrayHashMapUnmanaged type using the same settings as this managed map.
</b><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">Unmanaged</span> <span class="tok tok-symbol">=</span> <span class="tok">ArrayHashMapUnmanaged</span><span class="tok tok-symbol">(</span><span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">V</span><span class="tok tok-symbol">,</span> <span class="tok">Context</span><span class="tok tok-symbol">,</span> <span class="tok">store_hash</span><span class="tok tok-symbol">)</span></code></pre></div><div class="anal-decl"><b>Pointers to a key and value in the backing store of this map.
Modifying the key is allowed only if it does not change the hash.
Modifying the value is allowed.
Entry pointers become invalid whenever this ArrayHashMap is modified,
unless `ensureCapacity` was previously used.
</b><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">Entry</span> <span class="tok tok-symbol">=</span> <span class="tok">Unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">Entry</span></code></pre></div><div class="anal-decl"><b>A KV pair which has been copied out of the backing store
</b><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">KV</span> <span class="tok tok-symbol">=</span> <span class="tok">Unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">KV</span></code></pre></div><div class="anal-decl"><b>The Data type used for the MultiArrayList backing this map
</b><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">Data</span> <span class="tok tok-symbol">=</span> <span class="tok">Unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">Data</span></code></pre></div><div class="anal-decl"><b>The MultiArrayList type backing this map
</b><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">DataList</span> <span class="tok tok-symbol">=</span> <span class="tok">Unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">DataList</span></code></pre></div><div class="anal-decl"><b>The stored hash type, either u32 or void.
</b><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">Hash</span> <span class="tok tok-symbol">=</span> <span class="tok">Unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">Hash</span></code></pre></div><div class="anal-decl"><b>getOrPut variants return this structure, with pointers
to the backing store and a flag to indicate whether an
existing entry was found.
Modifying the key is allowed only if it does not change the hash.
Modifying the value is allowed.
Entry pointers become invalid whenever this ArrayHashMap is modified,
unless `ensureCapacity` was previously used.
</b><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">GetOrPutResult</span> <span class="tok tok-symbol">=</span> <span class="tok">Unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">GetOrPutResult</span></code></pre></div><div class="anal-decl"><b>An Iterator over Entry pointers.
</b><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">Iterator</span> <span class="tok tok-symbol">=</span> <span class="tok">Unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">Iterator</span></code></pre></div><div class="anal-decl"><b>Deprecated: call `ensureUnusedCapacity` or `ensureTotalCapacity`.
</b><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">ensureCapacity</span> <span class="tok tok-symbol">=</span> <span class="tok">ensureTotalCapacity</span></code></pre></div></div></details></div><div class="anal-decl"><b>General purpose hash table.
Insertion order is preserved.
Deletions perform a &quot;swap removal&quot; on the entries list.
Modifying the hash map while iterating is allowed, however one must understand
the (well defined) behavior when mixing insertions and deletions with iteration.
This type does not store an Allocator field - the Allocator must be passed in
with each function call that requires it. See `ArrayHashMap` for a type that stores
an Allocator field for convenience.
Can be initialized directly using the default field values.
This type is designed to have low overhead for small numbers of entries. When
`store_hash` is `false` and the number of entries in the map is less than 9,
the overhead cost of using `ArrayHashMapUnmanaged` rather than `std.ArrayList` is
only a single pointer-sized integer.
When `store_hash` is `false`, this data structure is biased towards cheap `eql`
functions. It does not store each item's hash in the table. Setting `store_hash`
to `true` incurs slightly more memory cost by storing each key's hash in the table
but guarantees only one call to `eql` per insertion/deletion.
Context must be a struct type with two member functions:
hash(self, K) u32
eql(self, K, K) bool
Adapted variants of many functions are provided.  These variants
take a pseudo key instead of a key.  Their context must have the functions:
hash(self, PseudoKey) u32
eql(self, PseudoKey, K) bool
</b><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">ArrayHashMapUnmanaged</span><span class="tok tok-symbol">(</span>
    <span class="tok tok-kw">comptime</span> <span class="tok">K</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-kw">comptime</span> <span class="tok">V</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-kw">comptime</span> <span class="tok">Context</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-kw">comptime</span> <span class="tok">store_hash</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">bool</span><span class="tok tok-symbol">,</span>
<span class="tok tok-symbol">)</span> <span class="tok tok-type">type</span></code></pre><details><summary>fields:</summary><div class="md-fields more-decls"><div class="anal-decl"><b>It is permitted to access this field directly.
</b><pre><code class="zig"><span class="tok">entries</span><span class="tok tok-symbol">:</span> <span class="tok">DataList</span> <span class="tok tok-symbol">=</span> <span class="tok tok-symbol">.</span><span class="tok tok-symbol">{</span><span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>When entries length is less than `linear_scan_max`, this remains `null`.
Once entries length grows big enough, this field is allocated. There is
an IndexHeader followed by an array of Index(I) structs, where I is defined
by how many total indexes there are.
</b><pre><code class="zig"><span class="tok">index_header</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">?</span><span class="tok tok-symbol">*</span><span class="tok">IndexHeader</span> <span class="tok tok-symbol">=</span> <span class="tok tok-null">null</span></code></pre></div></div></details><details><summary>types:</summary><div class="md-types more-decls"><div class="anal-decl"><b>Modifying the key is allowed only if it does not change the hash.
Modifying the value is allowed.
Entry pointers become invalid whenever this ArrayHashMap is modified,
unless `ensureCapacity` was previously used.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">const</span> <span class="tok">Entry</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">struct</span></code></pre><details><summary>fields:</summary><div class="md-fields more-decls"><div class="anal-decl"><pre><code class="zig"><span class="tok">key_ptr</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">K</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok">value_ptr</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">V</span></code></pre></div></div></details></div><div class="anal-decl"><b>A KV pair which has been copied out of the backing store
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">const</span> <span class="tok">KV</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">struct</span></code></pre><details><summary>fields:</summary><div class="md-fields more-decls"><div class="anal-decl"><pre><code class="zig"><span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span></code></pre></div></div></details></div><div class="anal-decl"><b>The Data type used for the MultiArrayList backing this map
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">const</span> <span class="tok">Data</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">struct</span></code></pre><details><summary>fields:</summary><div class="md-fields more-decls"><div class="anal-decl"><pre><code class="zig"><span class="tok">hash</span><span class="tok tok-symbol">:</span> <span class="tok">Hash</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span></code></pre></div></div></details></div><div class="anal-decl"><b>getOrPut variants return this structure, with pointers
to the backing store and a flag to indicate whether an
existing entry was found.
Modifying the key is allowed only if it does not change the hash.
Modifying the value is allowed.
Entry pointers become invalid whenever this ArrayHashMap is modified,
unless `ensureCapacity` was previously used.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">const</span> <span class="tok">GetOrPutResult</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">struct</span></code></pre><details><summary>fields:</summary><div class="md-fields more-decls"><div class="anal-decl"><pre><code class="zig"><span class="tok">key_ptr</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">K</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok">value_ptr</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">V</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok">found_existing</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">bool</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok">index</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span></code></pre></div></div></details></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">const</span> <span class="tok">Iterator</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">struct</span></code></pre><details><summary>fields:</summary><div class="md-fields more-decls"><div class="anal-decl"><pre><code class="zig"><span class="tok">keys</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">*</span><span class="tok tok-symbol">]</span><span class="tok">K</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok">values</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">*</span><span class="tok tok-symbol">]</span><span class="tok">V</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok">len</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">u32</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok">index</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">u32</span> <span class="tok tok-symbol">=</span> <span class="tok tok-number">0</span></code></pre></div></div></details><details><summary>funcs</summary><div class="md-funcs more-decls"><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">next</span><span class="tok tok-symbol">(</span><span class="tok">it</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Iterator</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">Entry</span></code></pre></div><div class="anal-decl"><b>Reset the iterator to the initial index
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">reset</span><span class="tok tok-symbol">(</span><span class="tok">it</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Iterator</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok">it</span><span class="tok tok-symbol">.</span><span class="tok">index</span> <span class="tok tok-symbol">=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div></div></details></div></div></details><details><summary>funcs</summary><div class="md-funcs more-decls"><div class="anal-decl"><b>Convert from an unmanaged map to a managed map.  After calling this,
the promoted map should no longer be used.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">promote</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">)</span> <span class="tok">Managed</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call promoteContext instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">promoteContext</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">promoteContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok">Managed</span></code></pre></div><div class="anal-decl"><b>Frees the backing allocation and leaves the map in an undefined state.
Note that this does not free keys or values.  You must take care of that
before calling this function, if it is needed.
</b><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">deinit</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>Clears the map but retains the backing allocation for future use.
</b><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">clearRetainingCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>Clears the map and releases the backing allocation
</b><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">clearAndFree</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>Returns the number of KV pairs stored in this map.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">count</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">usize</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">entries</span><span class="tok tok-symbol">.</span><span class="tok">len</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Returns the backing array of keys in this map.
Modifying the map may invalidate this array.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">keys</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok">K</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">entries</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">.</span><span class="tok">key</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Returns the backing array of values in this map.
Modifying the map may invalidate this array.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">values</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok">V</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">entries</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">.</span><span class="tok">value</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Returns an iterator over the pairs in this map.
Modifying the map may invalidate this iterator.
</b><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">iterator</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok">Iterator</span></code></pre></div><div class="anal-decl"><b>If key exists this function cannot fail.
If there is an existing item with `key`, then the result
`Entry` pointer points to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the `Entry` pointer points to it. Caller should then initialize
the value (but not the key).
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">getOrPut</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok">GetOrPutResult</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call getOrPutContext instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">getOrPutContext</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">getOrPutContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok">GetOrPutResult</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">getOrPutAdapted</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">key_ctx</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok">GetOrPutResult</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call getOrPutContextAdapted instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">getOrPutContextAdapted</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">key_ctx</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">getOrPutContextAdapted</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">key_ctx</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok">GetOrPutResult</span></code></pre></div><div class="anal-decl"><b>If there is an existing item with `key`, then the result
`Entry` pointer points to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the `Entry` pointer points to it. Caller should then initialize
the value (but not the key).
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">getOrPutAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok">GetOrPutResult</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call getOrPutAssumeCapacityContext instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">getOrPutAssumeCapacityContext</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">getOrPutAssumeCapacityContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok">GetOrPutResult</span></code></pre></div><div class="anal-decl"><b>If there is an existing item with `key`, then the result
`Entry` pointers point to it, and found_existing is true.
Otherwise, puts a new item with undefined key and value, and
the `Entry` pointers point to it. Caller must then initialize
both the key and the value.
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.
</b><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">getOrPutAssumeCapacityAdapted</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok">GetOrPutResult</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">getOrPutValue</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok">GetOrPutResult</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call getOrPutValueContext instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">getOrPutValueContext</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">getOrPutValueContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok">GetOrPutResult</span></code></pre></div><div class="anal-decl"><b>Increases capacity, guaranteeing that insertions up until the
`expected_count` will not cause an allocation, and therefore cannot fail.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">ensureTotalCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">new_capacity</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">ByIndexContext</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call ensureTotalCapacityContext instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ensureTotalCapacityContext</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">new_capacity</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">ensureTotalCapacityContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">new_capacity</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>Increases capacity, guaranteeing that insertions up until
`additional_count` **more** items will not cause an allocation, and
therefore cannot fail.
</b><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">ensureUnusedCapacity</span><span class="tok tok-symbol">(</span>
    <span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span>
    <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span>
    <span class="tok">additional_capacity</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span>
<span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">ensureUnusedCapacityContext</span><span class="tok tok-symbol">(</span>
    <span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span>
    <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span>
    <span class="tok">additional_capacity</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span>
    <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">,</span>
<span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>Returns the number of total elements which may be present before it is
no longer guaranteed that no allocations will be performed.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">capacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">usize</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">entry_cap</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">entries</span><span class="tok tok-symbol">.</span><span class="tok">capacity</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">const</span> <span class="tok">header</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">index_header</span> <span class="tok tok-kw">orelse</span> <span class="tok tok-kw">return</span> <span class="tok">math</span><span class="tok tok-symbol">.</span><span class="tok">min</span><span class="tok tok-symbol">(</span><span class="tok">linear_scan_max</span><span class="tok tok-symbol">,</span> <span class="tok">entry_cap</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">const</span> <span class="tok">indexes_cap</span> <span class="tok tok-symbol">=</span> <span class="tok">header</span><span class="tok tok-symbol">.</span><span class="tok">capacity</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">math</span><span class="tok tok-symbol">.</span><span class="tok">min</span><span class="tok tok-symbol">(</span><span class="tok">entry_cap</span><span class="tok tok-symbol">,</span> <span class="tok">indexes_cap</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Clobbers any existing data. To detect if a put would clobber
existing data, see `getOrPut`.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">put</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call putContext instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">putContext</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">putContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">result</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">try</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">getOrPutContext</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">result</span><span class="tok tok-symbol">.</span><span class="tok">value_ptr</span><span class="tok tok-symbol">.*</span> <span class="tok tok-symbol">=</span> <span class="tok">value</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Inserts a key-value pair into the hash map, asserting that no previous
entry with the same key is already present
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">putNoClobber</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call putNoClobberContext instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">putNoClobberContext</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">putNoClobberContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">result</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">try</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">getOrPutContext</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">assert</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">!</span><span class="tok">result</span><span class="tok tok-symbol">.</span><span class="tok">found_existing</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">result</span><span class="tok tok-symbol">.</span><span class="tok">value_ptr</span><span class="tok tok-symbol">.*</span> <span class="tok tok-symbol">=</span> <span class="tok">value</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Asserts there is enough capacity to store the new key-value pair.
Clobbers any existing data. To detect if a put would clobber
existing data, see `getOrPutAssumeCapacity`.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">putAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call putAssumeCapacityContext instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">putAssumeCapacityContext</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">putAssumeCapacityContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">result</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">getOrPutAssumeCapacityContext</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">result</span><span class="tok tok-symbol">.</span><span class="tok">value_ptr</span><span class="tok tok-symbol">.*</span> <span class="tok tok-symbol">=</span> <span class="tok">value</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Asserts there is enough capacity to store the new key-value pair.
Asserts that it does not clobber any existing data.
To detect if a put would clobber existing data, see `getOrPutAssumeCapacity`.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">putAssumeCapacityNoClobber</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call putAssumeCapacityNoClobberContext instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">putAssumeCapacityNoClobberContext</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">putAssumeCapacityNoClobberContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">result</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">getOrPutAssumeCapacityContext</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">assert</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">!</span><span class="tok">result</span><span class="tok tok-symbol">.</span><span class="tok">found_existing</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">result</span><span class="tok tok-symbol">.</span><span class="tok">value_ptr</span><span class="tok tok-symbol">.*</span> <span class="tok tok-symbol">=</span> <span class="tok">value</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Inserts a new `Entry` into the hash map, returning the previous one, if any.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">fetchPut</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-symbol">?</span><span class="tok">KV</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call fetchPutContext instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">fetchPutContext</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">fetchPutContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-symbol">?</span><span class="tok">KV</span></code></pre></div><div class="anal-decl"><b>Inserts a new `Entry` into the hash map, returning the previous one, if any.
If insertion happens, asserts there is enough capacity without allocating.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">fetchPutAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">KV</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call fetchPutAssumeCapacityContext instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">fetchPutAssumeCapacityContext</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">fetchPutAssumeCapacityContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">KV</span></code></pre></div><div class="anal-decl"><b>Finds pointers to the key and value storage associated with a key.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">getEntry</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">Entry</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call getEntryContext instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">getEntryContext</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">getEntryContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">Entry</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">getEntryAdapted</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">getEntryAdapted</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">Entry</span></code></pre></div><div class="anal-decl"><b>Finds the index in the `entries` array where a key is stored
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">getIndex</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok tok-type">usize</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call getIndexContext instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">getIndexContext</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">getIndexContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok tok-type">usize</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">getIndexAdapted</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">getIndexAdapted</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok tok-type">usize</span></code></pre></div><div class="anal-decl"><b>Find the value associated with a key
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">get</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">V</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call getContext instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">getContext</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">getContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">V</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">getAdapted</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">getAdapted</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">V</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">index</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">getIndexAdapted</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">)</span> <span class="tok tok-kw">orelse</span> <span class="tok tok-kw">return</span> <span class="tok tok-null">null</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">values</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">[</span><span class="tok">index</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Find a pointer to the value associated with a key
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">getPtr</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok tok-symbol">*</span><span class="tok">V</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call getPtrContext instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">getPtrContext</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">getPtrContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok tok-symbol">*</span><span class="tok">V</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">getPtrAdapted</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">getPtrAdapted</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok tok-symbol">*</span><span class="tok">V</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">index</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">getIndexAdapted</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">)</span> <span class="tok tok-kw">orelse</span> <span class="tok tok-kw">return</span> <span class="tok tok-null">null</span><span class="tok tok-symbol">;</span>
    // workaround for #6974
    <span class="tok tok-kw">return</span> <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">*</span><span class="tok">V</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">==</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span> <span class="tok tok-builtin">@as</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">*</span><span class="tok">V</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span> <span class="tok tok-kw">else</span> <span class="tok tok-symbol">&amp;</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">values</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">[</span><span class="tok">index</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Check whether a key is stored in the map
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">contains</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call containsContext instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">containsContext</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">containsContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">containsAdapted</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">containsAdapted</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">getIndexAdapted</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-null">null</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>If there is an `Entry` with a matching key, it is deleted from
the hash map, and then returned from this function. The entry is
removed from the underlying array by swapping it with the last
element.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">fetchSwapRemove</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">KV</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call fetchSwapRemoveContext instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">fetchSwapRemoveContext</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">fetchSwapRemoveContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">KV</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">fetchSwapRemoveContextAdapted</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">fetchSwapRemoveAdapted</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">KV</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">ByIndexContext</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call fetchSwapRemoveContextAdapted instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">fetchSwapRemoveContextAdapted</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">fetchSwapRemoveContextAdapted</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">key_ctx</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">KV</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">fetchRemoveByKey</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">key_ctx</span><span class="tok tok-symbol">,</span> <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok">store_hash</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span><span class="tok tok-symbol">}</span> <span class="tok tok-kw">else</span> <span class="tok">ctx</span><span class="tok tok-symbol">,</span> <span class="tok tok-symbol">.</span><span class="tok">swap</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>If there is an `Entry` with a matching key, it is deleted from
the hash map, and then returned from this function. The entry is
removed from the underlying array by shifting all elements forward
thereby maintaining the current ordering.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">fetchOrderedRemove</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">KV</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call fetchOrderedRemoveContext instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">fetchOrderedRemoveContext</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">fetchOrderedRemoveContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">KV</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">fetchOrderedRemoveContextAdapted</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">fetchOrderedRemoveAdapted</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">KV</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">ByIndexContext</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call fetchOrderedRemoveContextAdapted instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">fetchOrderedRemoveContextAdapted</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">fetchOrderedRemoveContextAdapted</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">key_ctx</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">KV</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">fetchRemoveByKey</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">key_ctx</span><span class="tok tok-symbol">,</span> <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok">store_hash</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span><span class="tok tok-symbol">}</span> <span class="tok tok-kw">else</span> <span class="tok">ctx</span><span class="tok tok-symbol">,</span> <span class="tok tok-symbol">.</span><span class="tok">ordered</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>If there is an `Entry` with a matching key, it is deleted from
the hash map. The entry is removed from the underlying array
by swapping it with the last element.  Returns true if an entry
was removed, false otherwise.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">swapRemove</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call swapRemoveContext instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">swapRemoveContext</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">swapRemoveContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">swapRemoveContextAdapted</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">swapRemoveAdapted</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">ByIndexContext</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call swapRemoveContextAdapted instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">swapRemoveContextAdapted</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">swapRemoveContextAdapted</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">key_ctx</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">removeByKey</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">key_ctx</span><span class="tok tok-symbol">,</span> <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok">store_hash</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span><span class="tok tok-symbol">}</span> <span class="tok tok-kw">else</span> <span class="tok">ctx</span><span class="tok tok-symbol">,</span> <span class="tok tok-symbol">.</span><span class="tok">swap</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>If there is an `Entry` with a matching key, it is deleted from
the hash map. The entry is removed from the underlying array
by shifting all elements forward, thereby maintaining the
current ordering.  Returns true if an entry was removed, false otherwise.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">orderedRemove</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call orderedRemoveContext instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">orderedRemoveContext</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">orderedRemoveContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">orderedRemoveContextAdapted</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">orderedRemoveAdapted</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">ByIndexContext</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call orderedRemoveContextAdapted instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">orderedRemoveContextAdapted</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">orderedRemoveContextAdapted</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">key_ctx</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">removeByKey</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">key_ctx</span><span class="tok tok-symbol">,</span> <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok">store_hash</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span><span class="tok tok-symbol">}</span> <span class="tok tok-kw">else</span> <span class="tok">ctx</span><span class="tok tok-symbol">,</span> <span class="tok tok-symbol">.</span><span class="tok">ordered</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Deletes the item at the specified index in `entries` from
the hash map. The entry is removed from the underlying array
by swapping it with the last element.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">swapRemoveAt</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">index</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">ByIndexContext</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call swapRemoveAtContext instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">swapRemoveAtContext</span><span class="tok tok-symbol">(</span><span class="tok">index</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">swapRemoveAtContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">index</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">removeByIndex</span><span class="tok tok-symbol">(</span><span class="tok">index</span><span class="tok tok-symbol">,</span> <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok">store_hash</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span><span class="tok tok-symbol">}</span> <span class="tok tok-kw">else</span> <span class="tok">ctx</span><span class="tok tok-symbol">,</span> <span class="tok tok-symbol">.</span><span class="tok">swap</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Deletes the item at the specified index in `entries` from
the hash map. The entry is removed from the underlying array
by shifting all elements forward, thereby maintaining the
current ordering.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">orderedRemoveAt</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">index</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">ByIndexContext</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call orderedRemoveAtContext instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">orderedRemoveAtContext</span><span class="tok tok-symbol">(</span><span class="tok">index</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">orderedRemoveAtContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">index</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">removeByIndex</span><span class="tok tok-symbol">(</span><span class="tok">index</span><span class="tok tok-symbol">,</span> <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok">store_hash</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span><span class="tok tok-symbol">}</span> <span class="tok tok-kw">else</span> <span class="tok">ctx</span><span class="tok tok-symbol">,</span> <span class="tok tok-symbol">.</span><span class="tok">ordered</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Create a copy of the hash map which can be modified separately.
The copy uses the same context and allocator as this instance.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">clone</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok">Self</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">ByIndexContext</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call cloneContext instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">cloneContext</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">cloneContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok">Self</span></code></pre></div><div class="anal-decl"><b>Rebuilds the key indexes. If the underlying entries has been modified directly, users
can call `reIndex` to update the indexes to account for these new entries.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">reIndex</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">ByIndexContext</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call reIndexContext instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">reIndexContext</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">reIndexContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>Shrinks the underlying `Entry` array to `new_len` elements and discards any associated
index entries. Keeps capacity the same.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">shrinkRetainingCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">new_len</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">ByIndexContext</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call shrinkRetainingCapacityContext instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">shrinkRetainingCapacityContext</span><span class="tok tok-symbol">(</span><span class="tok">new_len</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">shrinkRetainingCapacityContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">new_len</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>Shrinks the underlying `Entry` array to `new_len` elements and discards any associated
index entries. Reduces allocated capacity.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">shrinkAndFree</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">new_len</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">ByIndexContext</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call shrinkAndFreeContext instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">shrinkAndFreeContext</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">new_len</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">shrinkAndFreeContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">new_len</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>Removes the last inserted `Entry` in the hash map and returns it.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">pop</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok">KV</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok">ByIndexContext</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;Cannot infer context &quot;</span> <span class="tok tok-symbol">++</span> <span class="tok tok-builtin">@typeName</span><span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">++</span> <span class="tok tok-str">&quot;, call popContext instead.&quot;</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">popContext</span><span class="tok tok-symbol">(</span><span class="tok tok-null">undefined</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">popContext</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">ctx</span><span class="tok tok-symbol">:</span> <span class="tok">Context</span><span class="tok tok-symbol">)</span> <span class="tok">KV</span></code></pre></div></div></details><details><summary>values:</summary><div class="md-vals more-decls"><div class="anal-decl"><b>The MultiArrayList type backing this map
</b><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">DataList</span> <span class="tok tok-symbol">=</span> <span class="tok">std</span><span class="tok tok-symbol">.</span><span class="tok">MultiArrayList</span><span class="tok tok-symbol">(</span><span class="tok">Data</span><span class="tok tok-symbol">)</span></code></pre></div><div class="anal-decl"><b>The stored hash type, either u32 or void.
</b><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">Hash</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok">store_hash</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">u32</span> <span class="tok tok-kw">else</span> <span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>The ArrayHashMap type using the same settings as this managed map.
</b><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">Managed</span> <span class="tok tok-symbol">=</span> <span class="tok">ArrayHashMap</span><span class="tok tok-symbol">(</span><span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">V</span><span class="tok tok-symbol">,</span> <span class="tok">Context</span><span class="tok tok-symbol">,</span> <span class="tok">store_hash</span><span class="tok tok-symbol">)</span></code></pre></div><div class="anal-decl"><b>Deprecated: call `ensureUnusedCapacity` or `ensureTotalCapacity`.
</b><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">ensureCapacity</span> <span class="tok tok-symbol">=</span> <span class="tok">ensureTotalCapacity</span></code></pre></div></div></details></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">getHashPtrAddrFn</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">K</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok tok-kw">comptime</span> <span class="tok">Context</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">(</span><span class="tok tok-kw">fn</span> <span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">,</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">u32</span><span class="tok tok-symbol">)</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">getTrivialEqlFn</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">K</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok tok-kw">comptime</span> <span class="tok">Context</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">(</span><span class="tok tok-kw">fn</span> <span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">,</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span><span class="tok tok-symbol">)</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">AutoContext</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">K</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">type</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok tok-kw">struct</span> <span class="tok tok-symbol">{</span>
        <span class="tok tok-kw">pub</span> <span class="tok tok-kw">const</span> <span class="tok">hash</span> <span class="tok tok-symbol">=</span> <span class="tok">getAutoHashFn</span><span class="tok tok-symbol">(</span><span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok tok-builtin">@This</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
        <span class="tok tok-kw">pub</span> <span class="tok tok-kw">const</span> <span class="tok">eql</span> <span class="tok tok-symbol">=</span> <span class="tok">getAutoEqlFn</span><span class="tok tok-symbol">(</span><span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok tok-builtin">@This</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-symbol">}</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">getAutoHashFn</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">K</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok tok-kw">comptime</span> <span class="tok">Context</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">(</span><span class="tok tok-kw">fn</span> <span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">,</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">u32</span><span class="tok tok-symbol">)</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">getAutoEqlFn</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">K</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok tok-kw">comptime</span> <span class="tok">Context</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">(</span><span class="tok tok-kw">fn</span> <span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">,</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span><span class="tok tok-symbol">)</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">autoEqlIsCheap</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">K</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">getAutoHashStratFn</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">K</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok tok-kw">comptime</span> <span class="tok">Context</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok tok-kw">comptime</span> <span class="tok">strategy</span><span class="tok tok-symbol">:</span> <span class="tok">std</span><span class="tok tok-symbol">.</span><span class="tok">hash</span><span class="tok tok-symbol">.</span><span class="tok">Strategy</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">(</span><span class="tok tok-kw">fn</span> <span class="tok tok-symbol">(</span><span class="tok">Context</span><span class="tok tok-symbol">,</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">u32</span><span class="tok tok-symbol">)</span></code></pre></div></div><div class="more-decls"></div></html>