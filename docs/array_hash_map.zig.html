<style type="text/css" >
.more-decls {
    padding-left: 50px;
}
.anal-decl {
 background-color: #F7A41D77;
}
code {
 background-color: #F7A41D77;
}
</style><style type="text/css" >
pre > code {
  display: block;
  overflow: auto;
  padding: 0.5em;
  color: black;
}

details {
  margin-bottom: 0.5em;
  -webkit-touch-callout: none; /* iOS Safari */
    -webkit-user-select: none; /* Safari */
     -khtml-user-select: none; /* Konqueror HTML */
       -moz-user-select: none; /* Old versions of Firefox */
        -ms-user-select: none; /* Internet Explorer/Edge */
            user-select: none; /* Non-prefixed version, currently
                                  supported by Chrome, Edge, Opera and Firefox */
}

.tok {
  color: #333;
  font-style: normal;
}

.code {
  font-family: monospace;
  font-size: 0.8em;
}

.tok-kw {
  color: #333;
  font-weight: bold;
}

.tok-str {
  color: #d14;
}

.tok-builtin {
  color: #0086b3;
}

code.zig {
  color: #777;
  font-style: italic;
}

.tok-fn {
  color: #900;
  font-weight: bold;
}

.tok-null {
  color: #008080;
}

.tok-number {
  color: #008080;
}

.tok-type {
  color: #458;
  font-weight: bold;
}
</style><html><a href="https://github.com/ziglang/zig/blob/master/lib/std//array_hash_map.zig"><h1>/array_hash_map.zig</h1></a><div class="more-decls"></div><div class="more-decls"></div><h2 style="color: orange;">funcs:</h2><div class="more-decls"><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L20">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">AutoArrayHashMap</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">K</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok tok-kw">comptime</span> <span class="tok">V</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">type</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">ArrayHashMap</span><span class="tok tok-symbol">(</span><span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">V</span><span class="tok tok-symbol">,</span> <span class="tok">getAutoHashFn</span><span class="tok tok-symbol">(</span><span class="tok">K</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">,</span> <span class="tok">getAutoEqlFn</span><span class="tok tok-symbol">(</span><span class="tok">K</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">,</span> <span class="tok">autoEqlIsCheap</span><span class="tok tok-symbol">(</span><span class="tok">K</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L24">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">AutoArrayHashMapUnmanaged</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">K</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok tok-kw">comptime</span> <span class="tok">V</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">type</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">ArrayHashMapUnmanaged</span><span class="tok tok-symbol">(</span><span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">V</span><span class="tok tok-symbol">,</span> <span class="tok">getAutoHashFn</span><span class="tok tok-symbol">(</span><span class="tok">K</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">,</span> <span class="tok">getAutoEqlFn</span><span class="tok tok-symbol">(</span><span class="tok">K</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">,</span> <span class="tok">autoEqlIsCheap</span><span class="tok tok-symbol">(</span><span class="tok">K</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Builtin hashmap for strings as keys.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L29">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">StringArrayHashMap</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">V</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">type</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">ArrayHashMap</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span><span class="tok tok-symbol">,</span> <span class="tok">V</span><span class="tok tok-symbol">,</span> <span class="tok">hashString</span><span class="tok tok-symbol">,</span> <span class="tok">eqlString</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">true</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L33">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">StringArrayHashMapUnmanaged</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">V</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">type</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">ArrayHashMapUnmanaged</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span><span class="tok tok-symbol">,</span> <span class="tok">V</span><span class="tok tok-symbol">,</span> <span class="tok">hashString</span><span class="tok tok-symbol">,</span> <span class="tok">eqlString</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">true</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L37">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">eqlString</span><span class="tok tok-symbol">(</span><span class="tok">a</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span><span class="tok tok-symbol">,</span> <span class="tok">b</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">mem</span><span class="tok tok-symbol">.</span><span class="tok">eql</span><span class="tok tok-symbol">(</span><span class="tok tok-type">u8</span><span class="tok tok-symbol">,</span> <span class="tok">a</span><span class="tok tok-symbol">,</span> <span class="tok">b</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L41">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">hashString</span><span class="tok tok-symbol">(</span><span class="tok">s</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">u32</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok tok-builtin">@truncate</span><span class="tok tok-symbol">(</span><span class="tok tok-type">u32</span><span class="tok tok-symbol">,</span> <span class="tok">std</span><span class="tok tok-symbol">.</span><span class="tok">hash</span><span class="tok tok-symbol">.</span><span class="tok">Wyhash</span><span class="tok tok-symbol">.</span><span class="tok">hash</span><span class="tok tok-symbol">(</span><span class="tok tok-number">0</span><span class="tok tok-symbol">,</span> <span class="tok">s</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Insertion order is preserved.
Deletions perform a &quot;swap removal&quot; on the entries list.
Modifying the hash map while iterating is allowed, however one must understand
the (well defined) behavior when mixing insertions and deletions with iteration.
For a hash map that can be initialized directly that does not store an Allocator
field, see `ArrayHashMapUnmanaged`.
When `store_hash` is `false`, this data structure is biased towards cheap `eql`
functions. It does not store each item's hash in the table. Setting `store_hash`
to `true` incurs slightly more memory cost by storing each key's hash in the table
but only has to call `eql` for hash collisions.
If typical operations (except iteration over entries) need to be faster, prefer
the alternative `std.HashMap`.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L57">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">ArrayHashMap</span><span class="tok tok-symbol">(</span>
    <span class="tok tok-kw">comptime</span> <span class="tok">K</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-kw">comptime</span> <span class="tok">V</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-kw">comptime</span> <span class="tok">hash</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">fn</span> <span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">u32</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-kw">comptime</span> <span class="tok">eql</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">fn</span> <span class="tok tok-symbol">(</span><span class="tok">a</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">b</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-kw">comptime</span> <span class="tok">store_hash</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">bool</span><span class="tok tok-symbol">,</span>
<span class="tok tok-symbol">)</span> <span class="tok tok-type">type</span></code></pre><details><summary>fields:</summary><div class="md-fields more-decls"><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L65">src</a><pre><code class="zig"><span class="tok">unmanaged</span><span class="tok tok-symbol">:</span> <span class="tok">Unmanaged</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L66">src</a><pre><code class="zig"><span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span></code></pre></div></div></details><details><summary>types:</summary><div class="md-types more-decls"><div class="anal-decl"><b>Deprecated. Iterate using `items`.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L74">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">const</span> <span class="tok">Iterator</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">struct</span></code></pre><details><summary>fields:</summary><div class="md-fields more-decls"><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L75">src</a><pre><code class="zig"><span class="tok">hm</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok tok-kw">const</span> <span class="tok">Self</span></code></pre></div><div class="anal-decl"><b>Iterator through the entry array.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L77">src</a><pre><code class="zig"><span class="tok">index</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span></code></pre></div></div></details><details><summary>funcs</summary><div class="md-funcs more-decls"><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L79">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">next</span><span class="tok tok-symbol">(</span><span class="tok">it</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Iterator</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok tok-symbol">*</span><span class="tok">Entry</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok">it</span><span class="tok tok-symbol">.</span><span class="tok">index</span> <span class="tok tok-symbol">&gt;=</span> <span class="tok">it</span><span class="tok tok-symbol">.</span><span class="tok">hm</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">entries</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span><span class="tok tok-symbol">)</span> <span class="tok tok-kw">return</span> <span class="tok tok-null">null</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">const</span> <span class="tok">result</span> <span class="tok tok-symbol">=</span> <span class="tok tok-symbol">&amp;</span><span class="tok">it</span><span class="tok tok-symbol">.</span><span class="tok">hm</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">entries</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">[</span><span class="tok">it</span><span class="tok tok-symbol">.</span><span class="tok">index</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">;</span>
    <span class="tok">it</span><span class="tok tok-symbol">.</span><span class="tok">index</span> <span class="tok tok-symbol">+=</span> <span class="tok tok-number">1</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">result</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Reset the iterator to the initial index
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L87">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">reset</span><span class="tok tok-symbol">(</span><span class="tok">it</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Iterator</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok">it</span><span class="tok tok-symbol">.</span><span class="tok">index</span> <span class="tok tok-symbol">=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div></div></details></div></div></details><details><summary>funcs</summary><div class="md-funcs more-decls"><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L95">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">init</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">)</span> <span class="tok">Self</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok tok-symbol">.</span><span class="tok tok-symbol">{</span>
        <span class="tok tok-symbol">.</span><span class="tok">unmanaged</span> <span class="tok tok-symbol">=</span> <span class="tok tok-symbol">.</span><span class="tok tok-symbol">{</span><span class="tok tok-symbol">}</span><span class="tok tok-symbol">,</span>
        <span class="tok tok-symbol">.</span><span class="tok">allocator</span> <span class="tok tok-symbol">=</span> <span class="tok">allocator</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-symbol">}</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>`ArrayHashMap` takes ownership of the passed in array list. The array list must have
been allocated with `allocator`.
Deinitialize with `deinit`.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L105">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">fromOwnedArrayList</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">entries</span><span class="tok tok-symbol">:</span> <span class="tok">std</span><span class="tok tok-symbol">.</span><span class="tok">ArrayListUnmanaged</span><span class="tok tok-symbol">(</span><span class="tok">Entry</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok">Self</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">Self</span><span class="tok tok-symbol">{</span>
        <span class="tok tok-symbol">.</span><span class="tok">unmanaged</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">try</span> <span class="tok">Unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">fromOwnedArrayList</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">entries</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">,</span>
        <span class="tok tok-symbol">.</span><span class="tok">allocator</span> <span class="tok tok-symbol">=</span> <span class="tok">allocator</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-symbol">}</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L112">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">deinit</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">deinit</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocator</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">self</span><span class="tok tok-symbol">.*</span> <span class="tok tok-symbol">=</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L117">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">clearRetainingCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">clearRetainingCapacity</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L121">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">clearAndFree</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">clearAndFree</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocator</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L125">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">count</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">usize</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">count</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L129">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">iterator</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok tok-kw">const</span> <span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok">Iterator</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">Iterator</span><span class="tok tok-symbol">{</span>
        <span class="tok tok-symbol">.</span><span class="tok">hm</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">,</span>
        <span class="tok tok-symbol">.</span><span class="tok">index</span> <span class="tok tok-symbol">=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-symbol">}</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>If key exists this function cannot fail.
If there is an existing item with `key`, then the result
`Entry` pointer points to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the `Entry` pointer points to it. Caller should then initialize
the value (but not the key).
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L142">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">getOrPut</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok">GetOrPutResult</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">getOrPut</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>If there is an existing item with `key`, then the result
`Entry` pointer points to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the `Entry` pointer points to it. Caller should then initialize
the value (but not the key).
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L153">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">getOrPutAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok">GetOrPutResult</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">getOrPutAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L157">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">getOrPutValue</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-symbol">*</span><span class="tok">Entry</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">getOrPutValue</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Increases capacity, guaranteeing that insertions up until the
`expected_count` will not cause an allocation, and therefore cannot fail.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L163">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">ensureCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">new_capacity</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">ensureCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">new_capacity</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Returns the number of total elements which may be present before it is
no longer guaranteed that no allocations will be performed.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L169">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">capacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">usize</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">capacity</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Clobbers any existing data. To detect if a put would clobber
existing data, see `getOrPut`.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L175">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">put</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">put</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Inserts a key-value pair into the hash map, asserting that no previous
entry with the same key is already present
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L181">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">putNoClobber</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">putNoClobber</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Asserts there is enough capacity to store the new key-value pair.
Clobbers any existing data. To detect if a put would clobber
existing data, see `getOrPutAssumeCapacity`.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L188">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">putAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">putAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Asserts there is enough capacity to store the new key-value pair.
Asserts that it does not clobber any existing data.
To detect if a put would clobber existing data, see `getOrPutAssumeCapacity`.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L195">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">putAssumeCapacityNoClobber</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">putAssumeCapacityNoClobber</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Inserts a new `Entry` into the hash map, returning the previous one, if any.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L200">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">fetchPut</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-symbol">?</span><span class="tok">Entry</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">fetchPut</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Inserts a new `Entry` into the hash map, returning the previous one, if any.
If insertion happuns, asserts there is enough capacity without allocating.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L206">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">fetchPutAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">Entry</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">fetchPutAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L210">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">getEntry</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok tok-symbol">*</span><span class="tok">Entry</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">getEntry</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L214">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">getIndex</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok tok-type">usize</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">getIndex</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L218">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">get</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">V</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">get</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L222">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">contains</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">contains</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>If there is an `Entry` with a matching key, it is deleted from
the hash map, and then returned from this function. The entry is
removed from the underlying array by swapping it with the last
element.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L230">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">swapRemove</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">Entry</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">swapRemove</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>If there is an `Entry` with a matching key, it is deleted from
the hash map, and then returned from this function. The entry is
removed from the underlying array by shifting all elements forward
thereby maintaining the current ordering.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L238">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">orderedRemove</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">Entry</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">orderedRemove</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>TODO: deprecated: call swapRemoveAssertDiscard instead.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L243">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">removeAssertDiscard</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">removeAssertDiscard</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Asserts there is an `Entry` with matching key, deletes it from the hash map
by swapping it with the last element, and discards it.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L249">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">swapRemoveAssertDiscard</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">swapRemoveAssertDiscard</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Asserts there is an `Entry` with matching key, deletes it from the hash map
by by shifting all elements forward thereby maintaining the current ordering.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L255">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">orderedRemoveAssertDiscard</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">orderedRemoveAssertDiscard</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L259">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">items</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok">Entry</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L263">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">clone</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok">Self</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">var</span> <span class="tok">other</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">try</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">clone</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocator</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">other</span><span class="tok tok-symbol">.</span><span class="tok">promote</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocator</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Rebuilds the key indexes. If the underlying entries has been modified directly, users
can call `reIndex` to update the indexes to account for these new entries.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L270">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">reIndex</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">reIndex</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocator</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Shrinks the underlying `Entry` array to `new_len` elements and discards any associated
index entries. Keeps capacity the same.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L276">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">shrinkRetainingCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">new_len</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">shrinkRetainingCapacity</span><span class="tok tok-symbol">(</span><span class="tok">new_len</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Shrinks the underlying `Entry` array to `new_len` elements and discards any associated
index entries. Reduces allocated capacity.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L282">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">shrinkAndFree</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">new_len</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">shrinkAndFree</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">new_len</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Removes the last inserted `Entry` in the hash map and returns it.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L287">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">pop</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok">Entry</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">pop</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div></div></details><details><summary>values:</summary><div class="md-vals more-decls"><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L68">src</a><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">Unmanaged</span> <span class="tok tok-symbol">=</span> <span class="tok">ArrayHashMapUnmanaged</span><span class="tok tok-symbol">(</span><span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">V</span><span class="tok tok-symbol">,</span> <span class="tok">hash</span><span class="tok tok-symbol">,</span> <span class="tok">eql</span><span class="tok tok-symbol">,</span> <span class="tok">store_hash</span><span class="tok tok-symbol">)</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L69">src</a><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">Entry</span> <span class="tok tok-symbol">=</span> <span class="tok">Unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">Entry</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L70">src</a><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">Hash</span> <span class="tok tok-symbol">=</span> <span class="tok">Unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">Hash</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L71">src</a><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">GetOrPutResult</span> <span class="tok tok-symbol">=</span> <span class="tok">Unmanaged</span><span class="tok tok-symbol">.</span><span class="tok">GetOrPutResult</span></code></pre></div></div></details></div><div class="anal-decl"><b>General purpose hash table.
Insertion order is preserved.
Deletions perform a &quot;swap removal&quot; on the entries list.
Modifying the hash map while iterating is allowed, however one must understand
the (well defined) behavior when mixing insertions and deletions with iteration.
This type does not store an Allocator field - the Allocator must be passed in
with each function call that requires it. See `ArrayHashMap` for a type that stores
an Allocator field for convenience.
Can be initialized directly using the default field values.
This type is designed to have low overhead for small numbers of entries. When
`store_hash` is `false` and the number of entries in the map is less than 9,
the overhead cost of using `ArrayHashMapUnmanaged` rather than `std.ArrayList` is
only a single pointer-sized integer.
When `store_hash` is `false`, this data structure is biased towards cheap `eql`
functions. It does not store each item's hash in the table. Setting `store_hash`
to `true` incurs slightly more memory cost by storing each key's hash in the table
but guarantees only one call to `eql` per insertion/deletion.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L310">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">ArrayHashMapUnmanaged</span><span class="tok tok-symbol">(</span>
    <span class="tok tok-kw">comptime</span> <span class="tok">K</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-kw">comptime</span> <span class="tok">V</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-kw">comptime</span> <span class="tok">hash</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">fn</span> <span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">u32</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-kw">comptime</span> <span class="tok">eql</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">fn</span> <span class="tok tok-symbol">(</span><span class="tok">a</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">b</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-kw">comptime</span> <span class="tok">store_hash</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">bool</span><span class="tok tok-symbol">,</span>
<span class="tok tok-symbol">)</span> <span class="tok tok-type">type</span></code></pre><details><summary>fields:</summary><div class="md-fields more-decls"><div class="anal-decl"><b>It is permitted to access this field directly.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L319">src</a><pre><code class="zig"><span class="tok">entries</span><span class="tok tok-symbol">:</span> <span class="tok">std</span><span class="tok tok-symbol">.</span><span class="tok">ArrayListUnmanaged</span><span class="tok tok-symbol">(</span><span class="tok">Entry</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">=</span> <span class="tok tok-symbol">.</span><span class="tok tok-symbol">{</span><span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>When entries length is less than `linear_scan_max`, this remains `null`.
Once entries length grows big enough, this field is allocated. There is
an IndexHeader followed by an array of Index(I) structs, where I is defined
by how many total indexes there are.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L325">src</a><pre><code class="zig"><span class="tok">index_header</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">?</span><span class="tok tok-symbol">*</span><span class="tok">IndexHeader</span> <span class="tok tok-symbol">=</span> <span class="tok tok-null">null</span></code></pre></div></div></details><details><summary>types:</summary><div class="md-types more-decls"><div class="anal-decl"><b>Modifying the key is illegal behavior.
Modifying the value is allowed.
Entry pointers become invalid whenever this ArrayHashMap is modified,
unless `ensureCapacity` was previously used.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L331">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">const</span> <span class="tok">Entry</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">struct</span></code></pre><details><summary>fields:</summary><div class="md-fields more-decls"><div class="anal-decl"><b>This field is `void` if `store_hash` is `false`.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L333">src</a><pre><code class="zig"><span class="tok">hash</span><span class="tok tok-symbol">:</span> <span class="tok">Hash</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L334">src</a><pre><code class="zig"><span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L335">src</a><pre><code class="zig"><span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span></code></pre></div></div></details></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L340">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">const</span> <span class="tok">GetOrPutResult</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">struct</span></code></pre><details><summary>fields:</summary><div class="md-fields more-decls"><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L341">src</a><pre><code class="zig"><span class="tok">entry</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Entry</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L342">src</a><pre><code class="zig"><span class="tok">found_existing</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">bool</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L343">src</a><pre><code class="zig"><span class="tok">index</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span></code></pre></div></div></details></div></div></details><details><summary>funcs</summary><div class="md-funcs more-decls"><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L358">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">promote</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">)</span> <span class="tok">Managed</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok tok-symbol">.</span><span class="tok tok-symbol">{</span>
        <span class="tok tok-symbol">.</span><span class="tok">unmanaged</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">,</span>
        <span class="tok tok-symbol">.</span><span class="tok">allocator</span> <span class="tok tok-symbol">=</span> <span class="tok">allocator</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-symbol">}</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>`ArrayHashMapUnmanaged` takes ownership of the passed in array list. The array list must
have been allocated with `allocator`.
Deinitialize with `deinit`.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L368">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">fromOwnedArrayList</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">entries</span><span class="tok tok-symbol">:</span> <span class="tok">std</span><span class="tok tok-symbol">.</span><span class="tok">ArrayListUnmanaged</span><span class="tok tok-symbol">(</span><span class="tok">Entry</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok">Self</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">var</span> <span class="tok">array_hash_map</span> <span class="tok tok-symbol">=</span> <span class="tok">Self</span><span class="tok tok-symbol">{</span> <span class="tok tok-symbol">.</span><span class="tok">entries</span> <span class="tok tok-symbol">=</span> <span class="tok">entries</span> <span class="tok tok-symbol">}</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">try</span> <span class="tok">array_hash_map</span><span class="tok tok-symbol">.</span><span class="tok">reIndex</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">array_hash_map</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L374">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">deinit</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L382">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">clearRetainingCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L395">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">clearAndFree</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L403">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">count</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">usize</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">entries</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>If key exists this function cannot fail.
If there is an existing item with `key`, then the result
`Entry` pointer points to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the `Entry` pointer points to it. Caller should then initialize
the value (but not the key).
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L413">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">getOrPut</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok">GetOrPutResult</span></code></pre></div><div class="anal-decl"><b>If there is an existing item with `key`, then the result
`Entry` pointer points to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the `Entry` pointer points to it. Caller should then initialize
the value (but not the key).
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L433">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">getOrPutAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok">GetOrPutResult</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L467">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">getOrPutValue</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-symbol">*</span><span class="tok">Entry</span></code></pre></div><div class="anal-decl"><b>Increases capacity, guaranteeing that insertions up until the
`expected_count` will not cause an allocation, and therefore cannot fail.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L477">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">ensureCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">new_capacity</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>Returns the number of total elements which may be present before it is
no longer guaranteed that no allocations will be performed.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L506">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">capacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">usize</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">entry_cap</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">entries</span><span class="tok tok-symbol">.</span><span class="tok">capacity</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">const</span> <span class="tok">header</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">index_header</span> <span class="tok tok-kw">orelse</span> <span class="tok tok-kw">return</span> <span class="tok">math</span><span class="tok tok-symbol">.</span><span class="tok">min</span><span class="tok tok-symbol">(</span><span class="tok">linear_scan_max</span><span class="tok tok-symbol">,</span> <span class="tok">entry_cap</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">const</span> <span class="tok">indexes_cap</span> <span class="tok tok-symbol">=</span> <span class="tok tok-symbol">(</span><span class="tok">header</span><span class="tok tok-symbol">.</span><span class="tok">indexes_len</span> <span class="tok tok-symbol">+</span> <span class="tok tok-number">1</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">*</span> <span class="tok tok-number">3</span> <span class="tok tok-symbol">/</span> <span class="tok tok-number">4</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">math</span><span class="tok tok-symbol">.</span><span class="tok">min</span><span class="tok tok-symbol">(</span><span class="tok">entry_cap</span><span class="tok tok-symbol">,</span> <span class="tok">indexes_cap</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Clobbers any existing data. To detect if a put would clobber
existing data, see `getOrPut`.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L515">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">put</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">result</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">try</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">getOrPut</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">result</span><span class="tok tok-symbol">.</span><span class="tok">entry</span><span class="tok tok-symbol">.</span><span class="tok">value</span> <span class="tok tok-symbol">=</span> <span class="tok">value</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Inserts a key-value pair into the hash map, asserting that no previous
entry with the same key is already present
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L522">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">putNoClobber</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">result</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">try</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">getOrPut</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">assert</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">!</span><span class="tok">result</span><span class="tok tok-symbol">.</span><span class="tok">found_existing</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">result</span><span class="tok tok-symbol">.</span><span class="tok">entry</span><span class="tok tok-symbol">.</span><span class="tok">value</span> <span class="tok tok-symbol">=</span> <span class="tok">value</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Asserts there is enough capacity to store the new key-value pair.
Clobbers any existing data. To detect if a put would clobber
existing data, see `getOrPutAssumeCapacity`.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L531">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">putAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">result</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">getOrPutAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">result</span><span class="tok tok-symbol">.</span><span class="tok">entry</span><span class="tok tok-symbol">.</span><span class="tok">value</span> <span class="tok tok-symbol">=</span> <span class="tok">value</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Asserts there is enough capacity to store the new key-value pair.
Asserts that it does not clobber any existing data.
To detect if a put would clobber existing data, see `getOrPutAssumeCapacity`.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L539">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">putAssumeCapacityNoClobber</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">result</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">getOrPutAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">assert</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">!</span><span class="tok">result</span><span class="tok tok-symbol">.</span><span class="tok">found_existing</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">result</span><span class="tok tok-symbol">.</span><span class="tok">entry</span><span class="tok tok-symbol">.</span><span class="tok">value</span> <span class="tok tok-symbol">=</span> <span class="tok">value</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Inserts a new `Entry` into the hash map, returning the previous one, if any.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L546">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">fetchPut</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-symbol">?</span><span class="tok">Entry</span></code></pre></div><div class="anal-decl"><b>Inserts a new `Entry` into the hash map, returning the previous one, if any.
If insertion happens, asserts there is enough capacity without allocating.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L558">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">fetchPutAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">V</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">Entry</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L568">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">getEntry</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok tok-symbol">*</span><span class="tok">Entry</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">index</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">getIndex</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">)</span> <span class="tok tok-kw">orelse</span> <span class="tok tok-kw">return</span> <span class="tok tok-null">null</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok tok-symbol">&amp;</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">entries</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">[</span><span class="tok">index</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L573">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">getIndex</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok tok-type">usize</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L592">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">get</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">V</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">getEntry</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">|</span><span class="tok">entry</span><span class="tok tok-symbol">|</span> <span class="tok">entry</span><span class="tok tok-symbol">.</span><span class="tok">value</span> <span class="tok tok-kw">else</span> <span class="tok tok-null">null</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L596">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">contains</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">getEntry</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-null">null</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>If there is an `Entry` with a matching key, it is deleted from
the hash map, and then returned from this function. The entry is
removed from the underlying array by swapping it with the last
element.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L604">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">swapRemove</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">Entry</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">removeInternal</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok tok-symbol">.</span><span class="tok">swap</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>If there is an `Entry` with a matching key, it is deleted from
the hash map, and then returned from this function. The entry is
removed from the underlying array by shifting all elements forward
thereby maintaining the current ordering.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L612">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">orderedRemove</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">Entry</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">removeInternal</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok tok-symbol">.</span><span class="tok">ordered</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>TODO deprecated: call swapRemoveAssertDiscard instead.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L617">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">removeAssertDiscard</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">swapRemoveAssertDiscard</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Asserts there is an `Entry` with matching key, deletes it from the hash map
by swapping it with the last element, and discards it.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L623">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">swapRemoveAssertDiscard</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok">assert</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">swapRemove</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-null">null</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Asserts there is an `Entry` with matching key, deletes it from the hash map
by by shifting all elements forward thereby maintaining the current ordering.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L629">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">orderedRemoveAssertDiscard</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">key</span><span class="tok tok-symbol">:</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok">assert</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">orderedRemove</span><span class="tok tok-symbol">(</span><span class="tok">key</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-null">null</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L633">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">items</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok">Entry</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">entries</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L637">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">clone</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok">Self</span></code></pre></div><div class="anal-decl"><b>Rebuilds the key indexes. If the underlying entries has been modified directly, users
can call `reIndex` to update the indexes to account for these new entries.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L651">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">reIndex</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>Shrinks the underlying `Entry` array to `new_len` elements and discards any associated
index entries. Keeps capacity the same.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L666">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">shrinkRetainingCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">new_len</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>Shrinks the underlying `Entry` array to `new_len` elements and discards any associated
index entries. Reduces allocated capacity.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L678">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">shrinkAndFree</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">new_len</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>Removes the last inserted `Entry` in the hash map and returns it.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L689">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">pop</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok">Entry</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">top</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">entries</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">[</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">entries</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">-</span> <span class="tok tok-number">1</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">;</span>
    <span class="tok">_</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">removeWithHash</span><span class="tok tok-symbol">(</span><span class="tok">top</span><span class="tok tok-symbol">.</span><span class="tok">key</span><span class="tok tok-symbol">,</span> <span class="tok">top</span><span class="tok tok-symbol">.</span><span class="tok">hash</span><span class="tok tok-symbol">,</span> <span class="tok tok-symbol">.</span><span class="tok">index_only</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">entries</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">-=</span> <span class="tok tok-number">1</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">top</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div></div></details><details><summary>values:</summary><div class="md-vals more-decls"><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L338">src</a><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">Hash</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok">store_hash</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">u32</span> <span class="tok tok-kw">else</span> <span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L346">src</a><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">Managed</span> <span class="tok tok-symbol">=</span> <span class="tok">ArrayHashMap</span><span class="tok tok-symbol">(</span><span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">V</span><span class="tok tok-symbol">,</span> <span class="tok">hash</span><span class="tok tok-symbol">,</span> <span class="tok">eql</span><span class="tok tok-symbol">,</span> <span class="tok">store_hash</span><span class="tok tok-symbol">)</span></code></pre></div></div></details></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L1341">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">getHashPtrAddrFn</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">K</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">(</span><span class="tok tok-kw">fn</span> <span class="tok tok-symbol">(</span><span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">u32</span><span class="tok tok-symbol">)</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L1349">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">getTrivialEqlFn</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">K</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">(</span><span class="tok tok-kw">fn</span> <span class="tok tok-symbol">(</span><span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span><span class="tok tok-symbol">)</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L1357">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">getAutoHashFn</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">K</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">(</span><span class="tok tok-kw">fn</span> <span class="tok tok-symbol">(</span><span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">u32</span><span class="tok tok-symbol">)</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L1371">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">getAutoEqlFn</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">K</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">(</span><span class="tok tok-kw">fn</span> <span class="tok tok-symbol">(</span><span class="tok">K</span><span class="tok tok-symbol">,</span> <span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span><span class="tok tok-symbol">)</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L1379">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">autoEqlIsCheap</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">K</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/array_hash_map.zig#L1397">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">getAutoHashStratFn</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">K</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok tok-kw">comptime</span> <span class="tok">strategy</span><span class="tok tok-symbol">:</span> <span class="tok">std</span><span class="tok tok-symbol">.</span><span class="tok">hash</span><span class="tok tok-symbol">.</span><span class="tok">Strategy</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">(</span><span class="tok tok-kw">fn</span> <span class="tok tok-symbol">(</span><span class="tok">K</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">u32</span><span class="tok tok-symbol">)</span></code></pre></div></div><div class="more-decls"></div></html>