[{"doc_comment":"This struct represents a kernel thread, and acts as a namespace for concurrency\nprimitives that operate on kernel threads. For concurrency primitives that support\nboth evented I/O and async I/O, see the respective names in the top level std namespace.","pl":"data: Data","src":10,"more_decls":null}{"doc_comment":"Signals the processor that it is inside a busy-wait spin-loop (\"spin lock\").","pl":"fn spinLoopHint() void","src":70,"more_decls":null}{"doc_comment":"Returns the ID of the calling thread.\nMakes a syscall every time the function is called.\nOn Linux and POSIX, this Id is the same as a Handle.","pl":"fn getCurrentId() Id","src":81,"more_decls":null}{"doc_comment":"Returns the handle of this thread.\nOn Linux and POSIX, this is the same as Id.\nOn Linux, it is possible that the thread spawned with `spawn`\nfinishes executing entirely before the clone syscall completes. In this\ncase, this function will return 0 rather than the no-longer-existing thread's\npid.","pl":"pub fn handle(self: Thread) Handle {\n    return self.data.handle;\n}","src":97,"more_decls":null}{"pl":"fn wait(self: *Thread) void","src":101,"more_decls":null}{"doc_comment":"Spawns a new thread executing startFn, returning an handle for it.\nCaller must call wait on the returned thread.\nThe `startFn` function must take a single argument of type T and return a\nvalue of type u8, noreturn, void or !void.\nThe `context` parameter is of type T and is passed to the spawned thread.","pl":"fn spawn(comptime startFn: anytype, context: SpawnContextType(@TypeOf(startFn))) SpawnError!*Thread","src":186,"more_decls":null}{"pl":"fn cpuCount() CpuCountError!usize","src":502,"more_decls":null}{"pl":"fn getCurrentThreadId() u64","src":541,"more_decls":null}{"pl":"const AutoResetEvent = @import(\"Thread/AutoResetEvent.zig\")","src":12,"more_decls":null}{"pl":"const ResetEvent = @import(\"Thread/ResetEvent.zig\")","src":13,"more_decls":null}{"pl":"const StaticResetEvent = @import(\"Thread/StaticResetEvent.zig\")","src":14,"more_decls":null}{"pl":"const Mutex = @import(\"Thread/Mutex.zig\")","src":15,"more_decls":null}{"pl":"const Semaphore = @import(\"Thread/Semaphore.zig\")","src":16,"more_decls":null}{"pl":"const Condition = @import(\"Thread/Condition.zig\")","src":17,"more_decls":null}{"pl":"const use_pthreads = std.Target.current.os.tag != .windows and builtin.link_libc","src":19,"more_decls":null}{"doc_comment":"Represents a kernel thread handle.\nMay be an integer or a pointer depending on the platform.\nOn Linux and POSIX, this is the same as Id.","pl":"const Handle = if (use_pthreads)\n    c.pthread_t\nelse switch (std.Target.current.os.tag) {\n    .linux => i32,\n    .windows => windows.HANDLE,\n    else => void,\n}","src":35,"more_decls":null}{"doc_comment":"Represents a unique ID per thread.\nMay be an integer or pointer depending on the platform.\nOn Linux and POSIX, this is the same as Handle.","pl":"const Id = switch (std.Target.current.os.tag) {\n    .windows => windows.DWORD,\n    else => Handle,\n}","src":46,"more_decls":null}{"pl":"const Data = if (use_pthreads)\n    struct {\n        handle: Thread.Handle,\n        memory: []u8,\n    }\nelse switch (std.Target.current.os.tag) {\n    .linux => struct {\n        handle: Thread.Handle,\n        memory: []align(mem.page_size) u8,\n    },\n    .windows => struct {\n        handle: Thread.Handle,\n        alloc_start: *c_void,\n        heap_handle: windows.HANDLE,\n    },\n    else => struct {},\n}","src":51,"more_decls":null}{"pl":"const SpawnError = error{\n    /// A system-imposed limit on the number of threads was encountered.\n    /// There are a number of limits that may trigger this error:\n    /// *  the  RLIMIT_NPROC soft resource limit (set via setrlimit(2)),\n    ///    which limits the number of processes and threads for  a  real\n    ///    user ID, was reached;\n    /// *  the kernel's system-wide limit on the number of processes and\n    ///    threads,  /proc/sys/kernel/threads-max,  was   reached   (see\n    ///    proc(5));\n    /// *  the  maximum  number  of  PIDs, /proc/sys/kernel/pid_max, was\n    ///    reached (see proc(5)); or\n    /// *  the PID limit (pids.max) imposed by the cgroup \"process  num‚Äê\n    ///    ber\" (PIDs) controller was reached.\n    ThreadQuotaExceeded,\n\n    /// The kernel cannot allocate sufficient memory to allocate a task structure\n    /// for the child, or to copy those parts of the caller's context that need to\n    /// be copied.\n    SystemResources,\n\n    /// Not enough userland memory to spawn the thread.\n    OutOfMemory,\n\n    /// `mlockall` is enabled, and the memory needed to spawn the thread\n    /// would exceed the limit.\n    LockedMemoryLimitExceeded,\n\n    Unexpected,\n}","src":137,"more_decls":null}{"pl":"const CpuCountError = error{\n    PermissionDenied,\n    SystemResources,\n    Unexpected,\n}","src":496,"more_decls":null}]