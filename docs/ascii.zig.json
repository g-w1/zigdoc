[{"doc_comment":"Contains constants for the C0 control codes of the ASCII encoding.\nhttps://en.wikipedia.org/wiki/C0_and_C1_control_codes","pl":"pub const control_code = struct ","src":18,"more_decls":{"pl":"const NUL = 0x00","src":19,"more_decls":null}{"pl":"const SOH = 0x01","src":20,"more_decls":null}{"pl":"const STX = 0x02","src":21,"more_decls":null}{"pl":"const ETX = 0x03","src":22,"more_decls":null}{"pl":"const EOT = 0x04","src":23,"more_decls":null}{"pl":"const ENQ = 0x05","src":24,"more_decls":null}{"pl":"const ACK = 0x06","src":25,"more_decls":null}{"pl":"const BEL = 0x07","src":26,"more_decls":null}{"pl":"const BS = 0x08","src":27,"more_decls":null}{"pl":"const TAB = 0x09","src":28,"more_decls":null}{"pl":"const LF = 0x0A","src":29,"more_decls":null}{"pl":"const VT = 0x0B","src":30,"more_decls":null}{"pl":"const FF = 0x0C","src":31,"more_decls":null}{"pl":"const CR = 0x0D","src":32,"more_decls":null}{"pl":"const SO = 0x0E","src":33,"more_decls":null}{"pl":"const SI = 0x0F","src":34,"more_decls":null}{"pl":"const DLE = 0x10","src":35,"more_decls":null}{"pl":"const DC1 = 0x11","src":36,"more_decls":null}{"pl":"const DC2 = 0x12","src":37,"more_decls":null}{"pl":"const DC3 = 0x13","src":38,"more_decls":null}{"pl":"const DC4 = 0x14","src":39,"more_decls":null}{"pl":"const NAK = 0x15","src":40,"more_decls":null}{"pl":"const SYN = 0x16","src":41,"more_decls":null}{"pl":"const ETB = 0x17","src":42,"more_decls":null}{"pl":"const CAN = 0x18","src":43,"more_decls":null}{"pl":"const EM = 0x19","src":44,"more_decls":null}{"pl":"const SUB = 0x1A","src":45,"more_decls":null}{"pl":"const ESC = 0x1B","src":46,"more_decls":null}{"pl":"const FS = 0x1C","src":47,"more_decls":null}{"pl":"const GS = 0x1D","src":48,"more_decls":null}{"pl":"const RS = 0x1E","src":49,"more_decls":null}{"pl":"const US = 0x1F","src":50,"more_decls":null}{"pl":"const DEL = 0x7F","src":52,"more_decls":null}{"pl":"const XON = 0x11","src":54,"more_decls":null}{"pl":"const XOFF = 0x13","src":55,"more_decls":null}}{"pl":"pub fn isAlNum(c: u8) bool {\n    return (combinedTable[c] & ((@as(u8, 1) << @enumToInt(tIndex.Alpha)) |\n        @as(u8, 1) << @enumToInt(tIndex.Digit))) != 0;\n}","src":195,"more_decls":null}{"pl":"pub fn isAlpha(c: u8) bool {\n    return inTable(c, tIndex.Alpha);\n}","src":200,"more_decls":null}{"pl":"pub fn isCntrl(c: u8) bool {\n    return c < 0x20 or c == 127; //DEL\n}","src":204,"more_decls":null}{"pl":"pub fn isDigit(c: u8) bool {\n    return inTable(c, tIndex.Digit);\n}","src":208,"more_decls":null}{"pl":"pub fn isGraph(c: u8) bool {\n    return inTable(c, tIndex.Graph);\n}","src":212,"more_decls":null}{"pl":"pub fn isLower(c: u8) bool {\n    return inTable(c, tIndex.Lower);\n}","src":216,"more_decls":null}{"pl":"pub fn isPrint(c: u8) bool {\n    return inTable(c, tIndex.Graph) or c == ' ';\n}","src":220,"more_decls":null}{"pl":"pub fn isPunct(c: u8) bool {\n    return inTable(c, tIndex.Punct);\n}","src":224,"more_decls":null}{"pl":"pub fn isSpace(c: u8) bool {\n    return inTable(c, tIndex.Space);\n}","src":228,"more_decls":null}{"pl":"pub fn isUpper(c: u8) bool {\n    return inTable(c, tIndex.Upper);\n}","src":246,"more_decls":null}{"pl":"pub fn isXDigit(c: u8) bool {\n    return inTable(c, tIndex.Hex);\n}","src":250,"more_decls":null}{"pl":"pub fn isASCII(c: u8) bool {\n    return c < 128;\n}","src":254,"more_decls":null}{"pl":"pub fn isBlank(c: u8) bool {\n    return (c == ' ') or (c == '\\x09');\n}","src":258,"more_decls":null}{"pl":"fn toUpper(c: u8) u8","src":262,"more_decls":null}{"pl":"fn toLower(c: u8) u8","src":270,"more_decls":null}{"doc_comment":"Allocates a lower case copy of `ascii_string`.\nCaller owns returned string and must free with `allocator`.","pl":"fn allocLowerString(allocator: *std.mem.Allocator, ascii_string: []const u8) ![]u8","src":292,"more_decls":null}{"doc_comment":"Allocates an upper case copy of `ascii_string`.\nCaller owns returned string and must free with `allocator`.","pl":"fn allocUpperString(allocator: *std.mem.Allocator, ascii_string: []const u8) ![]u8","src":308,"more_decls":null}{"doc_comment":"Compares strings `a` and `b` case insensitively and returns whether they are equal.","pl":"fn eqlIgnoreCase(a: []const u8, b: []const u8) bool","src":323,"more_decls":null}{"pl":"pub fn startsWithIgnoreCase(haystack: []const u8, needle: []const u8) bool {\n    return if (needle.len > haystack.len) false else eqlIgnoreCase(haystack[0..needle.len], needle);\n}","src":337,"more_decls":null}{"pl":"pub fn endsWithIgnoreCase(haystack: []const u8, needle: []const u8) bool {\n    return if (needle.len > haystack.len) false else eqlIgnoreCase(haystack[haystack.len - needle.len ..], needle);\n}","src":346,"more_decls":null}{"doc_comment":"Finds `substr` in `container`, ignoring case, starting at `start_index`.\nTODO boyer-moore algorithm","pl":"fn indexOfIgnoreCasePos(container: []const u8, start_index: usize, substr: []const u8) ?usize","src":357,"more_decls":null}{"doc_comment":"Finds `substr` in `container`, ignoring case, starting at index 0.","pl":"pub fn indexOfIgnoreCase(container: []const u8, substr: []const u8) ?usize {\n    return indexOfIgnoreCasePos(container, 0, substr);\n}","src":369,"more_decls":null}{"doc_comment":"Compares two slices of numbers lexicographically. O(n).","pl":"fn orderIgnoreCase(lhs: []const u8, rhs: []const u8) std.math.Order","src":383,"more_decls":null}{"doc_comment":"Returns true if lhs < rhs, false otherwise\nTODO rename \"IgnoreCase\" to \"Insensitive\" in this entire file.","pl":"pub fn lessThanIgnoreCase(lhs: []const u8, rhs: []const u8) bool {\n    return orderIgnoreCase(lhs, rhs) == .lt;\n}","src":398,"more_decls":null}{"doc_comment":"All the values for which isSpace() returns true. This may be used with\ne.g. std.mem.trim() to trim whiteSpace.","pl":"const spaces = [_]u8{ ' ', '\\t', '\\n', '\\r', control_code.VT, control_code.FF }","src":234,"more_decls":null}]