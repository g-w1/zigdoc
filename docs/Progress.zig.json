[{"doc_comment":"`null` if the current node (and its children) should\nnot print on update()","pl":"terminal: ?std.fs.File = undefined","src":22,"more_decls":null}{"doc_comment":"Whether the terminal supports ANSI escape codes.","pl":"supports_ansi_escape_codes: bool = false","src":25,"more_decls":null}{"doc_comment":"If the terminal is \"dumb\", don't print output.\nThis can be useful if you don't want to print all\nthe stages of code generation if there are a lot.\nYou should not use it if the user should see output\nfor example showing the user what tests run.","pl":"dont_print_on_dumb: bool = false","src":32,"more_decls":null}{"pl":"root: Node = undefined","src":34,"more_decls":null}{"doc_comment":"Keeps track of how much time has passed since the beginning.\nUsed to compare with `initial_delay_ms` and `refresh_rate_ms`.","pl":"timer: std.time.Timer = undefined","src":38,"more_decls":null}{"doc_comment":"When the previous refresh was written to the terminal.\nUsed to compare with `refresh_rate_ms`.","pl":"prev_refresh_timestamp: u64 = undefined","src":42,"more_decls":null}{"doc_comment":"This buffer represents the maximum number of bytes written to the terminal\nwith each refresh.","pl":"output_buffer: [100]u8 = undefined","src":46,"more_decls":null}{"doc_comment":"How many nanoseconds between writing updates to the terminal.","pl":"refresh_rate_ns: u64 = 50 * std.time.ns_per_ms","src":49,"more_decls":null}{"doc_comment":"How many nanoseconds to keep the output hidden","pl":"initial_delay_ns: u64 = 500 * std.time.ns_per_ms","src":52,"more_decls":null}{"pl":"done: bool = true","src":54,"more_decls":null}{"doc_comment":"Protects the `refresh` function, as well as `node.recently_updated_child`.\nWithout this, callsites would call `Node.end` and then free `Node` memory\nwhile it was still being accessed by the `refresh` function.","pl":"update_lock: std.Thread.Mutex = .{}","src":59,"more_decls":null}{"doc_comment":"Represents one unit of progress. Each node can have children nodes, or\none can use integers with `update`.","pl":"pub const Node = struct ","src":63,"more_decls":{"pl":"context: *Progress","src":64,"more_decls":null}{"pl":"parent: ?*Node","src":65,"more_decls":null}{"pl":"name: []const u8","src":66,"more_decls":null}{"doc_comment":"Must be handled atomically to be thread-safe.","pl":"recently_updated_child: ?*Node = null","src":68,"more_decls":null}{"doc_comment":"Must be handled atomically to be thread-safe. 0 means null.","pl":"unprotected_estimated_total_items: usize","src":70,"more_decls":null}{"doc_comment":"Must be handled atomically to be thread-safe.","pl":"unprotected_completed_items: usize","src":72,"more_decls":null}{"doc_comment":"Create a new child progress node. Thread-safe.\nCall `Node.end` when done.\nTODO solve https://github.com/ziglang/zig/issues/2765 and then change this\nAPI to set `self.parent.recently_updated_child` with the return value.\nUntil that is fixed you probably want to call `activate` on the return value.\nPassing 0 for `estimated_total_items` means unknown.","pl":"fn start(self: *Node, name: []const u8, estimated_total_items: usize) Node","src":80,"more_decls":null}{"doc_comment":"This is the same as calling `start` and then `end` on the returned `Node`. Thread-safe.","pl":"pub fn completeOne(self: *Node) void {\n    self.activate();\n    _ = @atomicRmw(usize, &self.unprotected_completed_items, .Add, 1, .Monotonic);\n    self.context.maybeRefresh();\n}","src":91,"more_decls":null}{"doc_comment":"Finish a started `Node`. Thread-safe.","pl":"fn end(self: *Node) void","src":98,"more_decls":null}{"doc_comment":"Tell the parent node that this node is actively being worked on. Thread-safe.","pl":"pub fn activate(self: *Node) void {\n    if (self.parent) |parent| {\n        @atomicStore(?*Node, &parent.recently_updated_child, self, .Release);\n    }\n}","src":116,"more_decls":null}{"doc_comment":"Thread-safe. 0 means unknown.","pl":"pub fn setEstimatedTotalItems(self: *Node, count: usize) void {\n    @atomicStore(usize, &self.unprotected_estimated_total_items, count, .Monotonic);\n}","src":123,"more_decls":null}{"doc_comment":"Thread-safe.","pl":"pub fn setCompletedItems(self: *Node, completed_items: usize) void {\n    @atomicStore(usize, &self.unprotected_completed_items, completed_items, .Monotonic);\n}","src":128,"more_decls":null}}{"doc_comment":"Create a new progress node.\nCall `Node.end` when done.\nTODO solve https://github.com/ziglang/zig/issues/2765 and then change this\nAPI to return Progress rather than accept it as a parameter.\n`estimated_total_items` value of 0 means unknown.","pl":"fn start(self: *Progress, name: []const u8, estimated_total_items: usize) !*Node","src":138,"more_decls":null}{"doc_comment":"Updates the terminal if enough time has passed since last update. Thread-safe.","pl":"fn maybeRefresh(self: *Progress) void","src":164,"more_decls":null}{"doc_comment":"Updates the terminal and resets `self.next_refresh_timestamp`. Thread-safe.","pl":"pub fn refresh(self: *Progress) void {\n    const held = self.update_lock.tryAcquire() orelse return;\n    defer held.release();\n\n    return self.refreshWithHeldLock();\n}","src":177,"more_decls":null}{"pl":"fn log(self: *Progress, comptime format: []const u8, args: anytype) void","src":302,"more_decls":null}]