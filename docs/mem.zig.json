[{"pl":"pub const TokenIterator = struct ","src":1458,"more_decls":{"pl":"buffer: []const u8","src":1459,"more_decls":null}{"pl":"delimiter_bytes: []const u8","src":1460,"more_decls":null}{"pl":"index: usize","src":1461,"more_decls":null}{"doc_comment":"Returns a slice of the next token, or null if tokenization is complete.","pl":"fn next(self: *TokenIterator) ?[]const u8","src":1464,"more_decls":null}{"doc_comment":"Returns a slice of the remaining bytes. Does not affect iterator state.","pl":"pub fn rest(self: TokenIterator) []const u8 {\n    // move to beginning of token\n    var index: usize = self.index;\n    while (index < self.buffer.len and self.isSplitByte(self.buffer[index])) : (index += 1) {}\n    return self.buffer[index..];\n}","src":1480,"more_decls":null}{"doc_comment":"Resets the iterator to the initial token.","pl":"pub fn reset(self: *TokenIterator) void {\n    self.index = 0;\n}","src":1488,"more_decls":null}}{"pl":"pub const SplitIterator = struct ","src":1502,"more_decls":{"pl":"buffer: []const u8","src":1503,"more_decls":null}{"pl":"index: ?usize","src":1504,"more_decls":null}{"pl":"delimiter: []const u8","src":1505,"more_decls":null}{"doc_comment":"Returns a slice of the next field, or null if splitting is complete.","pl":"fn next(self: *SplitIterator) ?[]const u8","src":1508,"more_decls":null}{"doc_comment":"Returns a slice of the remaining bytes. Does not affect iterator state.","pl":"pub fn rest(self: SplitIterator) []const u8 {\n    const end = self.buffer.len;\n    const start = self.index orelse end;\n    return self.buffer[start..end];\n}","src":1521,"more_decls":null}}{"doc_comment":"Detects and asserts if the std.mem.Allocator interface is violated by the caller\nor the allocator.","pl":"fn ValidationAllocator(comptime T: type) type","sub_container_type":"struct ","src":39,"more_decls":{"pl":"allocator: Allocator","src":42,"more_decls":null}{"pl":"underlying_allocator: T","src":43,"more_decls":null}{"pl":"fn init(allocator: T) @This()","src":44,"more_decls":null}{"pl":"fn alloc(\n    allocator: *Allocator,\n    n: usize,\n    ptr_align: u29,\n    len_align: u29,\n    ret_addr: usize,\n) Allocator.Error![]u8","src":58,"more_decls":null}{"pl":"fn resize(\n    allocator: *Allocator,\n    buf: []u8,\n    buf_align: u29,\n    new_len: usize,\n    len_align: u29,\n    ret_addr: usize,\n) Allocator.Error!usize","src":84,"more_decls":null}}{"pl":"pub fn validationWrap(allocator: anytype) ValidationAllocator(@TypeOf(allocator)) {\n    return ValidationAllocator(@TypeOf(allocator)).init(allocator);\n}","src":116,"more_decls":null}{"doc_comment":"An allocator helper function.  Adjusts an allocation length satisfy `len_align`.\n`full_len` should be the full capacity of the allocation which may be greater\nthan the `len` that was requsted.  This function should only be used by allocators\nthat are unaffected by `len_align`.","pl":"fn alignAllocLen(full_len: usize, alloc_len: usize, len_align: u29) usize","src":124,"more_decls":null}{"doc_comment":"Copy all of source into dest at position 0.\ndest.len must be >= source.len.\nIf the slices overlap, dest.ptr must be <= src.ptr.","pl":"fn copy(comptime T: type, dest: []T, source: []const T) void","src":151,"more_decls":null}{"doc_comment":"Copy all of source into dest at position 0.\ndest.len must be >= source.len.\nIf the slices overlap, dest.ptr must be >= src.ptr.","pl":"fn copyBackwards(comptime T: type, dest: []T, source: []const T) void","src":164,"more_decls":null}{"doc_comment":"Sets all elements of `dest` to `value`.","pl":"pub fn set(comptime T: type, dest: []T, value: T) void {\n    for (dest) |*d|\n        d.* = value;\n}","src":178,"more_decls":null}{"doc_comment":"Generally, Zig users are encouraged to explicitly initialize all fields of a struct explicitly rather than using this function.\nHowever, it is recognized that there are sometimes use cases for initializing all fields to a \"zero\" value. For example, when\ninterfacing with a C API where this practice is more common and relied upon. If you are performing code review and see this\nfunction used, examine closely - it may be a code smell.\nZero initializes the type.\nThis can be used to zero initialize a any type for which it makes sense. Structs will be initialized recursively.","pl":"fn zeroes(comptime T: type) T","src":189,"more_decls":null}{"doc_comment":"Initializes all fields of the struct with their default value, or zero values if no default value is present.\nIf the field is present in the provided initial values, it will have that value instead.\nStructs are initialized recursively.","pl":"fn zeroInit(comptime T: type, init: anytype) T","src":356,"more_decls":null}{"doc_comment":"Compares two slices of numbers lexicographically. O(n).","pl":"fn order(comptime T: type, lhs: []const T, rhs: []const T) math.Order","src":450,"more_decls":null}{"doc_comment":"Returns true if lhs < rhs, false otherwise","pl":"pub fn lessThan(comptime T: type, lhs: []const T, rhs: []const T) bool {\n    return order(T, lhs, rhs) == .lt;\n}","src":472,"more_decls":null}{"doc_comment":"Compares two slices and returns whether they are equal.","pl":"fn eql(comptime T: type, a: []const T, b: []const T) bool","src":485,"more_decls":null}{"doc_comment":"Compares two slices and returns the index of the first inequality.\nReturns null if the slices are equal.","pl":"fn indexOfDiff(comptime T: type, a: []const T, b: []const T) ?usize","src":496,"more_decls":null}{"doc_comment":"Takes a pointer to an array, a sentinel-terminated pointer, or a slice, and\nreturns a slice. If there is a sentinel on the input type, there will be a\nsentinel on the output type. The constness of the output type matches\nthe constness of the input type. `[*c]` pointers are assumed to be 0-terminated,\nand assumed to not allow null.","pl":"fn Span(comptime T: type) type","src":521,"more_decls":null}{"doc_comment":"Takes a pointer to an array, a sentinel-terminated pointer, or a slice, and\nreturns a slice. If there is a sentinel on the input type, there will be a\nsentinel on the output type. The constness of the output type matches\nthe constness of the input type.\n\nWhen there is both a sentinel and an array length or slice length, the\nlength value is used instead of the sentinel.","pl":"fn span(ptr: anytype) Span(@TypeOf(ptr))","src":579,"more_decls":null}{"doc_comment":"Same as `span`, except when there is both a sentinel and an array\nlength or slice length, scans the memory for the sentinel value\nrather than using the length.","pl":"fn spanZ(ptr: anytype) Span(@TypeOf(ptr))","src":607,"more_decls":null}{"doc_comment":"Takes a pointer to an array, an array, a vector, a sentinel-terminated pointer,\na slice or a tuple, and returns the length.\nIn the case of a sentinel-terminated array, it uses the array length.\nFor C pointers it assumes it is a pointer-to-many with a 0 sentinel.","pl":"fn len(value: anytype) usize","src":636,"more_decls":null}{"doc_comment":"Takes a pointer to an array, an array, a sentinel-terminated pointer,\nor a slice, and returns the length.\nIn the case of a sentinel-terminated array, it scans the array\nfor a sentinel and uses that for the length, rather than using the array length.\nFor C pointers it assumes it is a pointer-to-many with a 0 sentinel.","pl":"fn lenZ(ptr: anytype) usize","src":695,"more_decls":null}{"pl":"fn indexOfSentinel(comptime Elem: type, comptime sentinel: Elem, ptr: [*:sentinel]const Elem) usize","src":745,"more_decls":null}{"doc_comment":"Returns true if all elements in a slice are equal to the scalar value provided","pl":"pub fn allEqual(comptime T: type, slice: []const T, scalar: T) bool {\n    for (slice) |item| {\n        if (item != scalar) return false;\n    }\n    return true;\n}","src":754,"more_decls":null}{"doc_comment":"Deprecated, use `Allocator.dupe`.","pl":"pub fn dupe(allocator: *Allocator, comptime T: type, m: []const T) ![]T {\n    return allocator.dupe(T, m);\n}","src":762,"more_decls":null}{"doc_comment":"Deprecated, use `Allocator.dupeZ`.","pl":"pub fn dupeZ(allocator: *Allocator, comptime T: type, m: []const T) ![:0]T {\n    return allocator.dupeZ(T, m);\n}","src":767,"more_decls":null}{"doc_comment":"Remove values from the beginning of a slice.","pl":"pub fn trimLeft(comptime T: type, slice: []const T, values_to_strip: []const T) []const T {\n    var begin: usize = 0;\n    while (begin < slice.len and indexOfScalar(T, values_to_strip, slice[begin]) != null) : (begin += 1) {}\n    return slice[begin..];\n}","src":772,"more_decls":null}{"doc_comment":"Remove values from the end of a slice.","pl":"pub fn trimRight(comptime T: type, slice: []const T, values_to_strip: []const T) []const T {\n    var end: usize = slice.len;\n    while (end > 0 and indexOfScalar(T, values_to_strip, slice[end - 1]) != null) : (end -= 1) {}\n    return slice[0..end];\n}","src":779,"more_decls":null}{"doc_comment":"Remove values from the beginning and end of a slice.","pl":"fn trim(comptime T: type, slice: []const T, values_to_strip: []const T) []const T","src":786,"more_decls":null}{"doc_comment":"Linear search for the index of a scalar value inside a slice.","pl":"pub fn indexOfScalar(comptime T: type, slice: []const T, value: T) ?usize {\n    return indexOfScalarPos(T, slice, 0, value);\n}","src":802,"more_decls":null}{"doc_comment":"Linear search for the last index of a scalar value inside a slice.","pl":"fn lastIndexOfScalar(comptime T: type, slice: []const T, value: T) ?usize","src":807,"more_decls":null}{"pl":"fn indexOfScalarPos(comptime T: type, slice: []const T, start_index: usize, value: T) ?usize","src":816,"more_decls":null}{"pl":"pub fn indexOfAny(comptime T: type, slice: []const T, values: []const T) ?usize {\n    return indexOfAnyPos(T, slice, 0, values);\n}","src":824,"more_decls":null}{"pl":"fn lastIndexOfAny(comptime T: type, slice: []const T, values: []const T) ?usize","src":828,"more_decls":null}{"pl":"fn indexOfAnyPos(comptime T: type, slice: []const T, start_index: usize, values: []const T) ?usize","src":839,"more_decls":null}{"pl":"pub fn indexOf(comptime T: type, haystack: []const T, needle: []const T) ?usize {\n    return indexOfPos(T, haystack, 0, needle);\n}","src":849,"more_decls":null}{"doc_comment":"Find the index in a slice of a sub-slice, searching from the end backwards.\nTo start looking at a different index, slice the haystack first.\nConsider using `lastIndexOf` instead of this, which will automatically use a\nmore sophisticated algorithm on larger inputs.","pl":"fn lastIndexOfLinear(comptime T: type, haystack: []const T, needle: []const T) ?usize","src":857,"more_decls":null}{"doc_comment":"Consider using `indexOfPos` instead of this, which will automatically use a\nmore sophisticated algorithm on larger inputs.","pl":"fn indexOfPosLinear(comptime T: type, haystack: []const T, start_index: usize, needle: []const T) ?usize","src":867,"more_decls":null}{"doc_comment":"Find the index in a slice of a sub-slice, searching from the end backwards.\nTo start looking at a different index, slice the haystack first.\nUses the Reverse boyer-moore-horspool algorithm on large inputs;\n`lastIndexOfLinear` on small inputs.","pl":"fn lastIndexOf(comptime T: type, haystack: []const T, needle: []const T) ?usize","src":905,"more_decls":null}{"doc_comment":"Uses Boyer-moore-horspool algorithm on large inputs; `indexOfPosLinear` on small inputs.","pl":"fn indexOfPos(comptime T: type, haystack: []const T, start_index: usize, needle: []const T) ?usize","src":930,"more_decls":null}{"doc_comment":"Returns the number of needles inside the haystack\nneedle.len must be > 0\ndoes not count overlapping needles","pl":"fn count(comptime T: type, haystack: []const T, needle: []const T) usize","src":980,"more_decls":null}{"doc_comment":"Returns true if the haystack contains expected_count or more needles\nneedle.len must be > 0\ndoes not count overlapping needles","pl":"fn containsAtLeast(comptime T: type, haystack: []const T, expected_count: usize, needle: []const T) bool","src":1010,"more_decls":null}{"doc_comment":"Reads an integer from memory with size equal to bytes.len.\nT specifies the return type, which must be large enough to store\nthe result.","pl":"fn readVarInt(comptime ReturnType: type, bytes: []const u8, endian: builtin.Endian) ReturnType","src":1044,"more_decls":null}{"doc_comment":"Reads an integer from memory with bit count specified by T.\nThe bit count of T must be evenly divisible by 8.\nThis function cannot fail and cannot cause undefined behavior.\nAssumes the endianness of memory is native. This means the function can\nsimply pointer cast memory.","pl":"pub fn readIntNative(comptime T: type, bytes: *const [@divExact(@typeInfo(T).Int.bits, 8)]u8) T {\n    return @ptrCast(*align(1) const T, bytes).*;\n}","src":1067,"more_decls":null}{"doc_comment":"Reads an integer from memory with bit count specified by T.\nThe bit count of T must be evenly divisible by 8.\nThis function cannot fail and cannot cause undefined behavior.\nAssumes the endianness of memory is foreign, so it must byte-swap.","pl":"pub fn readIntForeign(comptime T: type, bytes: *const [@divExact(@typeInfo(T).Int.bits, 8)]u8) T {\n    return @byteSwap(T, readIntNative(T, bytes));\n}","src":1075,"more_decls":null}{"doc_comment":"Asserts that bytes.len >= @typeInfo(T).Int.bits / 8. Reads the integer starting from index 0\nand ignores extra bytes.\nThe bit count of T must be evenly divisible by 8.\nAssumes the endianness of memory is native. This means the function can\nsimply pointer cast memory.","pl":"pub fn readIntSliceNative(comptime T: type, bytes: []const u8) T {\n    const n = @divExact(@typeInfo(T).Int.bits, 8);\n    assert(bytes.len >= n);\n    return readIntNative(T, bytes[0..n]);\n}","src":1094,"more_decls":null}{"doc_comment":"Asserts that bytes.len >= @typeInfo(T).Int.bits / 8. Reads the integer starting from index 0\nand ignores extra bytes.\nThe bit count of T must be evenly divisible by 8.\nAssumes the endianness of memory is foreign, so it must byte-swap.","pl":"pub fn readIntSliceForeign(comptime T: type, bytes: []const u8) T {\n    return @byteSwap(T, readIntSliceNative(T, bytes));\n}","src":1104,"more_decls":null}{"doc_comment":"Reads an integer from memory with bit count specified by T.\nThe bit count of T must be evenly divisible by 8.\nThis function cannot fail and cannot cause undefined behavior.","pl":"fn readInt(comptime T: type, bytes: *const [@divExact(@typeInfo(T).Int.bits, 8)]u8, endian: builtin.Endian) T","src":1121,"more_decls":null}{"doc_comment":"Asserts that bytes.len >= @typeInfo(T).Int.bits / 8. Reads the integer starting from index 0\nand ignores extra bytes.\nThe bit count of T must be evenly divisible by 8.","pl":"pub fn readIntSlice(comptime T: type, bytes: []const u8, endian: builtin.Endian) T {\n    const n = @divExact(@typeInfo(T).Int.bits, 8);\n    assert(bytes.len >= n);\n    return readInt(T, bytes[0..n], endian);\n}","src":1132,"more_decls":null}{"doc_comment":"Writes an integer to memory, storing it in twos-complement.\nThis function always succeeds, has defined behavior for all inputs, and\naccepts any integer bit width.\nThis function stores in native endian, which means it is implemented as a simple\nmemory store.","pl":"pub fn writeIntNative(comptime T: type, buf: *[(@typeInfo(T).Int.bits + 7) / 8]u8, value: T) void {\n    @ptrCast(*align(1) T, buf).* = value;\n}","src":1178,"more_decls":null}{"doc_comment":"Writes an integer to memory, storing it in twos-complement.\nThis function always succeeds, has defined behavior for all inputs, but\nthe integer bit width must be divisible by 8.\nThis function stores in foreign endian, which means it does a @byteSwap first.","pl":"pub fn writeIntForeign(comptime T: type, buf: *[@divExact(@typeInfo(T).Int.bits, 8)]u8, value: T) void {\n    writeIntNative(T, buf, @byteSwap(T, value));\n}","src":1186,"more_decls":null}{"doc_comment":"Writes an integer to memory, storing it in twos-complement.\nThis function always succeeds, has defined behavior for all inputs, but\nthe integer bit width must be divisible by 8.","pl":"fn writeInt(comptime T: type, buffer: *[@divExact(@typeInfo(T).Int.bits, 8)]u8, value: T, endian: builtin.Endian) void","src":1203,"more_decls":null}{"doc_comment":"Writes a twos-complement little-endian integer to memory.\nAsserts that buf.len >= @typeInfo(T).Int.bits / 8.\nThe bit count of T must be divisible by 8.\nAny extra bytes in buffer after writing the integer are set to zero. To\navoid the branch to check for extra buffer bytes, use writeIntLittle\ninstead.","pl":"fn writeIntSliceLittle(comptime T: type, buffer: []u8, value: T) void","src":1217,"more_decls":null}{"doc_comment":"Writes a twos-complement big-endian integer to memory.\nAsserts that buffer.len >= @typeInfo(T).Int.bits / 8.\nThe bit count of T must be divisible by 8.\nAny extra bytes in buffer before writing the integer are set to zero. To\navoid the branch to check for extra buffer bytes, use writeIntBig instead.","pl":"fn writeIntSliceBig(comptime T: type, buffer: []u8, value: T) void","src":1237,"more_decls":null}{"doc_comment":"Writes a twos-complement integer to memory, with the specified endianness.\nAsserts that buf.len >= @typeInfo(T).Int.bits / 8.\nThe bit count of T must be evenly divisible by 8.\nAny extra bytes in buffer not part of the integer are set to zero, with\nrespect to endianness. To avoid the branch to check for extra buffer bytes,\nuse writeInt instead.","pl":"fn writeIntSlice(comptime T: type, buffer: []u8, value: T, endian: builtin.Endian) void","src":1270,"more_decls":null}{"doc_comment":"Returns an iterator that iterates over the slices of `buffer` that are not\nany of the bytes in `delimiter_bytes`.\ntokenize(\"   abc def    ghi  \", \" \")\nWill return slices for \"abc\", \"def\", \"ghi\", null, in that order.\nIf `buffer` is empty, the iterator will return null.\nIf `delimiter_bytes` does not exist in buffer,\nthe iterator will return `buffer`, null, in that order.\nSee also the related function `split`.","pl":"fn tokenize(buffer: []const u8, delimiter_bytes: []const u8) TokenIterator","src":1323,"more_decls":null}{"doc_comment":"Returns an iterator that iterates over the slices of `buffer` that\nare separated by bytes in `delimiter`.\nsplit(\"abc|def||ghi\", \"|\")\nwill return slices for \"abc\", \"def\", \"\", \"ghi\", null, in that order.\nIf `delimiter` does not exist in buffer,\nthe iterator will return `buffer`, null, in that order.\nThe delimiter length must not be zero.\nSee also the related function `tokenize`.","pl":"fn split(buffer: []const u8, delimiter: []const u8) SplitIterator","src":1397,"more_decls":null}{"pl":"pub fn startsWith(comptime T: type, haystack: []const T, needle: []const T) bool {\n    return if (needle.len > haystack.len) false else eql(T, haystack[0..needle.len], needle);\n}","src":1440,"more_decls":null}{"pl":"pub fn endsWith(comptime T: type, haystack: []const T, needle: []const T) bool {\n    return if (needle.len > haystack.len) false else eql(T, haystack[haystack.len - needle.len ..], needle);\n}","src":1449,"more_decls":null}{"doc_comment":"Naively combines a series of slices with a separator.\nAllocates memory for the result, which must be freed by the caller.","pl":"pub fn join(allocator: *Allocator, separator: []const u8, slices: []const []const u8) ![]u8 {\n    return joinMaybeZ(allocator, separator, slices, false);\n}","src":1530,"more_decls":null}{"doc_comment":"Naively combines a series of slices with a separator and null terminator.\nAllocates memory for the result, which must be freed by the caller.","pl":"pub fn joinZ(allocator: *Allocator, separator: []const u8, slices: []const []const u8) ![:0]u8 {\n    const out = try joinMaybeZ(allocator, separator, slices, true);\n    return out[0 .. out.len - 1 :0];\n}","src":1536,"more_decls":null}{"doc_comment":"Copies each T from slices into a new slice that exactly holds all the elements.","pl":"fn concat(allocator: *Allocator, comptime T: type, slices: []const []const T) ![]T","src":1620,"more_decls":null}{"doc_comment":"Returns the smallest number in a slice. O(n).\n`slice` must not be empty.","pl":"fn min(comptime T: type, slice: []const T) T","src":1813,"more_decls":null}{"doc_comment":"Returns the largest number in a slice. O(n).\n`slice` must not be empty.","pl":"fn max(comptime T: type, slice: []const T) T","src":1827,"more_decls":null}{"pl":"pub fn swap(comptime T: type, a: *T, b: *T) void {\n    const tmp = a.*;\n    a.* = b.*;\n    b.* = tmp;\n}","src":1839,"more_decls":null}{"doc_comment":"In-place order reversal of a slice","pl":"fn reverse(comptime T: type, items: []T) void","src":1846,"more_decls":null}{"doc_comment":"In-place rotation of the values in an array ([0 1 2 3] becomes [1 2 3 0] if we rotate by 1)\nAssumes 0 <= amount <= items.len","pl":"pub fn rotate(comptime T: type, items: []T, amount: usize) void {\n    reverse(T, items[0..amount]);\n    reverse(T, items[amount..]);\n    reverse(T, items);\n}","src":1863,"more_decls":null}{"doc_comment":"Replace needle with replacement as many times as possible, writing to an output buffer which is assumed to be of\nappropriate size. Use replacementSize to calculate an appropriate buffer size.","pl":"fn replace(comptime T: type, input: []const T, needle: []const T, replacement: []const T, output: []T) usize","src":1878,"more_decls":null}{"doc_comment":"Calculate the size needed in an output buffer to perform a replacement.","pl":"fn replacementSize(comptime T: type, input: []const T, needle: []const T, replacement: []const T) usize","src":1910,"more_decls":null}{"doc_comment":"Perform a replacement on an allocated buffer of pre-determined size. Caller must free returned memory.","pl":"pub fn replaceOwned(comptime T: type, allocator: *Allocator, input: []const T, needle: []const T, replacement: []const T) Allocator.Error![]T {\n    var output = try allocator.alloc(T, replacementSize(T, input, needle, replacement));\n    _ = replace(T, input, needle, replacement, output);\n    return output;\n}","src":1931,"more_decls":null}{"doc_comment":"Converts a little-endian integer to host endianness.","pl":"pub fn littleToNative(comptime T: type, x: T) T {\n    return switch (builtin.endian) {\n        .Little => x,\n        .Big => @byteSwap(T, x),\n    };\n}","src":1950,"more_decls":null}{"doc_comment":"Converts a big-endian integer to host endianness.","pl":"pub fn bigToNative(comptime T: type, x: T) T {\n    return switch (builtin.endian) {\n        .Little => @byteSwap(T, x),\n        .Big => x,\n    };\n}","src":1958,"more_decls":null}{"doc_comment":"Converts an integer from specified endianness to host endianness.","pl":"pub fn toNative(comptime T: type, x: T, endianness_of_x: builtin.Endian) T {\n    return switch (endianness_of_x) {\n        .Little => littleToNative(T, x),\n        .Big => bigToNative(T, x),\n    };\n}","src":1966,"more_decls":null}{"doc_comment":"Converts an integer which has host endianness to the desired endianness.","pl":"pub fn nativeTo(comptime T: type, x: T, desired_endianness: builtin.Endian) T {\n    return switch (desired_endianness) {\n        .Little => nativeToLittle(T, x),\n        .Big => nativeToBig(T, x),\n    };\n}","src":1974,"more_decls":null}{"doc_comment":"Converts an integer which has host endianness to little endian.","pl":"pub fn nativeToLittle(comptime T: type, x: T) T {\n    return switch (builtin.endian) {\n        .Little => x,\n        .Big => @byteSwap(T, x),\n    };\n}","src":1982,"more_decls":null}{"doc_comment":"Converts an integer which has host endianness to big endian.","pl":"pub fn nativeToBig(comptime T: type, x: T) T {\n    return switch (builtin.endian) {\n        .Little => @byteSwap(T, x),\n        .Big => x,\n    };\n}","src":1990,"more_decls":null}{"doc_comment":"Given a pointer to a single item, returns a slice of the underlying bytes, preserving pointer attributes.","pl":"pub fn asBytes(ptr: anytype) AsBytesReturnType(@TypeOf(ptr)) {\n    const P = @TypeOf(ptr);\n    return @ptrCast(AsBytesReturnType(P), ptr);\n}","src":2022,"more_decls":null}{"doc_comment":"Given any value, returns a copy of its bytes in an array.","pl":"pub fn toBytes(value: anytype) [@sizeOf(@TypeOf(value))]u8 {\n    return asBytes(&value).*;\n}","src":2076,"more_decls":null}{"doc_comment":"Given a pointer to an array of bytes, returns a pointer to a value of the specified type\nbacked by those bytes, preserving pointer attributes.","pl":"pub fn bytesAsValue(comptime T: type, bytes: anytype) BytesAsValueReturnType(T, @TypeOf(bytes)) {\n    return @ptrCast(BytesAsValueReturnType(T, @TypeOf(bytes)), bytes);\n}","src":2109,"more_decls":null}{"doc_comment":"Given a pointer to an array of bytes, returns a value of the specified type backed by a\ncopy of those bytes.","pl":"pub fn bytesToValue(comptime T: type, bytes: anytype) T {\n    return bytesAsValue(T, bytes).*;\n}","src":2166,"more_decls":null}{"doc_comment":"Given a slice of bytes, returns a slice of the specified type\nbacked by those bytes, preserving pointer attributes.","pl":"fn bytesAsSlice(comptime T: type, bytes: anytype) BytesAsSliceReturnType(T, @TypeOf(bytes))","src":2193,"more_decls":null}{"doc_comment":"Given a slice, returns a slice of the underlying bytes, preserving pointer attributes.","pl":"fn sliceAsBytes(slice: anytype) SliceAsBytesReturnType(@TypeOf(slice))","src":2281,"more_decls":null}{"doc_comment":"Round an address up to the nearest aligned address\nThe alignment must be a power of 2 and greater than 0.","pl":"pub fn alignForward(addr: usize, alignment: usize) usize {\n    return alignForwardGeneric(usize, addr, alignment);\n}","src":2378,"more_decls":null}{"doc_comment":"Round an address up to the nearest aligned address\nThe alignment must be a power of 2 and greater than 0.","pl":"pub fn alignForwardGeneric(comptime T: type, addr: T, alignment: T) T {\n    return alignBackwardGeneric(T, addr + (alignment - 1), alignment);\n}","src":2384,"more_decls":null}{"doc_comment":"Force an evaluation of the expression; this tries to prevent\nthe compiler from optimizing the computation away even if the\nresult eventually gets discarded.","pl":"fn doNotOptimizeAway(val: anytype) void","src":2391,"more_decls":null}{"doc_comment":"Round an address up to the previous aligned address\nUnlike `alignBackward`, `alignment` can be any positive number, not just a power of 2.","pl":"pub fn alignBackwardAnyAlign(i: usize, alignment: usize) usize {\n    if (@popCount(usize, alignment) == 1)\n        return alignBackward(i, alignment);\n    assert(alignment != 0);\n    return i - @mod(i, alignment);\n}","src":2416,"more_decls":null}{"doc_comment":"Round an address up to the previous aligned address\nThe alignment must be a power of 2 and greater than 0.","pl":"pub fn alignBackward(addr: usize, alignment: usize) usize {\n    return alignBackwardGeneric(usize, addr, alignment);\n}","src":2425,"more_decls":null}{"doc_comment":"Round an address up to the previous aligned address\nThe alignment must be a power of 2 and greater than 0.","pl":"fn alignBackwardGeneric(comptime T: type, addr: T, alignment: T) T","src":2431,"more_decls":null}{"doc_comment":"Returns whether `alignment` is a valid alignment, meaning it is\na positive power of 2.","pl":"pub fn isValidAlign(alignment: u29) bool {\n    return @popCount(u29, alignment) == 1;\n}","src":2441,"more_decls":null}{"pl":"pub fn isAlignedAnyAlign(i: usize, alignment: usize) bool {\n    if (@popCount(usize, alignment) == 1)\n        return isAligned(i, alignment);\n    assert(alignment != 0);\n    return 0 == @mod(i, alignment);\n}","src":2445,"more_decls":null}{"doc_comment":"Given an address and an alignment, return true if the address is a multiple of the alignment\nThe alignment must be a power of 2 and greater than 0.","pl":"pub fn isAligned(addr: usize, alignment: usize) bool {\n    return isAlignedGeneric(u64, addr, alignment);\n}","src":2454,"more_decls":null}{"pl":"pub fn isAlignedGeneric(comptime T: type, addr: T, alignment: T) bool {\n    return alignBackwardGeneric(T, addr, alignment) == addr;\n}","src":2458,"more_decls":null}{"doc_comment":"Returns the largest slice in the given bytes that conforms to the new alignment,\nor `null` if the given bytes contain no conforming address.","pl":"fn alignInBytes(bytes: []u8, comptime new_alignment: usize) ?[]align(new_alignment) u8","src":2502,"more_decls":null}{"doc_comment":"Returns the largest sub-slice within the given slice that conforms to the new alignment,\nor `null` if the given slice contains no conforming address.","pl":"fn alignInSlice(slice: anytype, comptime new_alignment: usize) ?AlignedSlice(@TypeOf(slice), new_alignment)","src":2516,"more_decls":null}{"doc_comment":"Compile time known minimum page size.\nhttps://github.com/ziglang/zig/issues/4082","pl":"const page_size = switch (builtin.arch) {\n    .wasm32, .wasm64 => 64 * 1024,\n    .aarch64 => switch (builtin.os.tag) {\n        .macos, .ios, .watchos, .tvos => 16 * 1024,\n        else => 4 * 1024,\n    },\n    .sparcv9 => 8 * 1024,\n    else => 4 * 1024,\n}","src":17,"more_decls":null}{"doc_comment":"The standard library currently thoroughly depends on byte size\nbeing 8 bits.  (see the use of u8 throughout allocation code as\nthe \"byte\" type.)  Code which depends on this can reference this\ndeclaration.  If we ever try to port the standard library to a\nnon-8-bit-byte platform, this will allow us to search for things\nwhich need to be updated.","pl":"const byte_size_in_bits = 8","src":33,"more_decls":null}{"pl":"const Allocator = @import(\"mem/Allocator.zig\")","src":35,"more_decls":null}{"pl":"const toSliceConst = @compileError(\"deprecated; use std.mem.spanZ\")","src":513,"more_decls":null}{"pl":"const toSlice = @compileError(\"deprecated; use std.mem.spanZ\")","src":514,"more_decls":null}{"pl":"const readIntLittle = switch (builtin.endian) {\n    .Little => readIntNative,\n    .Big => readIntForeign,\n}","src":1079,"more_decls":null}{"pl":"const readIntBig = switch (builtin.endian) {\n    .Little => readIntForeign,\n    .Big => readIntNative,\n}","src":1084,"more_decls":null}{"pl":"const readIntSliceLittle = switch (builtin.endian) {\n    .Little => readIntSliceNative,\n    .Big => readIntSliceForeign,\n}","src":1108,"more_decls":null}{"pl":"const readIntSliceBig = switch (builtin.endian) {\n    .Little => readIntSliceForeign,\n    .Big => readIntSliceNative,\n}","src":1113,"more_decls":null}{"pl":"const writeIntLittle = switch (builtin.endian) {\n    .Little => writeIntNative,\n    .Big => writeIntForeign,\n}","src":1190,"more_decls":null}{"pl":"const writeIntBig = switch (builtin.endian) {\n    .Little => writeIntForeign,\n    .Big => writeIntNative,\n}","src":1195,"more_decls":null}{"pl":"const writeIntSliceNative = switch (builtin.endian) {\n    .Little => writeIntSliceLittle,\n    .Big => writeIntSliceBig,\n}","src":1254,"more_decls":null}{"pl":"const writeIntSliceForeign = switch (builtin.endian) {\n    .Little => writeIntSliceBig,\n    .Big => writeIntSliceLittle,\n}","src":1259,"more_decls":null}{"pl":"const separate = @compileError(\"deprecated: renamed to split (behavior remains unchanged)\")","src":1406,"more_decls":null}]