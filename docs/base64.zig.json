[{"doc_comment":"Base64 codecs","pl":"pub const Codecs = struct ","src":17,"more_decls":{"pl":"alphabet_chars: [64]u8","src":18,"more_decls":null}{"pl":"pad_char: ?u8","src":19,"more_decls":null}{"pl":"decoderWithIgnore: fn (ignore: []const u8) Base64DecoderWithIgnore","src":20,"more_decls":null}{"pl":"Encoder: Base64Encoder","src":21,"more_decls":null}{"pl":"Decoder: Base64Decoder","src":22,"more_decls":null}}{"pl":"pub const Base64Encoder = struct ","src":80,"more_decls":{"pl":"alphabet_chars: [64]u8","src":81,"more_decls":null}{"pl":"pad_char: ?u8","src":82,"more_decls":null}{"doc_comment":"A bunch of assertions, then simply pass the data right through.","pl":"fn init(alphabet_chars: [64]u8, pad_char: ?u8) Base64Encoder","src":85,"more_decls":null}{"doc_comment":"Compute the encoded length","pl":"fn calcSize(encoder: *const Base64Encoder, source_len: usize) usize","src":100,"more_decls":null}{"doc_comment":"dest.len must at least be what you get from ::calcSize.","pl":"fn encode(encoder: *const Base64Encoder, dest: []u8, source: []const u8) []const u8","src":110,"more_decls":null}}{"pl":"pub const Base64Decoder = struct ","src":142,"more_decls":{"doc_comment":"e.g. 'A' => 0.\n`invalid_char` for any value not in the 64 alphabet chars.","pl":"char_to_index: [256]u8","src":147,"more_decls":null}{"pl":"pad_char: ?u8","src":148,"more_decls":null}{"pl":"fn init(alphabet_chars: [64]u8, pad_char: ?u8) Base64Decoder","src":150,"more_decls":null}{"doc_comment":"Return the maximum possible decoded size for a given input length - The actual length may be less if the input includes padding.\n`InvalidPadding` is returned if the input length is not valid.","pl":"fn calcSizeUpperBound(decoder: *const Base64Decoder, source_len: usize) Error!usize","src":169,"more_decls":null}{"doc_comment":"Return the exact decoded size for a slice.\n`InvalidPadding` is returned if the input length is not valid.","pl":"fn calcSizeForSlice(decoder: *const Base64Decoder, source: []const u8) Error!usize","src":183,"more_decls":null}{"doc_comment":"dest.len must be what you get from ::calcSize.\ninvalid characters result in error.InvalidCharacter.\ninvalid padding results in error.InvalidPadding.","pl":"fn decode(decoder: *const Base64Decoder, dest: []u8, source: []const u8) Error!void","src":196,"more_decls":null}}{"pl":"pub const Base64DecoderWithIgnore = struct ","src":237,"more_decls":{"pl":"decoder: Base64Decoder","src":238,"more_decls":null}{"pl":"char_is_ignored: [256]bool","src":239,"more_decls":null}{"pl":"fn init(alphabet_chars: [64]u8, pad_char: ?u8, ignore_chars: []const u8) Base64DecoderWithIgnore","src":241,"more_decls":null}{"doc_comment":"Return the maximum possible decoded size for a given input length - The actual length may be less if the input includes padding\n`InvalidPadding` is returned if the input length is not valid.","pl":"fn calcSizeUpperBound(decoder_with_ignore: *const Base64DecoderWithIgnore, source_len: usize) Error!usize","src":257,"more_decls":null}{"doc_comment":"Invalid characters that are not ignored result in error.InvalidCharacter.\nInvalid padding results in error.InvalidPadding.\nDecoding more data than can fit in dest results in error.NoSpaceLeft. See also ::calcSizeUpperBound.\nReturns the number of bytes written to dest.","pl":"fn decode(decoder_with_ignore: *const Base64DecoderWithIgnore, dest: []u8, source: []const u8) Error!usize","src":270,"more_decls":null}}{"pl":"const Error = error{\n    InvalidCharacter,\n    InvalidPadding,\n    NoSpaceLeft,\n}","src":10,"more_decls":null}{"pl":"const standard_alphabet_chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".*","src":25,"more_decls":null}{"doc_comment":"Standard Base64 codecs, with padding","pl":"const standard = Codecs{\n    .alphabet_chars = standard_alphabet_chars,\n    .pad_char = '=',\n    .decoderWithIgnore = standardBase64DecoderWithIgnore,\n    .Encoder = Base64Encoder.init(standard_alphabet_chars, '='),\n    .Decoder = Base64Decoder.init(standard_alphabet_chars, '='),\n}","src":31,"more_decls":null}{"doc_comment":"Standard Base64 codecs, without padding","pl":"const standard_no_pad = Codecs{\n    .alphabet_chars = standard_alphabet_chars,\n    .pad_char = null,\n    .decoderWithIgnore = standardBase64DecoderWithIgnore,\n    .Encoder = Base64Encoder.init(standard_alphabet_chars, null),\n    .Decoder = Base64Decoder.init(standard_alphabet_chars, null),\n}","src":40,"more_decls":null}{"pl":"const url_safe_alphabet_chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\".*","src":48,"more_decls":null}{"doc_comment":"URL-safe Base64 codecs, with padding","pl":"const url_safe = Codecs{\n    .alphabet_chars = url_safe_alphabet_chars,\n    .pad_char = '=',\n    .decoderWithIgnore = urlSafeBase64DecoderWithIgnore,\n    .Encoder = Base64Encoder.init(url_safe_alphabet_chars, '='),\n    .Decoder = Base64Decoder.init(url_safe_alphabet_chars, '='),\n}","src":54,"more_decls":null}{"doc_comment":"URL-safe Base64 codecs, without padding","pl":"const url_safe_no_pad = Codecs{\n    .alphabet_chars = url_safe_alphabet_chars,\n    .pad_char = null,\n    .decoderWithIgnore = urlSafeBase64DecoderWithIgnore,\n    .Encoder = Base64Encoder.init(url_safe_alphabet_chars, null),\n    .Decoder = Base64Decoder.init(url_safe_alphabet_chars, null),\n}","src":63,"more_decls":null}{"doc_comment":"Deprecated - Use `standard.pad_char`","pl":"const standard_pad_char = standard.pad_char","src":74,"more_decls":null}{"doc_comment":"Deprecated - Use `standard.Encoder`","pl":"const standard_encoder = standard.Encoder","src":76,"more_decls":null}{"doc_comment":"Deprecated - Use `standard.Decoder`","pl":"const standard_decoder = standard.Decoder","src":78,"more_decls":null}]