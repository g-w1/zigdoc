<style type="text/css" >
.more-decls {
    padding-left: 50px;
}
.anal-decl {
 background-color: #F7A41D77;
}
code {
 background-color: #F7A41D77;
}
</style><style type="text/css" >
pre > code {
  display: block;
  overflow: auto;
  padding: 0.5em;
  color: black;
}

details {
  margin-bottom: 0.5em;
  -webkit-touch-callout: none; /* iOS Safari */
    -webkit-user-select: none; /* Safari */
     -khtml-user-select: none; /* Konqueror HTML */
       -moz-user-select: none; /* Old versions of Firefox */
        -ms-user-select: none; /* Internet Explorer/Edge */
            user-select: none; /* Non-prefixed version, currently
                                  supported by Chrome, Edge, Opera and Firefox */
}

.tok {
  color: #333;
  font-style: normal;
}

.code {
  font-family: monospace;
  font-size: 0.8em;
}

.tok-kw {
  color: #333;
  font-weight: bold;
}

.tok-str {
  color: #d14;
}

.tok-builtin {
  color: #0086b3;
}

code.zig {
  color: #777;
  font-style: italic;
}

.tok-fn {
  color: #900;
  font-weight: bold;
}

.tok-null {
  color: #008080;
}

.tok-number {
  color: #008080;
}

.tok-type {
  color: #458;
  font-weight: bold;
}
</style><html><a href="null//array_list.zig"><h1>/array_list.zig</h1></a><div class="more-decls"></div><div class="more-decls"></div><h2 style="color: orange;">funcs:</h2><div class="more-decls"><div class="anal-decl"><b>A contiguous, growable list of items in memory.
This is a wrapper around an array of T values. Initialize with `init`.

This struct internally stores a `std.mem.Allocator` for memory management.
To manually specify an allocator with each method call see `ArrayListUnmanaged`.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">ArrayList</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">type</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">ArrayListAligned</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">null</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>A contiguous, growable list of arbitrarily aligned items in memory.
This is a wrapper around an array of T values aligned to `alignment`-byte
addresses. If the specified alignment is `null`, then `@alignOf(T)` is used.
Initialize with `init`.

This struct internally stores a `std.mem.Allocator` for memory management.
To manually specify an allocator with each method call see `ArrayListAlignedUnmanaged`.
</b><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">ArrayListAligned</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok tok-kw">comptime</span> <span class="tok">alignment</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">?</span><span class="tok tok-type">u29</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">type</span></code></pre><details><summary>fields:</summary><div class="md-fields more-decls"><div class="anal-decl"><b>Contents of the list. Pointers to elements in this slice are
**invalid after resizing operations** on the ArrayList, unless the
operation explicitly either: (1) states otherwise or (2) lists the
invalidated pointers.

The allocator used determines how element pointers are
invalidated, so the behavior may vary between lists. To avoid
illegal behavior, take into account the above paragraph plus the
explicit statements given in each method.
</b><pre><code class="zig"><span class="tok">items</span><span class="tok tok-symbol">:</span> <span class="tok">Slice</span></code></pre></div><div class="anal-decl"><b>How many T values this list can hold without allocating
additional memory.
</b><pre><code class="zig"><span class="tok">capacity</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span></code></pre></div></div></details><details><summary>funcs</summary><div class="md-funcs more-decls"><div class="anal-decl"><b>Deinitialize with `deinit` or use `toOwnedSlice`.
</b><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">init</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">)</span> <span class="tok">Self</span></code></pre></div><div class="anal-decl"><b>Initialize with capacity to hold at least `num` elements.
Deinitialize with `deinit` or use `toOwnedSlice`.
</b><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">initCapacity</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">num</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok">Self</span></code></pre></div><div class="anal-decl"><b>Release all allocated memory.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">deinit</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocator</span><span class="tok tok-symbol">.</span><span class="tok">free</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocatedSlice</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>ArrayList takes ownership of the passed in slice. The slice must have been
allocated with `allocator`.
Deinitialize with `deinit` or use `toOwnedSlice`.
</b><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">fromOwnedSlice</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">slice</span><span class="tok tok-symbol">:</span> <span class="tok">Slice</span><span class="tok tok-symbol">)</span> <span class="tok">Self</span></code></pre></div><div class="anal-decl"><b>Initializes an ArrayListUnmanaged with the `items` and `capacity` fields
of this ArrayList. This ArrayList retains ownership of underlying memory.
Deprecated: use `moveToUnmanaged` which has different semantics.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">toUnmanaged</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok">ArrayListAlignedUnmanaged</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">alignment</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok tok-symbol">.</span><span class="tok tok-symbol">{</span> <span class="tok tok-symbol">.</span><span class="tok">items</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">,</span> <span class="tok tok-symbol">.</span><span class="tok">capacity</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">capacity</span> <span class="tok tok-symbol">}</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Initializes an ArrayListUnmanaged with the `items` and `capacity` fields
of this ArrayList. Empties this ArrayList.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">moveToUnmanaged</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok">ArrayListAlignedUnmanaged</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">alignment</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">allocator</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocator</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">const</span> <span class="tok">result</span> <span class="tok tok-symbol">=</span> <span class="tok tok-symbol">.</span><span class="tok tok-symbol">{</span> <span class="tok tok-symbol">.</span><span class="tok">items</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">,</span> <span class="tok tok-symbol">.</span><span class="tok">capacity</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">capacity</span> <span class="tok tok-symbol">}</span><span class="tok tok-symbol">;</span>
    <span class="tok">self</span><span class="tok tok-symbol">.*</span> <span class="tok tok-symbol">=</span> <span class="tok">init</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">result</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>The caller owns the returned memory. Empties this ArrayList.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">toOwnedSlice</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok">Slice</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">allocator</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocator</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">const</span> <span class="tok">result</span> <span class="tok tok-symbol">=</span> <span class="tok">allocator</span><span class="tok tok-symbol">.</span><span class="tok">shrink</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocatedSlice</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">self</span><span class="tok tok-symbol">.*</span> <span class="tok tok-symbol">=</span> <span class="tok">init</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">result</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>The caller owns the returned memory. Empties this ArrayList.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">toOwnedSliceSentinel</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok tok-kw">comptime</span> <span class="tok">sentinel</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-symbol">[</span><span class="tok tok-symbol">:</span><span class="tok">sentinel</span><span class="tok tok-symbol">]</span><span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">try</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">append</span><span class="tok tok-symbol">(</span><span class="tok">sentinel</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">const</span> <span class="tok">result</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">toOwnedSlice</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">result</span><span class="tok tok-symbol">[</span><span class="tok tok-number">0</span> <span class="tok tok-symbol">..</span> <span class="tok">result</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">-</span> <span class="tok tok-number">1</span> <span class="tok tok-symbol">:</span><span class="tok">sentinel</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Insert `item` at index `n` by moving `list[n .. list.len]` to make room.
This operation is O(N).
</b><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">insert</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">n</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span> <span class="tok">item</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>Insert slice `items` at index `i` by moving `list[i .. list.len]` to make room.
This operation is O(N).
</b><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">insertSlice</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">i</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span> <span class="tok">items</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>Replace range of elements `list[start..start+len]` with `new_items`.
Grows list if `len &lt; new_items.len`.
Shrinks list if `len &gt; new_items.len`.
Invalidates pointers if this ArrayList is resized.
</b><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">replaceRange</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">start</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span> <span class="tok">len</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span> <span class="tok">new_items</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>Extend the list by 1 element. Allocates more memory as necessary.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">append</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">item</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">new_item_ptr</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">try</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">addOne</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">new_item_ptr</span><span class="tok tok-symbol">.*</span> <span class="tok tok-symbol">=</span> <span class="tok">item</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Extend the list by 1 element, but assert `self.capacity`
is sufficient to hold an additional item. **Does not**
invalidate pointers.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">appendAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">item</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">new_item_ptr</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">addOneAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">new_item_ptr</span><span class="tok tok-symbol">.*</span> <span class="tok tok-symbol">=</span> <span class="tok">item</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Remove the element at index `i`, shift elements after index
`i` forward, and return the removed element.
Asserts the array has at least one item.
Invalidates pointers to end of list.
This operation is O(N).
</b><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">orderedRemove</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">i</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok">T</span></code></pre></div><div class="anal-decl"><b>Removes the element at the specified index and returns it.
The empty slot is filled from the end of the list.
This operation is O(1).
</b><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">swapRemove</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">i</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok">T</span></code></pre></div><div class="anal-decl"><b>Append the slice of items to the list. Allocates more
memory as necessary.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">appendSlice</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">items</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">try</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ensureUnusedCapacity</span><span class="tok tok-symbol">(</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">appendSliceAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok">items</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Append the slice of items to the list, asserting the capacity is already
enough to store the new items. **Does not** invalidate pointers.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">appendSliceAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">items</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">oldlen</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">const</span> <span class="tok">newlen</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">+</span> <span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span><span class="tok tok-symbol">;</span>
    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">=</span> <span class="tok">newlen</span><span class="tok tok-symbol">;</span>
    <span class="tok">mem</span><span class="tok tok-symbol">.</span><span class="tok">copy</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">[</span><span class="tok">oldlen</span><span class="tok tok-symbol">..</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">,</span> <span class="tok">items</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Append a value to the list `n` times.
Allocates more memory as necessary.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">appendNTimes</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">n</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">old_len</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">try</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">resize</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">+</span> <span class="tok">n</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">mem</span><span class="tok tok-symbol">.</span><span class="tok">set</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">[</span><span class="tok">old_len</span><span class="tok tok-symbol">..</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Append a value to the list `n` times.
Asserts the capacity is enough. **Does not** invalidate pointers.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">appendNTimesAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">n</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">new_len</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">+</span> <span class="tok">n</span><span class="tok tok-symbol">;</span>
    <span class="tok">assert</span><span class="tok tok-symbol">(</span><span class="tok">new_len</span> <span class="tok tok-symbol">&lt;=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">capacity</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">mem</span><span class="tok tok-symbol">.</span><span class="tok">set</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">ptr</span><span class="tok tok-symbol">[</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span><span class="tok tok-symbol">..</span><span class="tok">new_len</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">=</span> <span class="tok">new_len</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Adjust the list's length to `new_len`.
Does not initialize added items if any.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">resize</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">new_len</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">try</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ensureTotalCapacity</span><span class="tok tok-symbol">(</span><span class="tok">new_len</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">=</span> <span class="tok">new_len</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Reduce allocated capacity to `new_len`.
May invalidate element pointers.
</b><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">shrinkAndFree</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">new_len</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>Reduce length to `new_len`.
Invalidates pointers for the elements `items[new_len..]`.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">shrinkRetainingCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">new_len</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok">assert</span><span class="tok tok-symbol">(</span><span class="tok">new_len</span> <span class="tok tok-symbol">&lt;=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">=</span> <span class="tok">new_len</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Invalidates all element pointers.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">clearRetainingCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Invalidates all element pointers.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">clearAndFree</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocator</span><span class="tok tok-symbol">.</span><span class="tok">free</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocatedSlice</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">;</span>
    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">capacity</span> <span class="tok tok-symbol">=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Modify the array so that it can hold at least `new_capacity` items.
Invalidates pointers if additional memory is needed.
</b><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">ensureTotalCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">new_capacity</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>Modify the array so that it can hold at least `additional_count` **more** items.
Invalidates pointers if additional memory is needed.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">ensureUnusedCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">additional_count</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ensureTotalCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">+</span> <span class="tok">additional_count</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Increases the array's length to match the full capacity that is already allocated.
The new elements have `undefined` values. **Does not** invalidate pointers.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">expandToCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">capacity</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Increase length by 1, returning pointer to the new item.
The returned pointer becomes invalid when the list resized.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">addOne</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-symbol">*</span><span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">newlen</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">+</span> <span class="tok tok-number">1</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">try</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ensureTotalCapacity</span><span class="tok tok-symbol">(</span><span class="tok">newlen</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">addOneAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Increase length by 1, returning pointer to the new item.
Asserts that there is already space for the new item without allocating more.
The returned pointer becomes invalid when the list is resized.
**Does not** invalidate element pointers.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">addOneAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">*</span><span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok">assert</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">&lt;</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">capacity</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>

    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">+=</span> <span class="tok tok-number">1</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok tok-symbol">&amp;</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">[</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">-</span> <span class="tok tok-number">1</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Resize the array, adding `n` new elements, which have `undefined` values.
The return value is an array pointing to the newly allocated elements.
The returned pointer becomes invalid when the list is resized.
Resizes list if `self.capacity` is not large enough.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">addManyAsArray</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok tok-kw">comptime</span> <span class="tok">n</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-symbol">*</span><span class="tok tok-symbol">[</span><span class="tok">n</span><span class="tok tok-symbol">]</span><span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">prev_len</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">try</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">resize</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">+</span> <span class="tok">n</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">[</span><span class="tok">prev_len</span><span class="tok tok-symbol">..</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">[</span><span class="tok tok-number">0</span><span class="tok tok-symbol">..</span><span class="tok">n</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Resize the array, adding `n` new elements, which have `undefined` values.
The return value is an array pointing to the newly allocated elements.
Asserts that there is already space for the new item without allocating more.
**Does not** invalidate element pointers.
The returned pointer becomes invalid when the list is resized.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">addManyAsArrayAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok tok-kw">comptime</span> <span class="tok">n</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">*</span><span class="tok tok-symbol">[</span><span class="tok">n</span><span class="tok tok-symbol">]</span><span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok">assert</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">+</span> <span class="tok">n</span> <span class="tok tok-symbol">&lt;=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">capacity</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">const</span> <span class="tok">prev_len</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span><span class="tok tok-symbol">;</span>
    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">+=</span> <span class="tok">n</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">[</span><span class="tok">prev_len</span><span class="tok tok-symbol">..</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">[</span><span class="tok tok-number">0</span><span class="tok tok-symbol">..</span><span class="tok">n</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Remove and return the last element from the list.
Asserts the list has at least one item.
Invalidates pointers to the removed element.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">pop</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">val</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">[</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">-</span> <span class="tok tok-number">1</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">;</span>
    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">-=</span> <span class="tok tok-number">1</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">val</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Remove and return the last element from the list, or
return `null` if list is empty.
Invalidates pointers to the removed element, if any.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">popOrNull</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">==</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span> <span class="tok tok-kw">return</span> <span class="tok tok-null">null</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">pop</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Returns a slice of all the items plus the extra capacity, whose memory
contents are `undefined`.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">allocatedSlice</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok">Slice</span> <span class="tok tok-symbol">{</span>
    // For a nicer API, `items.len` is the length, not the capacity.
    // This requires &quot;unsafe&quot; slicing.
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">ptr</span><span class="tok tok-symbol">[</span><span class="tok tok-number">0</span><span class="tok tok-symbol">..</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">capacity</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Returns a slice of only the extra capacity after items.
This can be useful for writing directly into an ArrayList.
Note that such an operation must be followed up with a direct
modification of `self.items.len`.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">unusedCapacitySlice</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok">Slice</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocatedSlice</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">[</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span><span class="tok tok-symbol">..</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div></div></details><details><summary>values:</summary><div class="md-vals more-decls"><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">Slice</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok">alignment</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">|</span><span class="tok">a</span><span class="tok tok-symbol">|</span> <span class="tok tok-symbol">(</span><span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">align</span><span class="tok tok-symbol">(</span><span class="tok">a</span><span class="tok tok-symbol">)</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-kw">else</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok">T</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">span</span> <span class="tok tok-symbol">=</span> <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;deprecated: use `items` field directly&quot;</span><span class="tok tok-symbol">)</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">toSlice</span> <span class="tok tok-symbol">=</span> <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;deprecated: use `items` field directly&quot;</span><span class="tok tok-symbol">)</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">toSliceConst</span> <span class="tok tok-symbol">=</span> <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;deprecated: use `items` field directly&quot;</span><span class="tok tok-symbol">)</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">at</span> <span class="tok tok-symbol">=</span> <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;deprecated: use `list.items[i]`&quot;</span><span class="tok tok-symbol">)</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">ptrAt</span> <span class="tok tok-symbol">=</span> <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;deprecated: use `&amp;list.items[i]`&quot;</span><span class="tok tok-symbol">)</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">setOrError</span> <span class="tok tok-symbol">=</span> <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;deprecated: use `if (i &gt;= list.items.len) return error.OutOfBounds else list.items[i] = item`&quot;</span><span class="tok tok-symbol">)</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">set</span> <span class="tok tok-symbol">=</span> <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;deprecated: use `list.items[i] = item`&quot;</span><span class="tok tok-symbol">)</span></code></pre></div><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">swapRemoveOrError</span> <span class="tok tok-symbol">=</span> <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;deprecated: use `if (i &gt;= list.items.len) return error.OutOfBounds else list.swapRemove(i)`&quot;</span><span class="tok tok-symbol">)</span></code></pre></div><div class="anal-decl"><b>Deprecated: call `ensureUnusedCapacity` or `ensureTotalCapacity`.
</b><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">ensureCapacity</span> <span class="tok tok-symbol">=</span> <span class="tok">ensureTotalCapacity</span></code></pre></div></div></details></div><div class="anal-decl"><b>An ArrayList, but the allocator is passed as a parameter to the relevant functions
rather than stored in the struct itself. The same allocator **must** be used throughout
the entire lifetime of an ArrayListUnmanaged. Initialize directly or with
`initCapacity`, and deinitialize with `deinit` or use `toOwnedSlice`.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">ArrayListUnmanaged</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">type</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">ArrayListAlignedUnmanaged</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">null</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>An ArrayListAligned, but the allocator is passed as a parameter to the relevant
functions rather than stored  in the struct itself. The same allocator **must**
be used throughout the entire lifetime of an ArrayListAlignedUnmanaged.
Initialize directly or with `initCapacity`, and deinitialize with `deinit` or use `toOwnedSlice`.
</b><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">ArrayListAlignedUnmanaged</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok tok-kw">comptime</span> <span class="tok">alignment</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">?</span><span class="tok tok-type">u29</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">type</span></code></pre><details><summary>fields:</summary><div class="md-fields more-decls"><div class="anal-decl"><b>Contents of the list. Pointers to elements in this slice are
**invalid after resizing operations** on the ArrayList, unless the
operation explicitly either: (1) states otherwise or (2) lists the
invalidated pointers.

The allocator used determines how element pointers are
invalidated, so the behavior may vary between lists. To avoid
illegal behavior, take into account the above paragraph plus the
explicit statements given in each method.
</b><pre><code class="zig"><span class="tok">items</span><span class="tok tok-symbol">:</span> <span class="tok">Slice</span> <span class="tok tok-symbol">=</span> <span class="tok tok-symbol">&amp;</span><span class="tok tok-symbol">[</span><span class="tok">_</span><span class="tok tok-symbol">]</span><span class="tok">T</span><span class="tok tok-symbol">{</span><span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>How many T values this list can hold without allocating
additional memory.
</b><pre><code class="zig"><span class="tok">capacity</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span> <span class="tok tok-symbol">=</span> <span class="tok tok-number">0</span></code></pre></div></div></details><details><summary>funcs</summary><div class="md-funcs more-decls"><div class="anal-decl"><b>Initialize with capacity to hold at least num elements.
Deinitialize with `deinit` or use `toOwnedSlice`.
</b><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">initCapacity</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">num</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok">Self</span></code></pre></div><div class="anal-decl"><b>Release all allocated memory.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">deinit</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok">allocator</span><span class="tok tok-symbol">.</span><span class="tok">free</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocatedSlice</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">self</span><span class="tok tok-symbol">.*</span> <span class="tok tok-symbol">=</span> <span class="tok tok-null">undefined</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Convert this list into an analogous memory-managed one.
The returned list has ownership of the underlying memory.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">toManaged</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">)</span> <span class="tok">ArrayListAligned</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">alignment</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok tok-symbol">.</span><span class="tok tok-symbol">{</span> <span class="tok tok-symbol">.</span><span class="tok">items</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">,</span> <span class="tok tok-symbol">.</span><span class="tok">capacity</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">capacity</span><span class="tok tok-symbol">,</span> <span class="tok tok-symbol">.</span><span class="tok">allocator</span> <span class="tok tok-symbol">=</span> <span class="tok">allocator</span> <span class="tok tok-symbol">}</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>The caller owns the returned memory. ArrayList becomes empty.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">toOwnedSlice</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">)</span> <span class="tok">Slice</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">result</span> <span class="tok tok-symbol">=</span> <span class="tok">allocator</span><span class="tok tok-symbol">.</span><span class="tok">shrink</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocatedSlice</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">self</span><span class="tok tok-symbol">.*</span> <span class="tok tok-symbol">=</span> <span class="tok">Self</span><span class="tok tok-symbol">{</span><span class="tok tok-symbol">}</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">result</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>The caller owns the returned memory. ArrayList becomes empty.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">toOwnedSliceSentinel</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok tok-kw">comptime</span> <span class="tok">sentinel</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-symbol">[</span><span class="tok tok-symbol">:</span><span class="tok">sentinel</span><span class="tok tok-symbol">]</span><span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">try</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">append</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">sentinel</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">const</span> <span class="tok">result</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">toOwnedSlice</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">result</span><span class="tok tok-symbol">[</span><span class="tok tok-number">0</span> <span class="tok tok-symbol">..</span> <span class="tok">result</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">-</span> <span class="tok tok-number">1</span> <span class="tok tok-symbol">:</span><span class="tok">sentinel</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Insert `item` at index `n`. Moves `list[n .. list.len]`
to higher indices to make room.
This operation is O(N).
</b><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">insert</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">n</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span> <span class="tok">item</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>Insert slice `items` at index `i`. Moves `list[i .. list.len]` to
higher indicices make room.
This operation is O(N).
</b><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">insertSlice</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">i</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span> <span class="tok">items</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>Replace range of elements `list[start..start+len]` with `new_items`
Grows list if `len &lt; new_items.len`.
Shrinks list if `len &gt; new_items.len`
Invalidates pointers if this ArrayList is resized.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">replaceRange</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">start</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span> <span class="tok">len</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span> <span class="tok">new_items</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">var</span> <span class="tok">managed</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">toManaged</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">try</span> <span class="tok">managed</span><span class="tok tok-symbol">.</span><span class="tok">replaceRange</span><span class="tok tok-symbol">(</span><span class="tok">start</span><span class="tok tok-symbol">,</span> <span class="tok">len</span><span class="tok tok-symbol">,</span> <span class="tok">new_items</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">self</span><span class="tok tok-symbol">.*</span> <span class="tok tok-symbol">=</span> <span class="tok">managed</span><span class="tok tok-symbol">.</span><span class="tok">toUnmanaged</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Extend the list by 1 element. Allocates more memory as necessary.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">append</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">item</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">new_item_ptr</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">try</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">addOne</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">new_item_ptr</span><span class="tok tok-symbol">.*</span> <span class="tok tok-symbol">=</span> <span class="tok">item</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Extend the list by 1 element, but asserting `self.capacity`
is sufficient to hold an additional item.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">appendAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">item</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">new_item_ptr</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">addOneAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">new_item_ptr</span><span class="tok tok-symbol">.*</span> <span class="tok tok-symbol">=</span> <span class="tok">item</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Remove the element at index `i` from the list and return its value.
Asserts the array has at least one item. Invalidates pointers to
last element.
This operation is O(N).
</b><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">orderedRemove</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">i</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok">T</span></code></pre></div><div class="anal-decl"><b>Removes the element at the specified index and returns it.
The empty slot is filled from the end of the list.
Invalidates pointers to last element.
This operation is O(1).
</b><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">swapRemove</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">i</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok">T</span></code></pre></div><div class="anal-decl"><b>Append the slice of items to the list. Allocates more
memory as necessary.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">appendSlice</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">items</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">try</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ensureUnusedCapacity</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">appendSliceAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok">items</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Append the slice of items to the list, asserting the capacity is enough
to store the new items.
</b><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">appendSliceAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">items</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>Append a value to the list `n` times.
Allocates more memory as necessary.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">appendNTimes</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">n</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">old_len</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">try</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">resize</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">+</span> <span class="tok">n</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">mem</span><span class="tok tok-symbol">.</span><span class="tok">set</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">[</span><span class="tok">old_len</span><span class="tok tok-symbol">..</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Append a value to the list `n` times.
**Does not** invalidate pointers.
Asserts the capacity is enough.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">appendNTimesAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">n</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">new_len</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">+</span> <span class="tok">n</span><span class="tok tok-symbol">;</span>
    <span class="tok">assert</span><span class="tok tok-symbol">(</span><span class="tok">new_len</span> <span class="tok tok-symbol">&lt;=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">capacity</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">mem</span><span class="tok tok-symbol">.</span><span class="tok">set</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">ptr</span><span class="tok tok-symbol">[</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span><span class="tok tok-symbol">..</span><span class="tok">new_len</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">=</span> <span class="tok">new_len</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Adjust the list's length to `new_len`.
Does not initialize added items, if any.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">resize</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">new_len</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">try</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ensureTotalCapacity</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">new_len</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">=</span> <span class="tok">new_len</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Reduce allocated capacity to `new_len`.
</b><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">shrinkAndFree</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">new_len</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>Reduce length to `new_len`.
Invalidates pointers to elements `items[new_len..]`.
Keeps capacity the same.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">shrinkRetainingCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">new_len</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok">assert</span><span class="tok tok-symbol">(</span><span class="tok">new_len</span> <span class="tok tok-symbol">&lt;=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">=</span> <span class="tok">new_len</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Invalidates all element pointers.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">clearRetainingCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Invalidates all element pointers.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">clearAndFree</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok">allocator</span><span class="tok tok-symbol">.</span><span class="tok">free</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">allocatedSlice</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">;</span>
    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">capacity</span> <span class="tok tok-symbol">=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Modify the array so that it can hold at least `new_capacity` items.
Invalidates pointers if additional memory is needed.
</b><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">ensureTotalCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">new_capacity</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>Modify the array so that it can hold at least `additional_count` **more** items.
Invalidates pointers if additional memory is needed.
</b><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">ensureUnusedCapacity</span><span class="tok tok-symbol">(</span>
    <span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span>
    <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span>
    <span class="tok">additional_count</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span>
<span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>Increases the array's length to match the full capacity that is already allocated.
The new elements have `undefined` values.
**Does not** invalidate pointers.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">expandToCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">capacity</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Increase length by 1, returning pointer to the new item.
The returned pointer becomes invalid when the list resized.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">addOne</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-symbol">*</span><span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">newlen</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">+</span> <span class="tok tok-number">1</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">try</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">ensureTotalCapacity</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">newlen</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">addOneAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Increase length by 1, returning pointer to the new item.
Asserts that there is already space for the new item without allocating more.
**Does not** invalidate pointers.
The returned pointer becomes invalid when the list resized.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">addOneAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">*</span><span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok">assert</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">&lt;</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">capacity</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>

    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">+=</span> <span class="tok tok-number">1</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok tok-symbol">&amp;</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">[</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">-</span> <span class="tok tok-number">1</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Resize the array, adding `n` new elements, which have `undefined` values.
The return value is an array pointing to the newly allocated elements.
The returned pointer becomes invalid when the list is resized.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">addManyAsArray</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok tok-kw">comptime</span> <span class="tok">n</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-symbol">*</span><span class="tok tok-symbol">[</span><span class="tok">n</span><span class="tok tok-symbol">]</span><span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">prev_len</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">try</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">resize</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">+</span> <span class="tok">n</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">[</span><span class="tok">prev_len</span><span class="tok tok-symbol">..</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">[</span><span class="tok tok-number">0</span><span class="tok tok-symbol">..</span><span class="tok">n</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Resize the array, adding `n` new elements, which have `undefined` values.
The return value is an array pointing to the newly allocated elements.
Asserts that there is already space for the new item without allocating more.
**Does not** invalidate pointers.
The returned pointer becomes invalid when the list is resized.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">addManyAsArrayAssumeCapacity</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">,</span> <span class="tok tok-kw">comptime</span> <span class="tok">n</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">*</span><span class="tok tok-symbol">[</span><span class="tok">n</span><span class="tok tok-symbol">]</span><span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok">assert</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">+</span> <span class="tok">n</span> <span class="tok tok-symbol">&lt;=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">capacity</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">const</span> <span class="tok">prev_len</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span><span class="tok tok-symbol">;</span>
    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">+=</span> <span class="tok">n</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">[</span><span class="tok">prev_len</span><span class="tok tok-symbol">..</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">[</span><span class="tok tok-number">0</span><span class="tok tok-symbol">..</span><span class="tok">n</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Remove and return the last element from the list.
Asserts the list has at least one item.
Invalidates pointers to last element.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">pop</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">val</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">[</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">-</span> <span class="tok tok-number">1</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">;</span>
    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">-=</span> <span class="tok tok-number">1</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">val</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Remove and return the last element from the list.
If the list is empty, returns `null`.
Invalidates pointers to last element.
</b><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">popOrNull</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Self</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">items</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">==</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span> <span class="tok tok-kw">return</span> <span class="tok tok-null">null</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">pop</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div></div></details><details><summary>values:</summary><div class="md-vals more-decls"><div class="anal-decl"><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">Slice</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok">alignment</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">|</span><span class="tok">a</span><span class="tok tok-symbol">|</span> <span class="tok tok-symbol">(</span><span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">align</span><span class="tok tok-symbol">(</span><span class="tok">a</span><span class="tok tok-symbol">)</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-kw">else</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok">T</span></code></pre></div><div class="anal-decl"><b>Deprecated: call `ensureUnusedCapacity` or `ensureTotalCapacity`.
</b><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">ensureCapacity</span> <span class="tok tok-symbol">=</span> <span class="tok">ensureTotalCapacity</span></code></pre></div></div></details></div></div><div class="more-decls"></div></html>