[{"doc_comment":"BufMap copies keys and values before they go into the map, and\nfrees them when they get removed.","pl":"pub const BufMap = struct ","src":13,"more_decls":{"pl":"hash_map: BufMapHashMap","src":14,"more_decls":null}{"pl":"pub fn init(allocator: *Allocator) BufMap {\n    var self = BufMap{ .hash_map = BufMapHashMap.init(allocator) };\n    return self;\n}","src":18,"more_decls":null}{"pl":"fn deinit(self: *BufMap) void","src":23,"more_decls":null}{"doc_comment":"Same as `set` but the key and value become owned by the BufMap rather\nthan being copied.\nIf `setMove` fails, the ownership of key and value does not transfer.","pl":"fn setMove(self: *BufMap, key: []u8, value: []u8) !void","src":37,"more_decls":null}{"doc_comment":"`key` and `value` are copied into the BufMap.","pl":"fn set(self: *BufMap, key: []const u8, value: []const u8) !void","src":48,"more_decls":null}{"pl":"pub fn get(self: BufMap, key: []const u8) ?[]const u8 {\n    return self.hash_map.get(key);\n}","src":63,"more_decls":null}{"pl":"pub fn delete(self: *BufMap, key: []const u8) void {\n    const entry = self.hash_map.remove(key) orelse return;\n    self.free(entry.key);\n    self.free(entry.value);\n}","src":67,"more_decls":null}{"pl":"pub fn count(self: BufMap) usize {\n    return self.hash_map.count();\n}","src":73,"more_decls":null}{"pl":"pub fn iterator(self: *const BufMap) BufMapHashMap.Iterator {\n    return self.hash_map.iterator();\n}","src":77,"more_decls":null}}]