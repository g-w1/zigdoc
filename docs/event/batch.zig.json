[{"doc_comment":"Performs multiple async functions in parallel, without heap allocation.\nAsync function frames are managed externally to this abstraction, and\npassed in via the `add` function. Once all the jobs are added, call `wait`.\nThis API is *not* thread-safe. The object must be accessed from one thread at\na time, however, it need not be the same thread.","pl":"fn Batch(\n    /// The return value for each job.\n    /// If a job slot was re-used due to maxed out concurrency, then its result\n    /// value will be overwritten. The values can be accessed with the `results` field.\n    comptime Result: type,\n    /// How many jobs to run in parallel.\n    comptime max_jobs: comptime_int,\n    /// Controls whether the `add` and `wait` functions will be async functions.\n    comptime async_behavior: enum {\n        /// Observe the value of `std.io.is_async` to decide whether `add`\n        /// and `wait` will be async functions. Asserts that the jobs do not suspend when\n        /// `std.io.mode == .blocking`. This is a generally safe assumption, and the\n        /// usual recommended option for this parameter.\n        auto_async,\n\n        /// Always uses the `nosuspend` keyword when using `await` on the jobs,\n        /// making `add` and `wait` non-async functions. Asserts that the jobs do not suspend.\n        never_async,\n\n        /// `add` and `wait` use regular `await` keyword, making them async functions.\n        always_async,\n    },\n) type","sub_container_type":"struct ","src":13,"more_decls":{"pl":"jobs: [max_jobs]Job","src":37,"more_decls":null}{"pl":"next_job_index: usize","src":38,"more_decls":null}{"pl":"collected_result: CollectedResult","src":39,"more_decls":null}{"pl":"fn init() Self","src":59,"more_decls":null}{"doc_comment":"Add a frame to the Batch. If all jobs are in-flight, then this function\nwaits until one completes.\nThis function is *not* thread-safe. It must be called from one thread at\na time, however, it need not be the same thread.\nTODO: \"select\" language feature to use the next available slot, rather than\nawaiting the next index.","pl":"fn add(self: *Self, frame: anyframe->Result) void","src":78,"more_decls":null}{"doc_comment":"Wait for all the jobs to complete.\nSafe to call any number of times.\nIf `Result` is an error union, this function returns the last error that occurred, if any.\nUnlike the `results` field, the return value of `wait` will report any error that occurred;\nhitting max parallelism will not compromise the result.\nThis function is *not* thread-safe. It must be called from one thread at\na time, however, it need not be the same thread.","pl":"fn wait(self: *Self) CollectedResult","src":99,"more_decls":null}}]