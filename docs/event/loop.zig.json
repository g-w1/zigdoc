[{"pl":"pub const Loop = struct ","src":18,"more_decls":{"pl":"next_tick_queue: std.atomic.Queue(anyframe)","src":19,"more_decls":null}{"pl":"os_data: OsData","src":20,"more_decls":null}{"pl":"final_resume_node: ResumeNode","src":21,"more_decls":null}{"pl":"pending_event_count: usize","src":22,"more_decls":null}{"pl":"extra_threads: []*Thread","src":23,"more_decls":null}{"doc_comment":"TODO change this to a pool of configurable number of threads\nand rename it to be not file-system-specific. it will become\na thread pool for turning non-CPU-bound blocking things into\nasync things. A fallback for any missing OS-specific API.","pl":"fs_thread: *Thread","src":28,"more_decls":null}{"pl":"fs_queue: std.atomic.Queue(Request)","src":29,"more_decls":null}{"pl":"fs_end_request: Request.Node","src":30,"more_decls":null}{"pl":"fs_thread_wakeup: std.Thread.ResetEvent","src":31,"more_decls":null}{"doc_comment":"For resources that have the same lifetime as the `Loop`.\nThis is only used by `Loop` for the thread pool and associated resources.","pl":"arena: std.heap.ArenaAllocator","src":35,"more_decls":null}{"doc_comment":"State which manages frames that are sleeping on timers","pl":"delay_queue: DelayQueue","src":38,"more_decls":null}{"doc_comment":"Pre-allocated eventfds. All permanently active.\nThis is how `Loop` sends promises to be resumed on other threads.","pl":"available_eventfd_resume_nodes: std.atomic.Stack(ResumeNode.EventFd)","src":42,"more_decls":null}{"pl":"eventfd_resume_nodes: []std.atomic.Stack(ResumeNode.EventFd).Node","src":43,"more_decls":null}{"pl":"pub const ResumeNode = struct ","src":47,"more_decls":{"pl":"id: Id","src":48,"more_decls":null}{"pl":"handle: anyframe","src":49,"more_decls":null}{"pl":"overlapped: Overlapped","src":50,"more_decls":null}{"pl":"pub const Id = enum ","src":64,"more_decls":{"pl":"Basic","src":65,"more_decls":null}{"pl":"Stop","src":66,"more_decls":null}{"pl":"EventFd","src":67,"more_decls":null}}{"pl":"const overlapped_init = switch (builtin.os.tag) {\n            .windows => windows.OVERLAPPED{\n                .Internal = 0,\n                .InternalHigh = 0,\n                .Offset = 0,\n                .OffsetHigh = 0,\n                .hEvent = null,\n            },\n            else => {},\n        }","src":52,"more_decls":null}{"pl":"const Overlapped = @TypeOf(overlapped_init)","src":62,"more_decls":null}{"pl":"const EventFd = switch (builtin.os.tag) {\n            .macos, .freebsd, .netbsd, .dragonfly, .openbsd => KEventFd,\n            .linux => struct {\n                base: ResumeNode,\n                epoll_op: u32,\n                eventfd: i32,\n            },\n            .windows => struct {\n                base: ResumeNode,\n                completion_key: usize,\n            },\n            else => struct {},\n        }","src":70,"more_decls":null}{"pl":"const Basic = switch (builtin.os.tag) {\n            .macos, .freebsd, .netbsd, .dragonfly, .openbsd => KEventBasic,\n            .linux => struct {\n                base: ResumeNode,\n            },\n            .windows => struct {\n                base: ResumeNode,\n            },\n            else => @compileError(\"unsupported OS\"),\n        }","src":89,"more_decls":null}}{"pl":"pub const Request = struct ","src":1503,"more_decls":{"pl":"msg: Msg","src":1504,"more_decls":null}{"pl":"finish: Finish","src":1505,"more_decls":null}{"pl":"pub const Finish = union(enum) ","src":1509,"more_decls":{"pl":"TickNode: Loop.NextTickNode","src":1510,"more_decls":null}{"pl":"NoAction","src":1511,"more_decls":null}}{"pl":"pub const Msg = union(enum) ","src":1514,"more_decls":{"pl":"read: Read","src":1515,"more_decls":null}{"pl":"readv: ReadV","src":1516,"more_decls":null}{"pl":"write: Write","src":1517,"more_decls":null}{"pl":"writev: WriteV","src":1518,"more_decls":null}{"pl":"pwrite: PWrite","src":1519,"more_decls":null}{"pl":"pwritev: PWriteV","src":1520,"more_decls":null}{"pl":"pread: PRead","src":1521,"more_decls":null}{"pl":"preadv: PReadV","src":1522,"more_decls":null}{"pl":"open: Open","src":1523,"more_decls":null}{"pl":"openat: OpenAt","src":1524,"more_decls":null}{"pl":"close: Close","src":1525,"more_decls":null}{"pl":"faccessat: FAccessAt","src":1526,"more_decls":null}{"doc_comment":"special - means the fs thread should exit","pl":"end","src":1529,"more_decls":null}{"pl":"pub const Read = struct ","src":1531,"more_decls":{"pl":"fd: os.fd_t","src":1532,"more_decls":null}{"pl":"buf: []u8","src":1533,"more_decls":null}{"pl":"result: Error!usize","src":1534,"more_decls":null}{"pl":"const Error = os.ReadError","src":1536,"more_decls":null}}{"pl":"pub const ReadV = struct ","src":1539,"more_decls":{"pl":"fd: os.fd_t","src":1540,"more_decls":null}{"pl":"iov: []const os.iovec","src":1541,"more_decls":null}{"pl":"result: Error!usize","src":1542,"more_decls":null}{"pl":"const Error = os.ReadError","src":1544,"more_decls":null}}{"pl":"pub const Write = struct ","src":1547,"more_decls":{"pl":"fd: os.fd_t","src":1548,"more_decls":null}{"pl":"bytes: []const u8","src":1549,"more_decls":null}{"pl":"result: Error!usize","src":1550,"more_decls":null}{"pl":"const Error = os.WriteError","src":1552,"more_decls":null}}{"pl":"pub const WriteV = struct ","src":1555,"more_decls":{"pl":"fd: os.fd_t","src":1556,"more_decls":null}{"pl":"iov: []const os.iovec_const","src":1557,"more_decls":null}{"pl":"result: Error!usize","src":1558,"more_decls":null}{"pl":"const Error = os.WriteError","src":1560,"more_decls":null}}{"pl":"pub const PWrite = struct ","src":1563,"more_decls":{"pl":"fd: os.fd_t","src":1564,"more_decls":null}{"pl":"bytes: []const u8","src":1565,"more_decls":null}{"pl":"offset: usize","src":1566,"more_decls":null}{"pl":"result: Error!usize","src":1567,"more_decls":null}{"pl":"const Error = os.PWriteError","src":1569,"more_decls":null}}{"pl":"pub const PWriteV = struct ","src":1572,"more_decls":{"pl":"fd: os.fd_t","src":1573,"more_decls":null}{"pl":"iov: []const os.iovec_const","src":1574,"more_decls":null}{"pl":"offset: usize","src":1575,"more_decls":null}{"pl":"result: Error!usize","src":1576,"more_decls":null}{"pl":"const Error = os.PWriteError","src":1578,"more_decls":null}}{"pl":"pub const PRead = struct ","src":1581,"more_decls":{"pl":"fd: os.fd_t","src":1582,"more_decls":null}{"pl":"buf: []u8","src":1583,"more_decls":null}{"pl":"offset: usize","src":1584,"more_decls":null}{"pl":"result: Error!usize","src":1585,"more_decls":null}{"pl":"const Error = os.PReadError","src":1587,"more_decls":null}}{"pl":"pub const PReadV = struct ","src":1590,"more_decls":{"pl":"fd: os.fd_t","src":1591,"more_decls":null}{"pl":"iov: []const os.iovec","src":1592,"more_decls":null}{"pl":"offset: usize","src":1593,"more_decls":null}{"pl":"result: Error!usize","src":1594,"more_decls":null}{"pl":"const Error = os.PReadError","src":1596,"more_decls":null}}{"pl":"pub const Open = struct ","src":1599,"more_decls":{"pl":"path: [*:0]const u8","src":1600,"more_decls":null}{"pl":"flags: u32","src":1601,"more_decls":null}{"pl":"mode: os.mode_t","src":1602,"more_decls":null}{"pl":"result: Error!os.fd_t","src":1603,"more_decls":null}{"pl":"const Error = os.OpenError","src":1605,"more_decls":null}}{"pl":"pub const OpenAt = struct ","src":1608,"more_decls":{"pl":"fd: os.fd_t","src":1609,"more_decls":null}{"pl":"path: [*:0]const u8","src":1610,"more_decls":null}{"pl":"flags: u32","src":1611,"more_decls":null}{"pl":"mode: os.mode_t","src":1612,"more_decls":null}{"pl":"result: Error!os.fd_t","src":1613,"more_decls":null}{"pl":"const Error = os.OpenError","src":1615,"more_decls":null}}{"pl":"pub const Close = struct ","src":1618,"more_decls":{"pl":"fd: os.fd_t","src":1619,"more_decls":null}}{"pl":"pub const FAccessAt = struct ","src":1622,"more_decls":{"pl":"dirfd: os.fd_t","src":1623,"more_decls":null}{"pl":"path: [*:0]const u8","src":1624,"more_decls":null}{"pl":"mode: u32","src":1625,"more_decls":null}{"pl":"flags: u32","src":1626,"more_decls":null}{"pl":"result: Error!void","src":1627,"more_decls":null}{"pl":"const Error = os.AccessError","src":1629,"more_decls":null}}}{"pl":"const Node = std.atomic.Queue(Request).Node","src":1507,"more_decls":null}}{"doc_comment":"TODO copy elision / named return values so that the threads referencing *Loop\nhave the correct pointer value.\nhttps://github.com/ziglang/zig/issues/2761 and https://github.com/ziglang/zig/issues/2765","pl":"fn init(self: *Loop) !void","src":116,"more_decls":null}{"doc_comment":"After initialization, call run().\nTODO copy elision / named return values so that the threads referencing *Loop\nhave the correct pointer value.\nhttps://github.com/ziglang/zig/issues/2761 and https://github.com/ziglang/zig/issues/2765","pl":"pub fn initSingleThreaded(self: *Loop) !void {\n    return self.initThreadPool(1);\n}","src":130,"more_decls":null}{"doc_comment":"After initialization, call run().\nThis is the same as `initThreadPool` using `Thread.cpuCount` to determine the thread\npool size.\nTODO copy elision / named return values so that the threads referencing *Loop\nhave the correct pointer value.\nhttps://github.com/ziglang/zig/issues/2761 and https://github.com/ziglang/zig/issues/2765","pl":"pub fn initMultiThreaded(self: *Loop) !void {\n    if (builtin.single_threaded)\n        @compileError(\"initMultiThreaded unavailable when building in single-threaded mode\");\n    const core_count = try Thread.cpuCount();\n    return self.initThreadPool(core_count);\n}","src":140,"more_decls":null}{"doc_comment":"Thread count is the total thread count. The thread pool size will be\nmax(thread_count - 1, 0)","pl":"fn initThreadPool(self: *Loop, thread_count: usize) !void","src":149,"more_decls":null}{"pl":"pub fn deinit(self: *Loop) void {\n    self.deinitOsData();\n    self.fs_thread_wakeup.deinit();\n    self.arena.deinit();\n    self.* = undefined;\n}","src":198,"more_decls":null}{"doc_comment":"resume_node must live longer than the anyframe that it holds a reference to.\nflags must contain EPOLLET","pl":"fn linuxAddFd(self: *Loop, fd: i32, resume_node: *ResumeNode, flags: u32) !void","src":406,"more_decls":null}{"pl":"fn linuxModFd(self: *Loop, fd: i32, op: u32, flags: u32, resume_node: *ResumeNode) !void","src":418,"more_decls":null}{"pl":"pub fn linuxRemoveFd(self: *Loop, fd: i32) void {\n    os.epoll_ctl(self.os_data.epollfd, os.linux.EPOLL_CTL_DEL, fd, null) catch {};\n    self.finishOneEvent();\n}","src":427,"more_decls":null}{"pl":"fn linuxWaitFd(self: *Loop, fd: i32, flags: u32) void","src":432,"more_decls":null}{"pl":"fn waitUntilFdReadable(self: *Loop, fd: os.fd_t) void","src":484,"more_decls":null}{"pl":"fn waitUntilFdWritable(self: *Loop, fd: os.fd_t) void","src":496,"more_decls":null}{"pl":"fn waitUntilFdWritableOrReadable(self: *Loop, fd: os.fd_t) void","src":508,"more_decls":null}{"pl":"fn bsdWaitKev(self: *Loop, ident: usize, filter: i16, flags: u16) void","src":521,"more_decls":null}{"doc_comment":"resume_node must live longer than the anyframe that it holds a reference to.","pl":"fn bsdAddKev(self: *Loop, resume_node: *ResumeNode.Basic, ident: usize, filter: i16, flags: u16) !void","src":544,"more_decls":null}{"pl":"fn bsdRemoveKev(self: *Loop, ident: usize, filter: i16) void","src":559,"more_decls":null}{"doc_comment":"Bring your own linked list node. This means it can't fail.","pl":"pub fn onNextTick(self: *Loop, node: *NextTickNode) void {\n    self.beginOneEvent(); // finished in dispatch()\n    self.next_tick_queue.put(node);\n    self.dispatch();\n}","src":624,"more_decls":null}{"pl":"pub fn cancelOnNextTick(self: *Loop, node: *NextTickNode) void {\n    if (self.next_tick_queue.remove(node)) {\n        self.finishOneEvent();\n    }\n}","src":630,"more_decls":null}{"pl":"fn run(self: *Loop) void","src":636,"more_decls":null}{"doc_comment":"Runs the provided function asynchronously. The function's frame is allocated\nwith `allocator` and freed when the function returns.\n`func` must return void and it can be an async function.\nYields to the event loop, running the function on the next tick.","pl":"fn runDetached(self: *Loop, alloc: *mem.Allocator, comptime func: anytype, args: anytype) error{OutOfMemory}!void","src":667,"more_decls":null}{"doc_comment":"Yielding lets the event loop run, starting any unstarted async operations.\nNote that async operations automatically start when a function yields for any other reason,\nfor example, when async I/O is performed. This function is intended to be used only when\nCPU bound tasks would be waiting in the event loop but never get started because no async I/O\nis performed.","pl":"fn yield(self: *Loop) void","src":695,"more_decls":null}{"doc_comment":"If the build is multi-threaded and there is an event loop, then it calls `yield`. Otherwise,\ndoes nothing.","pl":"fn startCpuBoundOperation() void","src":708,"more_decls":null}{"doc_comment":"call finishOneEvent when done","pl":"pub fn beginOneEvent(self: *Loop) void {\n    _ = @atomicRmw(usize, &self.pending_event_count, .Add, 1, .SeqCst);\n}","src":717,"more_decls":null}{"pl":"fn finishOneEvent(self: *Loop) void","src":721,"more_decls":null}{"pl":"fn sleep(self: *Loop, nanoseconds: u64) void","src":764,"more_decls":null}{"doc_comment":"------- I/0 APIs -------","pl":"fn accept(\n    self: *Loop,\n    /// This argument is a socket that has been created with `socket`, bound to a local address\n    /// with `bind`, and is listening for connections after a `listen`.\n    sockfd: os.fd_t,\n    /// This argument is a pointer to a sockaddr structure.  This structure is filled in with  the\n    /// address  of  the  peer  socket, as known to the communications layer.  The exact format of the\n    /// address returned addr is determined by the socket's address  family  (see  `socket`  and  the\n    /// respective  protocol  man  pages).\n    addr: *os.sockaddr,\n    /// This argument is a value-result argument: the caller must initialize it to contain  the\n    /// size (in bytes) of the structure pointed to by addr; on return it will contain the actual size\n    /// of the peer address.\n    ///\n    /// The returned address is truncated if the buffer provided is too small; in this  case,  `addr_size`\n    /// will return a value greater than was supplied to the call.\n    addr_size: *os.socklen_t,\n    /// The following values can be bitwise ORed in flags to obtain different behavior:\n    /// * `SOCK_CLOEXEC`  - Set the close-on-exec (`FD_CLOEXEC`) flag on the new file descriptor.   See  the\n    ///   description  of the `O_CLOEXEC` flag in `open` for reasons why this may be useful.\n    flags: u32,\n) os.AcceptError!os.fd_t","src":888,"more_decls":null}{"pl":"fn connect(self: *Loop, sockfd: os.socket_t, sock_addr: *const os.sockaddr, len: os.socklen_t) os.ConnectError!void","src":921,"more_decls":null}{"doc_comment":"Performs an async `os.open` using a separate thread.","pl":"fn openZ(self: *Loop, file_path: [*:0]const u8, flags: u32, mode: os.mode_t) os.OpenError!os.fd_t","src":932,"more_decls":null}{"doc_comment":"Performs an async `os.opent` using a separate thread.","pl":"fn openatZ(self: *Loop, fd: os.fd_t, file_path: [*:0]const u8, flags: u32, mode: os.mode_t) os.OpenError!os.fd_t","src":953,"more_decls":null}{"doc_comment":"Performs an async `os.close` using a separate thread.","pl":"fn close(self: *Loop, fd: os.fd_t) void","src":975,"more_decls":null}{"doc_comment":"Performs an async `os.read` using a separate thread.\n`fd` must block and not return EAGAIN.","pl":"fn read(self: *Loop, fd: os.fd_t, buf: []u8, simulate_evented: bool) os.ReadError!usize","src":989,"more_decls":null}{"doc_comment":"Performs an async `os.readv` using a separate thread.\n`fd` must block and not return EAGAIN.","pl":"fn readv(self: *Loop, fd: os.fd_t, iov: []const os.iovec, simulate_evented: bool) os.ReadError!usize","src":1022,"more_decls":null}{"doc_comment":"Performs an async `os.pread` using a separate thread.\n`fd` must block and not return EAGAIN.","pl":"fn pread(self: *Loop, fd: os.fd_t, buf: []u8, offset: u64, simulate_evented: bool) os.PReadError!usize","src":1055,"more_decls":null}{"doc_comment":"Performs an async `os.preadv` using a separate thread.\n`fd` must block and not return EAGAIN.","pl":"fn preadv(self: *Loop, fd: os.fd_t, iov: []const os.iovec, offset: u64, simulate_evented: bool) os.ReadError!usize","src":1089,"more_decls":null}{"doc_comment":"Performs an async `os.write` using a separate thread.\n`fd` must block and not return EAGAIN.","pl":"fn write(self: *Loop, fd: os.fd_t, bytes: []const u8, simulate_evented: bool) os.WriteError!usize","src":1123,"more_decls":null}{"doc_comment":"Performs an async `os.writev` using a separate thread.\n`fd` must block and not return EAGAIN.","pl":"fn writev(self: *Loop, fd: os.fd_t, iov: []const os.iovec_const, simulate_evented: bool) os.WriteError!usize","src":1156,"more_decls":null}{"doc_comment":"Performs an async `os.pwrite` using a separate thread.\n`fd` must block and not return EAGAIN.","pl":"fn pwrite(self: *Loop, fd: os.fd_t, bytes: []const u8, offset: u64, simulate_evented: bool) os.PerformsWriteError!usize","src":1189,"more_decls":null}{"doc_comment":"Performs an async `os.pwritev` using a separate thread.\n`fd` must block and not return EAGAIN.","pl":"fn pwritev(self: *Loop, fd: os.fd_t, iov: []const os.iovec_const, offset: u64, simulate_evented: bool) os.PWriteError!usize","src":1223,"more_decls":null}{"pl":"fn sendto(\n    self: *Loop,\n    /// The file descriptor of the sending socket.\n    sockfd: os.fd_t,\n    /// Message to send.\n    buf: []const u8,\n    flags: u32,\n    dest_addr: ?*const os.sockaddr,\n    addrlen: os.socklen_t,\n) os.SendToError!usize","src":1255,"more_decls":null}{"pl":"fn recvfrom(\n    self: *Loop,\n    sockfd: os.fd_t,\n    buf: []u8,\n    flags: u32,\n    src_addr: ?*os.sockaddr,\n    addrlen: ?*os.socklen_t,\n) os.RecvFromError!usize","src":1276,"more_decls":null}{"doc_comment":"Performs an async `os.faccessatZ` using a separate thread.\n`fd` must block and not return EAGAIN.","pl":"fn faccessatZ(\n    self: *Loop,\n    dirfd: os.fd_t,\n    path_z: [*:0]const u8,\n    mode: u32,\n    flags: u32,\n) os.AccessError!void","src":1297,"more_decls":null}{"pl":"const NextTickNode = std.atomic.Queue(anyframe).Node","src":45,"more_decls":null}{"pl":"const instance: ?*Loop = if (@hasDecl(root, \"event_loop\")) root.event_loop else default_instance","src":111,"more_decls":null}}]