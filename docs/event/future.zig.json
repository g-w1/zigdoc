[{"doc_comment":"This is a value that starts out unavailable, until resolve() is called\nWhile it is unavailable, functions suspend when they try to get() it,\nand then are resumed when resolve() is called.\nAt this point the value remains forever available, and another resolve() is not allowed.","pl":"fn Future(comptime T: type) type","sub_container_type":"struct ","src":15,"more_decls":{"pl":"lock: Lock","src":17,"more_decls":null}{"pl":"data: T","src":18,"more_decls":null}{"pl":"available: Available","src":19,"more_decls":null}{"pl":"fn init() Self","src":30,"more_decls":null}{"doc_comment":"Obtain the value. If it's not available, wait until it becomes\navailable.\nThread-safe.","pl":"fn get(self: *Self) callconv(.Async) *T","src":41,"more_decls":null}{"doc_comment":"Gets the data without waiting for it. If it's available, a pointer is\nreturned. Otherwise, null is returned.","pl":"fn getOrNull(self: *Self) ?*T","src":53,"more_decls":null}{"doc_comment":"If someone else has started working on the data, wait for them to complete\nand return a pointer to the data. Otherwise, return null, and the caller\nshould start working on the data.\nIt's not required to call start() before resolve() but it can be useful since\nthis method is thread-safe.","pl":"fn start(self: *Self) callconv(.Async) ?*T","src":66,"more_decls":null}{"doc_comment":"Make the data become available. May be called only once.\nBefore calling this, modify the `data` property.","pl":"pub fn resolve(self: *Self) void {\n    const prev = @atomicRmw(Available, &self.available, .Xchg, .Finished, .SeqCst);\n    assert(prev != .Finished); // resolve() called twice\n    Lock.Held.release(Lock.Held{ .lock = &self.lock });\n}","src":81,"more_decls":null}}]