[{"doc_comment":"Thread-safe async/await lock.\nFunctions which are waiting for the lock are suspended, and\nare resumed when the lock is released, in order.\nMany readers can hold the lock at the same time; however locking for writing is exclusive.\nWhen a read lock is held, it will not be released until the reader queue is empty.\nWhen a write lock is held, it will not be released until the writer queue is empty.\nTODO: make this API also work in blocking I/O mode","pl":"pub const RwLock = struct ","src":19,"more_decls":{"pl":"shared_state: State","src":20,"more_decls":null}{"pl":"writer_queue: Queue","src":21,"more_decls":null}{"pl":"reader_queue: Queue","src":22,"more_decls":null}{"pl":"writer_queue_empty: bool","src":23,"more_decls":null}{"pl":"reader_queue_empty: bool","src":24,"more_decls":null}{"pl":"reader_lock_count: usize","src":25,"more_decls":null}{"pl":"pub const HeldRead = struct ","src":38,"more_decls":{"pl":"lock: *RwLock","src":39,"more_decls":null}{"pl":"fn release(self: HeldRead) void","src":41,"more_decls":null}}{"pl":"pub const HeldWrite = struct ","src":57,"more_decls":{"pl":"lock: *RwLock","src":58,"more_decls":null}{"pl":"fn release(self: HeldWrite) void","src":60,"more_decls":null}}{"pl":"fn init() RwLock","src":85,"more_decls":null}{"doc_comment":"Must be called when not locked. Not thread safe.\nAll calls to acquire() and release() must complete before calling deinit().","pl":"pub fn deinit(self: *RwLock) void {\n    assert(self.shared_state == .Unlocked);\n    while (self.writer_queue.get()) |node| resume node.data;\n    while (self.reader_queue.get()) |node| resume node.data;\n}","src":98,"more_decls":null}{"pl":"fn acquireRead(self: *RwLock) callconv(.Async) HeldRead","src":104,"more_decls":null}{"pl":"fn acquireWrite(self: *RwLock) callconv(.Async) HeldWrite","src":137,"more_decls":null}}]