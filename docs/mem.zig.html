<style type="text/css" >
.more-decls {
    padding-left: 50px;
}
.anal-decl {
 background-color: #F7A41D77;
}
code {
 background-color: #F7A41D77;
}
</style><style type="text/css" >
pre > code {
  display: block;
  overflow: auto;
  padding: 0.5em;
  color: black;
}

details {
  margin-bottom: 0.5em;
  -webkit-touch-callout: none; /* iOS Safari */
    -webkit-user-select: none; /* Safari */
     -khtml-user-select: none; /* Konqueror HTML */
       -moz-user-select: none; /* Old versions of Firefox */
        -ms-user-select: none; /* Internet Explorer/Edge */
            user-select: none; /* Non-prefixed version, currently
                                  supported by Chrome, Edge, Opera and Firefox */
}

.tok {
  color: #333;
  font-style: normal;
}

.code {
  font-family: monospace;
  font-size: 0.8em;
}

.tok-kw {
  color: #333;
  font-weight: bold;
}

.tok-str {
  color: #d14;
}

.tok-builtin {
  color: #0086b3;
}

code.zig {
  color: #777;
  font-style: italic;
}

.tok-fn {
  color: #900;
  font-weight: bold;
}

.tok-null {
  color: #008080;
}

.tok-number {
  color: #008080;
}

.tok-type {
  color: #458;
  font-weight: bold;
}
</style><html><a href="https://github.com/ziglang/zig/blob/master/lib/std//mem.zig"><h1>/mem.zig</h1></a><div class="more-decls"></div><h2 style="color: orange;">types:</h2><div class="more-decls"><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1459">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">const</span> <span class="tok">TokenIterator</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">struct</span></code></pre><details><summary>fields:</summary><div class="md-fields more-decls"><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1460">src</a><pre><code class="zig"><span class="tok">buffer</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1461">src</a><pre><code class="zig"><span class="tok">delimiter_bytes</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1462">src</a><pre><code class="zig"><span class="tok">index</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span></code></pre></div></div></details><details><summary>funcs</summary><div class="md-funcs more-decls"><div class="anal-decl"><b>Returns a slice of the next token, or null if tokenization is complete.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1465">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">next</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">TokenIterator</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span></code></pre></div><div class="anal-decl"><b>Returns a slice of the remaining bytes. Does not affect iterator state.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1481">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">rest</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">TokenIterator</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span> <span class="tok tok-symbol">{</span>
    // move to beginning of token
    <span class="tok tok-kw">var</span> <span class="tok">index</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">index</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">while</span> <span class="tok tok-symbol">(</span><span class="tok">index</span> <span class="tok tok-symbol">&lt;</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">buffer</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-kw">and</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">isSplitByte</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">buffer</span><span class="tok tok-symbol">[</span><span class="tok">index</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">:</span> <span class="tok tok-symbol">(</span><span class="tok">index</span> <span class="tok tok-symbol">+=</span> <span class="tok tok-number">1</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span><span class="tok tok-symbol">}</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">buffer</span><span class="tok tok-symbol">[</span><span class="tok">index</span><span class="tok tok-symbol">..</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Resets the iterator to the initial token.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1489">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">reset</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">TokenIterator</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">index</span> <span class="tok tok-symbol">=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div></div></details></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1503">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">const</span> <span class="tok">SplitIterator</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">struct</span></code></pre><details><summary>fields:</summary><div class="md-fields more-decls"><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1504">src</a><pre><code class="zig"><span class="tok">buffer</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1505">src</a><pre><code class="zig"><span class="tok">index</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">?</span><span class="tok tok-type">usize</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1506">src</a><pre><code class="zig"><span class="tok">delimiter</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span></code></pre></div></div></details><details><summary>funcs</summary><div class="md-funcs more-decls"><div class="anal-decl"><b>Returns a slice of the next field, or null if splitting is complete.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1509">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">next</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">SplitIterator</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span></code></pre></div><div class="anal-decl"><b>Returns a slice of the remaining bytes. Does not affect iterator state.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1522">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">rest</span><span class="tok tok-symbol">(</span><span class="tok">self</span><span class="tok tok-symbol">:</span> <span class="tok">SplitIterator</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">end</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">buffer</span><span class="tok tok-symbol">.</span><span class="tok">len</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">const</span> <span class="tok">start</span> <span class="tok tok-symbol">=</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">index</span> <span class="tok tok-kw">orelse</span> <span class="tok">end</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">self</span><span class="tok tok-symbol">.</span><span class="tok">buffer</span><span class="tok tok-symbol">[</span><span class="tok">start</span><span class="tok tok-symbol">..</span><span class="tok">end</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div></div></details></div></div><h2 style="color: orange;">funcs:</h2><div class="more-decls"><div class="anal-decl"><b>Detects and asserts if the std.mem.Allocator interface is violated by the caller
or the allocator.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L40">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">ValidationAllocator</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">type</span></code></pre><details><summary>fields:</summary><div class="md-fields more-decls"><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L43">src</a><pre><code class="zig"><span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok">Allocator</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L44">src</a><pre><code class="zig"><span class="tok">underlying_allocator</span><span class="tok tok-symbol">:</span> <span class="tok">T</span></code></pre></div></div></details><details><summary>funcs</summary><div class="md-funcs more-decls"><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L45">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">init</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-builtin">@This</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">)</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L59">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">alloc</span><span class="tok tok-symbol">(</span>
    <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span>
    <span class="tok">n</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span>
    <span class="tok">ptr_align</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">u29</span><span class="tok tok-symbol">,</span>
    <span class="tok">len_align</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">u29</span><span class="tok tok-symbol">,</span>
    <span class="tok">ret_addr</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span>
<span class="tok tok-symbol">)</span> <span class="tok">Allocator</span><span class="tok tok-symbol">.</span><span class="tok">Error</span><span class="tok tok-symbol">!</span><span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-type">u8</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L85">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">resize</span><span class="tok tok-symbol">(</span>
    <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span>
    <span class="tok">buf</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-type">u8</span><span class="tok tok-symbol">,</span>
    <span class="tok">buf_align</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">u29</span><span class="tok tok-symbol">,</span>
    <span class="tok">new_len</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span>
    <span class="tok">len_align</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">u29</span><span class="tok tok-symbol">,</span>
    <span class="tok">ret_addr</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span>
<span class="tok tok-symbol">)</span> <span class="tok">Allocator</span><span class="tok tok-symbol">.</span><span class="tok">Error</span><span class="tok tok-symbol">!</span><span class="tok tok-type">usize</span></code></pre></div></div></details></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L117">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">validationWrap</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok">ValidationAllocator</span><span class="tok tok-symbol">(</span><span class="tok tok-builtin">@TypeOf</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">ValidationAllocator</span><span class="tok tok-symbol">(</span><span class="tok tok-builtin">@TypeOf</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">.</span><span class="tok">init</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>An allocator helper function.  Adjusts an allocation length satisfy `len_align`.
`full_len` should be the full capacity of the allocation which may be greater
than the `len` that was requsted.  This function should only be used by allocators
that are unaffected by `len_align`.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L125">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">alignAllocLen</span><span class="tok tok-symbol">(</span><span class="tok">full_len</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span> <span class="tok">alloc_len</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span> <span class="tok">len_align</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">u29</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">usize</span></code></pre></div><div class="anal-decl"><b>Copy all of source into dest at position 0.
dest.len must be &gt;= source.len.
If the slices overlap, dest.ptr must be &lt;= src.ptr.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L152">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">copy</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">dest</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">source</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>Copy all of source into dest at position 0.
dest.len must be &gt;= source.len.
If the slices overlap, dest.ptr must be &gt;= src.ptr.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L165">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">copyBackwards</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">dest</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">source</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>Sets all elements of `dest` to `value`.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L179">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">set</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">dest</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">for</span> <span class="tok tok-symbol">(</span><span class="tok">dest</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">|</span><span class="tok tok-symbol">*</span><span class="tok">d</span><span class="tok tok-symbol">|</span>
        <span class="tok">d</span><span class="tok tok-symbol">.*</span> <span class="tok tok-symbol">=</span> <span class="tok">value</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Generally, Zig users are encouraged to explicitly initialize all fields of a struct explicitly rather than using this function.
However, it is recognized that there are sometimes use cases for initializing all fields to a &quot;zero&quot; value. For example, when
interfacing with a C API where this practice is more common and relied upon. If you are performing code review and see this
function used, examine closely - it may be a code smell.
Zero initializes the type.
This can be used to zero initialize a any type for which it makes sense. Structs will be initialized recursively.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L190">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">zeroes</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">)</span> <span class="tok">T</span></code></pre></div><div class="anal-decl"><b>Initializes all fields of the struct with their default value, or zero values if no default value is present.
If the field is present in the provided initial values, it will have that value instead.
Structs are initialized recursively.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L357">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">zeroInit</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">init</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok">T</span></code></pre></div><div class="anal-decl"><b>Compares two slices of numbers lexicographically. O(n).
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L451">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">order</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">lhs</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">rhs</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok">math</span><span class="tok tok-symbol">.</span><span class="tok">Order</span></code></pre></div><div class="anal-decl"><b>Returns true if lhs &lt; rhs, false otherwise
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L473">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">lessThan</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">lhs</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">rhs</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">order</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">lhs</span><span class="tok tok-symbol">,</span> <span class="tok">rhs</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">==</span> <span class="tok tok-symbol">.</span><span class="tok">lt</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Compares two slices and returns whether they are equal.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L486">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">eql</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">a</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">b</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span></code></pre></div><div class="anal-decl"><b>Compares two slices and returns the index of the first inequality.
Returns null if the slices are equal.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L497">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">indexOfDiff</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">a</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">b</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok tok-type">usize</span></code></pre></div><div class="anal-decl"><b>Takes a pointer to an array, a sentinel-terminated pointer, or a slice, and
returns a slice. If there is a sentinel on the input type, there will be a
sentinel on the output type. The constness of the output type matches
the constness of the input type. `[*c]` pointers are assumed to be 0-terminated,
and assumed to not allow null.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L522">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">Span</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">type</span></code></pre></div><div class="anal-decl"><b>Takes a pointer to an array, a sentinel-terminated pointer, or a slice, and
returns a slice. If there is a sentinel on the input type, there will be a
sentinel on the output type. The constness of the output type matches
the constness of the input type.

When there is both a sentinel and an array length or slice length, the
length value is used instead of the sentinel.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L580">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">span</span><span class="tok tok-symbol">(</span><span class="tok">ptr</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok">Span</span><span class="tok tok-symbol">(</span><span class="tok tok-builtin">@TypeOf</span><span class="tok tok-symbol">(</span><span class="tok">ptr</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">)</span></code></pre></div><div class="anal-decl"><b>Same as `span`, except when there is both a sentinel and an array
length or slice length, scans the memory for the sentinel value
rather than using the length.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L608">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">spanZ</span><span class="tok tok-symbol">(</span><span class="tok">ptr</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok">Span</span><span class="tok tok-symbol">(</span><span class="tok tok-builtin">@TypeOf</span><span class="tok tok-symbol">(</span><span class="tok">ptr</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">)</span></code></pre></div><div class="anal-decl"><b>Takes a pointer to an array, an array, a vector, a sentinel-terminated pointer,
a slice or a tuple, and returns the length.
In the case of a sentinel-terminated array, it uses the array length.
For C pointers it assumes it is a pointer-to-many with a 0 sentinel.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L637">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">len</span><span class="tok tok-symbol">(</span><span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">usize</span></code></pre></div><div class="anal-decl"><b>Takes a pointer to an array, an array, a sentinel-terminated pointer,
or a slice, and returns the length.
In the case of a sentinel-terminated array, it scans the array
for a sentinel and uses that for the length, rather than using the array length.
For C pointers it assumes it is a pointer-to-many with a 0 sentinel.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L696">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">lenZ</span><span class="tok tok-symbol">(</span><span class="tok">ptr</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">usize</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L746">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">indexOfSentinel</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">Elem</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok tok-kw">comptime</span> <span class="tok">sentinel</span><span class="tok tok-symbol">:</span> <span class="tok">Elem</span><span class="tok tok-symbol">,</span> <span class="tok">ptr</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">*</span><span class="tok tok-symbol">:</span><span class="tok">sentinel</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">Elem</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">usize</span></code></pre></div><div class="anal-decl"><b>Returns true if all elements in a slice are equal to the scalar value provided
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L755">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">allEqual</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">slice</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">scalar</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">for</span> <span class="tok tok-symbol">(</span><span class="tok">slice</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">|</span><span class="tok">item</span><span class="tok tok-symbol">|</span> <span class="tok tok-symbol">{</span>
        <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok">item</span> <span class="tok tok-symbol">!=</span> <span class="tok">scalar</span><span class="tok tok-symbol">)</span> <span class="tok tok-kw">return</span> <span class="tok tok-null">false</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-symbol">}</span>
    <span class="tok tok-kw">return</span> <span class="tok tok-null">true</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Deprecated, use `Allocator.dupe`.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L763">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">dupe</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">m</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">allocator</span><span class="tok tok-symbol">.</span><span class="tok">dupe</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">m</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Deprecated, use `Allocator.dupeZ`.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L768">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">dupeZ</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">m</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-symbol">[</span><span class="tok tok-symbol">:</span><span class="tok tok-number">0</span><span class="tok tok-symbol">]</span><span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">allocator</span><span class="tok tok-symbol">.</span><span class="tok">dupeZ</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">m</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Remove values from the beginning of a slice.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L773">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">trimLeft</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">slice</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">values_to_strip</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">var</span> <span class="tok">begin</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span> <span class="tok tok-symbol">=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">while</span> <span class="tok tok-symbol">(</span><span class="tok">begin</span> <span class="tok tok-symbol">&lt;</span> <span class="tok">slice</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-kw">and</span> <span class="tok">indexOfScalar</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">values_to_strip</span><span class="tok tok-symbol">,</span> <span class="tok">slice</span><span class="tok tok-symbol">[</span><span class="tok">begin</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-null">null</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">:</span> <span class="tok tok-symbol">(</span><span class="tok">begin</span> <span class="tok tok-symbol">+=</span> <span class="tok tok-number">1</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span><span class="tok tok-symbol">}</span>
    <span class="tok tok-kw">return</span> <span class="tok">slice</span><span class="tok tok-symbol">[</span><span class="tok">begin</span><span class="tok tok-symbol">..</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Remove values from the end of a slice.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L780">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">trimRight</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">slice</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">values_to_strip</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">var</span> <span class="tok">end</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span> <span class="tok tok-symbol">=</span> <span class="tok">slice</span><span class="tok tok-symbol">.</span><span class="tok">len</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">while</span> <span class="tok tok-symbol">(</span><span class="tok">end</span> <span class="tok tok-symbol">&gt;</span> <span class="tok tok-number">0</span> <span class="tok tok-kw">and</span> <span class="tok">indexOfScalar</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">values_to_strip</span><span class="tok tok-symbol">,</span> <span class="tok">slice</span><span class="tok tok-symbol">[</span><span class="tok">end</span> <span class="tok tok-symbol">-</span> <span class="tok tok-number">1</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-null">null</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">:</span> <span class="tok tok-symbol">(</span><span class="tok">end</span> <span class="tok tok-symbol">-=</span> <span class="tok tok-number">1</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span><span class="tok tok-symbol">}</span>
    <span class="tok tok-kw">return</span> <span class="tok">slice</span><span class="tok tok-symbol">[</span><span class="tok tok-number">0</span><span class="tok tok-symbol">..</span><span class="tok">end</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Remove values from the beginning and end of a slice.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L787">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">trim</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">slice</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">values_to_strip</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span></code></pre></div><div class="anal-decl"><b>Linear search for the index of a scalar value inside a slice.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L803">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">indexOfScalar</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">slice</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok tok-type">usize</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">indexOfScalarPos</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">slice</span><span class="tok tok-symbol">,</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Linear search for the last index of a scalar value inside a slice.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L808">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">lastIndexOfScalar</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">slice</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok tok-type">usize</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L817">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">indexOfScalarPos</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">slice</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">start_index</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok tok-type">usize</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L825">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">indexOfAny</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">slice</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">values</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok tok-type">usize</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">indexOfAnyPos</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">slice</span><span class="tok tok-symbol">,</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">,</span> <span class="tok">values</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L829">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">lastIndexOfAny</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">slice</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">values</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok tok-type">usize</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L840">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">indexOfAnyPos</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">slice</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">start_index</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span> <span class="tok">values</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok tok-type">usize</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L850">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">indexOf</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">haystack</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">needle</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok tok-type">usize</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">indexOfPos</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">haystack</span><span class="tok tok-symbol">,</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">,</span> <span class="tok">needle</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Find the index in a slice of a sub-slice, searching from the end backwards.
To start looking at a different index, slice the haystack first.
Consider using `lastIndexOf` instead of this, which will automatically use a
more sophisticated algorithm on larger inputs.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L858">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">lastIndexOfLinear</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">haystack</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">needle</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok tok-type">usize</span></code></pre></div><div class="anal-decl"><b>Consider using `indexOfPos` instead of this, which will automatically use a
more sophisticated algorithm on larger inputs.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L868">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">indexOfPosLinear</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">haystack</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">start_index</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span> <span class="tok">needle</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok tok-type">usize</span></code></pre></div><div class="anal-decl"><b>Find the index in a slice of a sub-slice, searching from the end backwards.
To start looking at a different index, slice the haystack first.
Uses the Reverse boyer-moore-horspool algorithm on large inputs;
`lastIndexOfLinear` on small inputs.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L906">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">lastIndexOf</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">haystack</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">needle</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok tok-type">usize</span></code></pre></div><div class="anal-decl"><b>Uses Boyer-moore-horspool algorithm on large inputs; `indexOfPosLinear` on small inputs.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L931">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">indexOfPos</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">haystack</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">start_index</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span> <span class="tok">needle</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok tok-type">usize</span></code></pre></div><div class="anal-decl"><b>Returns the number of needles inside the haystack
needle.len must be &gt; 0
does not count overlapping needles
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L981">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">count</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">haystack</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">needle</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">usize</span></code></pre></div><div class="anal-decl"><b>Returns true if the haystack contains expected_count or more needles
needle.len must be &gt; 0
does not count overlapping needles
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1011">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">containsAtLeast</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">haystack</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">expected_count</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span> <span class="tok">needle</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span></code></pre></div><div class="anal-decl"><b>Reads an integer from memory with size equal to bytes.len.
T specifies the return type, which must be large enough to store
the result.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1045">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">readVarInt</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">ReturnType</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">bytes</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span><span class="tok tok-symbol">,</span> <span class="tok">endian</span><span class="tok tok-symbol">:</span> <span class="tok">builtin</span><span class="tok tok-symbol">.</span><span class="tok">Endian</span><span class="tok tok-symbol">)</span> <span class="tok">ReturnType</span></code></pre></div><div class="anal-decl"><b>Reads an integer from memory with bit count specified by T.
The bit count of T must be evenly divisible by 8.
This function cannot fail and cannot cause undefined behavior.
Assumes the endianness of memory is native. This means the function can
simply pointer cast memory.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1068">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">readIntNative</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">bytes</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok tok-kw">const</span> <span class="tok tok-symbol">[</span><span class="tok tok-builtin">@divExact</span><span class="tok tok-symbol">(</span><span class="tok tok-builtin">@typeInfo</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">.</span><span class="tok">Int</span><span class="tok tok-symbol">.</span><span class="tok">bits</span><span class="tok tok-symbol">,</span> <span class="tok tok-number">8</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">]</span><span class="tok tok-type">u8</span><span class="tok tok-symbol">)</span> <span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok tok-builtin">@ptrCast</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">*</span><span class="tok tok-kw">align</span><span class="tok tok-symbol">(</span><span class="tok tok-number">1</span><span class="tok tok-symbol">)</span> <span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">bytes</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">.*</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Reads an integer from memory with bit count specified by T.
The bit count of T must be evenly divisible by 8.
This function cannot fail and cannot cause undefined behavior.
Assumes the endianness of memory is foreign, so it must byte-swap.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1076">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">readIntForeign</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">bytes</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok tok-kw">const</span> <span class="tok tok-symbol">[</span><span class="tok tok-builtin">@divExact</span><span class="tok tok-symbol">(</span><span class="tok tok-builtin">@typeInfo</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">.</span><span class="tok">Int</span><span class="tok tok-symbol">.</span><span class="tok">bits</span><span class="tok tok-symbol">,</span> <span class="tok tok-number">8</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">]</span><span class="tok tok-type">u8</span><span class="tok tok-symbol">)</span> <span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok tok-builtin">@byteSwap</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">readIntNative</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">bytes</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Asserts that bytes.len &gt;= @typeInfo(T).Int.bits / 8. Reads the integer starting from index 0
and ignores extra bytes.
The bit count of T must be evenly divisible by 8.
Assumes the endianness of memory is native. This means the function can
simply pointer cast memory.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1095">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">readIntSliceNative</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">bytes</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span><span class="tok tok-symbol">)</span> <span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">n</span> <span class="tok tok-symbol">=</span> <span class="tok tok-builtin">@divExact</span><span class="tok tok-symbol">(</span><span class="tok tok-builtin">@typeInfo</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">.</span><span class="tok">Int</span><span class="tok tok-symbol">.</span><span class="tok">bits</span><span class="tok tok-symbol">,</span> <span class="tok tok-number">8</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">assert</span><span class="tok tok-symbol">(</span><span class="tok">bytes</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">&gt;=</span> <span class="tok">n</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">readIntNative</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">bytes</span><span class="tok tok-symbol">[</span><span class="tok tok-number">0</span><span class="tok tok-symbol">..</span><span class="tok">n</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Asserts that bytes.len &gt;= @typeInfo(T).Int.bits / 8. Reads the integer starting from index 0
and ignores extra bytes.
The bit count of T must be evenly divisible by 8.
Assumes the endianness of memory is foreign, so it must byte-swap.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1105">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">readIntSliceForeign</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">bytes</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span><span class="tok tok-symbol">)</span> <span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok tok-builtin">@byteSwap</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">readIntSliceNative</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">bytes</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Reads an integer from memory with bit count specified by T.
The bit count of T must be evenly divisible by 8.
This function cannot fail and cannot cause undefined behavior.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1122">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">readInt</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">bytes</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok tok-kw">const</span> <span class="tok tok-symbol">[</span><span class="tok tok-builtin">@divExact</span><span class="tok tok-symbol">(</span><span class="tok tok-builtin">@typeInfo</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">.</span><span class="tok">Int</span><span class="tok tok-symbol">.</span><span class="tok">bits</span><span class="tok tok-symbol">,</span> <span class="tok tok-number">8</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">]</span><span class="tok tok-type">u8</span><span class="tok tok-symbol">,</span> <span class="tok">endian</span><span class="tok tok-symbol">:</span> <span class="tok">builtin</span><span class="tok tok-symbol">.</span><span class="tok">Endian</span><span class="tok tok-symbol">)</span> <span class="tok">T</span></code></pre></div><div class="anal-decl"><b>Asserts that bytes.len &gt;= @typeInfo(T).Int.bits / 8. Reads the integer starting from index 0
and ignores extra bytes.
The bit count of T must be evenly divisible by 8.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1133">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">readIntSlice</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">bytes</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span><span class="tok tok-symbol">,</span> <span class="tok">endian</span><span class="tok tok-symbol">:</span> <span class="tok">builtin</span><span class="tok tok-symbol">.</span><span class="tok">Endian</span><span class="tok tok-symbol">)</span> <span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">n</span> <span class="tok tok-symbol">=</span> <span class="tok tok-builtin">@divExact</span><span class="tok tok-symbol">(</span><span class="tok tok-builtin">@typeInfo</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">.</span><span class="tok">Int</span><span class="tok tok-symbol">.</span><span class="tok">bits</span><span class="tok tok-symbol">,</span> <span class="tok tok-number">8</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">assert</span><span class="tok tok-symbol">(</span><span class="tok">bytes</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">&gt;=</span> <span class="tok">n</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">readInt</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">bytes</span><span class="tok tok-symbol">[</span><span class="tok tok-number">0</span><span class="tok tok-symbol">..</span><span class="tok">n</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">,</span> <span class="tok">endian</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Writes an integer to memory, storing it in twos-complement.
This function always succeeds, has defined behavior for all inputs, and
accepts any integer bit width.
This function stores in native endian, which means it is implemented as a simple
memory store.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1179">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">writeIntNative</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">buf</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok tok-symbol">[</span><span class="tok tok-symbol">(</span><span class="tok tok-builtin">@typeInfo</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">.</span><span class="tok">Int</span><span class="tok tok-symbol">.</span><span class="tok">bits</span> <span class="tok tok-symbol">+</span> <span class="tok tok-number">7</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">/</span> <span class="tok tok-number">8</span><span class="tok tok-symbol">]</span><span class="tok tok-type">u8</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-builtin">@ptrCast</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">*</span><span class="tok tok-kw">align</span><span class="tok tok-symbol">(</span><span class="tok tok-number">1</span><span class="tok tok-symbol">)</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">buf</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">.*</span> <span class="tok tok-symbol">=</span> <span class="tok">value</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Writes an integer to memory, storing it in twos-complement.
This function always succeeds, has defined behavior for all inputs, but
the integer bit width must be divisible by 8.
This function stores in foreign endian, which means it does a @byteSwap first.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1187">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">writeIntForeign</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">buf</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok tok-symbol">[</span><span class="tok tok-builtin">@divExact</span><span class="tok tok-symbol">(</span><span class="tok tok-builtin">@typeInfo</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">.</span><span class="tok">Int</span><span class="tok tok-symbol">.</span><span class="tok">bits</span><span class="tok tok-symbol">,</span> <span class="tok tok-number">8</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">]</span><span class="tok tok-type">u8</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok">writeIntNative</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">buf</span><span class="tok tok-symbol">,</span> <span class="tok tok-builtin">@byteSwap</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Writes an integer to memory, storing it in twos-complement.
This function always succeeds, has defined behavior for all inputs, but
the integer bit width must be divisible by 8.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1204">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">writeInt</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">buffer</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok tok-symbol">[</span><span class="tok tok-builtin">@divExact</span><span class="tok tok-symbol">(</span><span class="tok tok-builtin">@typeInfo</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">.</span><span class="tok">Int</span><span class="tok tok-symbol">.</span><span class="tok">bits</span><span class="tok tok-symbol">,</span> <span class="tok tok-number">8</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">]</span><span class="tok tok-type">u8</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">endian</span><span class="tok tok-symbol">:</span> <span class="tok">builtin</span><span class="tok tok-symbol">.</span><span class="tok">Endian</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>Writes a twos-complement little-endian integer to memory.
Asserts that buf.len &gt;= @typeInfo(T).Int.bits / 8.
The bit count of T must be divisible by 8.
Any extra bytes in buffer after writing the integer are set to zero. To
avoid the branch to check for extra buffer bytes, use writeIntLittle
instead.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1218">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">writeIntSliceLittle</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">buffer</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-type">u8</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>Writes a twos-complement big-endian integer to memory.
Asserts that buffer.len &gt;= @typeInfo(T).Int.bits / 8.
The bit count of T must be divisible by 8.
Any extra bytes in buffer before writing the integer are set to zero. To
avoid the branch to check for extra buffer bytes, use writeIntBig instead.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1238">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">writeIntSliceBig</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">buffer</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-type">u8</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>Writes a twos-complement integer to memory, with the specified endianness.
Asserts that buf.len &gt;= @typeInfo(T).Int.bits / 8.
The bit count of T must be evenly divisible by 8.
Any extra bytes in buffer not part of the integer are set to zero, with
respect to endianness. To avoid the branch to check for extra buffer bytes,
use writeInt instead.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1271">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">writeIntSlice</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">buffer</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-type">u8</span><span class="tok tok-symbol">,</span> <span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">endian</span><span class="tok tok-symbol">:</span> <span class="tok">builtin</span><span class="tok tok-symbol">.</span><span class="tok">Endian</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>Returns an iterator that iterates over the slices of `buffer` that are not
any of the bytes in `delimiter_bytes`.
tokenize(&quot;   abc def    ghi  &quot;, &quot; &quot;)
Will return slices for &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, null, in that order.
If `buffer` is empty, the iterator will return null.
If `delimiter_bytes` does not exist in buffer,
the iterator will return `buffer`, null, in that order.
See also the related function `split`.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1324">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">tokenize</span><span class="tok tok-symbol">(</span><span class="tok">buffer</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span><span class="tok tok-symbol">,</span> <span class="tok">delimiter_bytes</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span><span class="tok tok-symbol">)</span> <span class="tok">TokenIterator</span></code></pre></div><div class="anal-decl"><b>Returns an iterator that iterates over the slices of `buffer` that
are separated by bytes in `delimiter`.
split(&quot;abc|def||ghi&quot;, &quot;|&quot;)
will return slices for &quot;abc&quot;, &quot;def&quot;, &quot;&quot;, &quot;ghi&quot;, null, in that order.
If `delimiter` does not exist in buffer,
the iterator will return `buffer`, null, in that order.
The delimiter length must not be zero.
See also the related function `tokenize`.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1398">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">split</span><span class="tok tok-symbol">(</span><span class="tok">buffer</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span><span class="tok tok-symbol">,</span> <span class="tok">delimiter</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span><span class="tok tok-symbol">)</span> <span class="tok">SplitIterator</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1441">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">startsWith</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">haystack</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">needle</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok">needle</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">&gt;</span> <span class="tok">haystack</span><span class="tok tok-symbol">.</span><span class="tok">len</span><span class="tok tok-symbol">)</span> <span class="tok tok-null">false</span> <span class="tok tok-kw">else</span> <span class="tok">eql</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">haystack</span><span class="tok tok-symbol">[</span><span class="tok tok-number">0</span><span class="tok tok-symbol">..</span><span class="tok">needle</span><span class="tok tok-symbol">.</span><span class="tok">len</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">,</span> <span class="tok">needle</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1450">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">endsWith</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">haystack</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">needle</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok">needle</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">&gt;</span> <span class="tok">haystack</span><span class="tok tok-symbol">.</span><span class="tok">len</span><span class="tok tok-symbol">)</span> <span class="tok tok-null">false</span> <span class="tok tok-kw">else</span> <span class="tok">eql</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">haystack</span><span class="tok tok-symbol">[</span><span class="tok">haystack</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">-</span> <span class="tok">needle</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">..</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">,</span> <span class="tok">needle</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Naively combines a series of slices with a separator.
Allocates memory for the result, which must be freed by the caller.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1531">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">join</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">separator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span><span class="tok tok-symbol">,</span> <span class="tok">slices</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-type">u8</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">joinMaybeZ</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">separator</span><span class="tok tok-symbol">,</span> <span class="tok">slices</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">false</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Naively combines a series of slices with a separator and null terminator.
Allocates memory for the result, which must be freed by the caller.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1537">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">joinZ</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">separator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span><span class="tok tok-symbol">,</span> <span class="tok">slices</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-type">u8</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-symbol">[</span><span class="tok tok-symbol">:</span><span class="tok tok-number">0</span><span class="tok tok-symbol">]</span><span class="tok tok-type">u8</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">out</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">try</span> <span class="tok">joinMaybeZ</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">,</span> <span class="tok">separator</span><span class="tok tok-symbol">,</span> <span class="tok">slices</span><span class="tok tok-symbol">,</span> <span class="tok tok-null">true</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">out</span><span class="tok tok-symbol">[</span><span class="tok tok-number">0</span> <span class="tok tok-symbol">..</span> <span class="tok">out</span><span class="tok tok-symbol">.</span><span class="tok">len</span> <span class="tok tok-symbol">-</span> <span class="tok tok-number">1</span> <span class="tok tok-symbol">:</span><span class="tok tok-number">0</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Copies each T from slices into a new slice that exactly holds all the elements.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1621">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">concat</span><span class="tok tok-symbol">(</span><span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">slices</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">!</span><span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok">T</span></code></pre></div><div class="anal-decl"><b>Returns the smallest number in a slice. O(n).
`slice` must not be empty.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1814">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">min</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">slice</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok">T</span></code></pre></div><div class="anal-decl"><b>Returns the largest number in a slice. O(n).
`slice` must not be empty.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1828">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">max</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">slice</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok">T</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1840">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">swap</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">a</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">b</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">tmp</span> <span class="tok tok-symbol">=</span> <span class="tok">a</span><span class="tok tok-symbol">.*</span><span class="tok tok-symbol">;</span>
    <span class="tok">a</span><span class="tok tok-symbol">.*</span> <span class="tok tok-symbol">=</span> <span class="tok">b</span><span class="tok tok-symbol">.*</span><span class="tok tok-symbol">;</span>
    <span class="tok">b</span><span class="tok tok-symbol">.*</span> <span class="tok tok-symbol">=</span> <span class="tok">tmp</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>In-place order reversal of a slice
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1847">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">reverse</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">items</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>In-place rotation of the values in an array ([0 1 2 3] becomes [1 2 3 0] if we rotate by 1)
Assumes 0 &lt;= amount &lt;= items.len
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1864">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">rotate</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">items</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">amount</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span> <span class="tok tok-symbol">{</span>
    <span class="tok">reverse</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">items</span><span class="tok tok-symbol">[</span><span class="tok tok-number">0</span><span class="tok tok-symbol">..</span><span class="tok">amount</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">reverse</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">items</span><span class="tok tok-symbol">[</span><span class="tok">amount</span><span class="tok tok-symbol">..</span><span class="tok tok-symbol">]</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">reverse</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">items</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Replace needle with replacement as many times as possible, writing to an output buffer which is assumed to be of
appropriate size. Use replacementSize to calculate an appropriate buffer size.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1879">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">replace</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">input</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">needle</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">replacement</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">output</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">usize</span></code></pre></div><div class="anal-decl"><b>Calculate the size needed in an output buffer to perform a replacement.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1911">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">replacementSize</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">input</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">needle</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">replacement</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">usize</span></code></pre></div><div class="anal-decl"><b>Perform a replacement on an allocated buffer of pre-determined size. Caller must free returned memory.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1932">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">replaceOwned</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">allocator</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">*</span><span class="tok">Allocator</span><span class="tok tok-symbol">,</span> <span class="tok">input</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">needle</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">replacement</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">const</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok">Allocator</span><span class="tok tok-symbol">.</span><span class="tok">Error</span><span class="tok tok-symbol">!</span><span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">var</span> <span class="tok">output</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">try</span> <span class="tok">allocator</span><span class="tok tok-symbol">.</span><span class="tok">alloc</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">replacementSize</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">input</span><span class="tok tok-symbol">,</span> <span class="tok">needle</span><span class="tok tok-symbol">,</span> <span class="tok">replacement</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">_</span> <span class="tok tok-symbol">=</span> <span class="tok">replace</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">input</span><span class="tok tok-symbol">,</span> <span class="tok">needle</span><span class="tok tok-symbol">,</span> <span class="tok">replacement</span><span class="tok tok-symbol">,</span> <span class="tok">output</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">output</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Converts a little-endian integer to host endianness.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1951">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">littleToNative</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">x</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok tok-kw">switch</span> <span class="tok tok-symbol">(</span><span class="tok">builtin</span><span class="tok tok-symbol">.</span><span class="tok">endian</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span>
        <span class="tok tok-symbol">.</span><span class="tok">Little</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok">x</span><span class="tok tok-symbol">,</span>
        <span class="tok tok-symbol">.</span><span class="tok">Big</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok tok-builtin">@byteSwap</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">x</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-symbol">}</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Converts a big-endian integer to host endianness.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1959">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">bigToNative</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">x</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok tok-kw">switch</span> <span class="tok tok-symbol">(</span><span class="tok">builtin</span><span class="tok tok-symbol">.</span><span class="tok">endian</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span>
        <span class="tok tok-symbol">.</span><span class="tok">Little</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok tok-builtin">@byteSwap</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">x</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">,</span>
        <span class="tok tok-symbol">.</span><span class="tok">Big</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok">x</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-symbol">}</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Converts an integer from specified endianness to host endianness.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1967">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">toNative</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">x</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">endianness_of_x</span><span class="tok tok-symbol">:</span> <span class="tok">builtin</span><span class="tok tok-symbol">.</span><span class="tok">Endian</span><span class="tok tok-symbol">)</span> <span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok tok-kw">switch</span> <span class="tok tok-symbol">(</span><span class="tok">endianness_of_x</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span>
        <span class="tok tok-symbol">.</span><span class="tok">Little</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok">littleToNative</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">x</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">,</span>
        <span class="tok tok-symbol">.</span><span class="tok">Big</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok">bigToNative</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">x</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-symbol">}</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Converts an integer which has host endianness to the desired endianness.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1975">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">nativeTo</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">x</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">desired_endianness</span><span class="tok tok-symbol">:</span> <span class="tok">builtin</span><span class="tok tok-symbol">.</span><span class="tok">Endian</span><span class="tok tok-symbol">)</span> <span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok tok-kw">switch</span> <span class="tok tok-symbol">(</span><span class="tok">desired_endianness</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span>
        <span class="tok tok-symbol">.</span><span class="tok">Little</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok">nativeToLittle</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">x</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">,</span>
        <span class="tok tok-symbol">.</span><span class="tok">Big</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok">nativeToBig</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">x</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-symbol">}</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Converts an integer which has host endianness to little endian.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1983">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">nativeToLittle</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">x</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok tok-kw">switch</span> <span class="tok tok-symbol">(</span><span class="tok">builtin</span><span class="tok tok-symbol">.</span><span class="tok">endian</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span>
        <span class="tok tok-symbol">.</span><span class="tok">Little</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok">x</span><span class="tok tok-symbol">,</span>
        <span class="tok tok-symbol">.</span><span class="tok">Big</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok tok-builtin">@byteSwap</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">x</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-symbol">}</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Converts an integer which has host endianness to big endian.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1991">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">nativeToBig</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">x</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok tok-kw">switch</span> <span class="tok tok-symbol">(</span><span class="tok">builtin</span><span class="tok tok-symbol">.</span><span class="tok">endian</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span>
        <span class="tok tok-symbol">.</span><span class="tok">Little</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok tok-builtin">@byteSwap</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">x</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">,</span>
        <span class="tok tok-symbol">.</span><span class="tok">Big</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok">x</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-symbol">}</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Given a pointer to a single item, returns a slice of the underlying bytes, preserving pointer attributes.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L2023">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">asBytes</span><span class="tok tok-symbol">(</span><span class="tok">ptr</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok">AsBytesReturnType</span><span class="tok tok-symbol">(</span><span class="tok tok-builtin">@TypeOf</span><span class="tok tok-symbol">(</span><span class="tok">ptr</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">const</span> <span class="tok">P</span> <span class="tok tok-symbol">=</span> <span class="tok tok-builtin">@TypeOf</span><span class="tok tok-symbol">(</span><span class="tok">ptr</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok tok-builtin">@ptrCast</span><span class="tok tok-symbol">(</span><span class="tok">AsBytesReturnType</span><span class="tok tok-symbol">(</span><span class="tok">P</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">,</span> <span class="tok">ptr</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Given any value, returns a copy of its bytes in an array.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L2077">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">toBytes</span><span class="tok tok-symbol">(</span><span class="tok">value</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">[</span><span class="tok tok-builtin">@sizeOf</span><span class="tok tok-symbol">(</span><span class="tok tok-builtin">@TypeOf</span><span class="tok tok-symbol">(</span><span class="tok">value</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">]</span><span class="tok tok-type">u8</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">asBytes</span><span class="tok tok-symbol">(</span><span class="tok tok-symbol">&amp;</span><span class="tok">value</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">.*</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Given a pointer to an array of bytes, returns a pointer to a value of the specified type
backed by those bytes, preserving pointer attributes.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L2110">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">bytesAsValue</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">bytes</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok">BytesAsValueReturnType</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok tok-builtin">@TypeOf</span><span class="tok tok-symbol">(</span><span class="tok">bytes</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok tok-builtin">@ptrCast</span><span class="tok tok-symbol">(</span><span class="tok">BytesAsValueReturnType</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok tok-builtin">@TypeOf</span><span class="tok tok-symbol">(</span><span class="tok">bytes</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">,</span> <span class="tok">bytes</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Given a pointer to an array of bytes, returns a value of the specified type backed by a
copy of those bytes.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L2167">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">bytesToValue</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">bytes</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">bytesAsValue</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">bytes</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">.*</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Given a slice of bytes, returns a slice of the specified type
backed by those bytes, preserving pointer attributes.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L2194">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">bytesAsSlice</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">bytes</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok">BytesAsSliceReturnType</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok tok-builtin">@TypeOf</span><span class="tok tok-symbol">(</span><span class="tok">bytes</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">)</span></code></pre></div><div class="anal-decl"><b>Given a slice, returns a slice of the underlying bytes, preserving pointer attributes.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L2282">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">sliceAsBytes</span><span class="tok tok-symbol">(</span><span class="tok">slice</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok">SliceAsBytesReturnType</span><span class="tok tok-symbol">(</span><span class="tok tok-builtin">@TypeOf</span><span class="tok tok-symbol">(</span><span class="tok">slice</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">)</span></code></pre></div><div class="anal-decl"><b>Round an address up to the nearest aligned address
The alignment must be a power of 2 and greater than 0.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L2379">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">alignForward</span><span class="tok tok-symbol">(</span><span class="tok">addr</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span> <span class="tok">alignment</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">usize</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">alignForwardGeneric</span><span class="tok tok-symbol">(</span><span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span> <span class="tok">addr</span><span class="tok tok-symbol">,</span> <span class="tok">alignment</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Round an address up to the nearest aligned address
The alignment must be a power of 2 and greater than 0.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L2385">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">alignForwardGeneric</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">addr</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">alignment</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok">T</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">alignBackwardGeneric</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">addr</span> <span class="tok tok-symbol">+</span> <span class="tok tok-symbol">(</span><span class="tok">alignment</span> <span class="tok tok-symbol">-</span> <span class="tok tok-number">1</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">,</span> <span class="tok">alignment</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Force an evaluation of the expression; this tries to prevent
the compiler from optimizing the computation away even if the
result eventually gets discarded.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L2392">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">doNotOptimizeAway</span><span class="tok tok-symbol">(</span><span class="tok">val</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">void</span></code></pre></div><div class="anal-decl"><b>Round an address up to the previous aligned address
Unlike `alignBackward`, `alignment` can be any positive number, not just a power of 2.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L2417">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">alignBackwardAnyAlign</span><span class="tok tok-symbol">(</span><span class="tok">i</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span> <span class="tok">alignment</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">usize</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@popCount</span><span class="tok tok-symbol">(</span><span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span> <span class="tok">alignment</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">==</span> <span class="tok tok-number">1</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-kw">return</span> <span class="tok">alignBackward</span><span class="tok tok-symbol">(</span><span class="tok">i</span><span class="tok tok-symbol">,</span> <span class="tok">alignment</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">assert</span><span class="tok tok-symbol">(</span><span class="tok">alignment</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok">i</span> <span class="tok tok-symbol">-</span> <span class="tok tok-builtin">@mod</span><span class="tok tok-symbol">(</span><span class="tok">i</span><span class="tok tok-symbol">,</span> <span class="tok">alignment</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Round an address up to the previous aligned address
The alignment must be a power of 2 and greater than 0.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L2426">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">alignBackward</span><span class="tok tok-symbol">(</span><span class="tok">addr</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span> <span class="tok">alignment</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">usize</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">alignBackwardGeneric</span><span class="tok tok-symbol">(</span><span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span> <span class="tok">addr</span><span class="tok tok-symbol">,</span> <span class="tok">alignment</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Round an address up to the previous aligned address
The alignment must be a power of 2 and greater than 0.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L2432">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">alignBackwardGeneric</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">addr</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">alignment</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok">T</span></code></pre></div><div class="anal-decl"><b>Returns whether `alignment` is a valid alignment, meaning it is
a positive power of 2.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L2442">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">isValidAlign</span><span class="tok tok-symbol">(</span><span class="tok">alignment</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">u29</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok tok-builtin">@popCount</span><span class="tok tok-symbol">(</span><span class="tok tok-type">u29</span><span class="tok tok-symbol">,</span> <span class="tok">alignment</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">==</span> <span class="tok tok-number">1</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L2446">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">isAlignedAnyAlign</span><span class="tok tok-symbol">(</span><span class="tok">i</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span> <span class="tok">alignment</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">if</span> <span class="tok tok-symbol">(</span><span class="tok tok-builtin">@popCount</span><span class="tok tok-symbol">(</span><span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span> <span class="tok">alignment</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">==</span> <span class="tok tok-number">1</span><span class="tok tok-symbol">)</span>
        <span class="tok tok-kw">return</span> <span class="tok">isAligned</span><span class="tok tok-symbol">(</span><span class="tok">i</span><span class="tok tok-symbol">,</span> <span class="tok">alignment</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok">assert</span><span class="tok tok-symbol">(</span><span class="tok">alignment</span> <span class="tok tok-symbol">!=</span> <span class="tok tok-number">0</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
    <span class="tok tok-kw">return</span> <span class="tok tok-number">0</span> <span class="tok tok-symbol">==</span> <span class="tok tok-builtin">@mod</span><span class="tok tok-symbol">(</span><span class="tok">i</span><span class="tok tok-symbol">,</span> <span class="tok">alignment</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Given an address and an alignment, return true if the address is a multiple of the alignment
The alignment must be a power of 2 and greater than 0.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L2455">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">isAligned</span><span class="tok tok-symbol">(</span><span class="tok">addr</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">,</span> <span class="tok">alignment</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">isAlignedGeneric</span><span class="tok tok-symbol">(</span><span class="tok tok-type">u64</span><span class="tok tok-symbol">,</span> <span class="tok">addr</span><span class="tok tok-symbol">,</span> <span class="tok">alignment</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L2459">src</a><pre><code class="zig"><span class="tok tok-kw">pub</span> <span class="tok tok-kw">fn</span> <span class="tok tok-fn">isAlignedGeneric</span><span class="tok tok-symbol">(</span><span class="tok tok-kw">comptime</span> <span class="tok">T</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">type</span><span class="tok tok-symbol">,</span> <span class="tok">addr</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">alignment</span><span class="tok tok-symbol">:</span> <span class="tok">T</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">bool</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-kw">return</span> <span class="tok">alignBackwardGeneric</span><span class="tok tok-symbol">(</span><span class="tok">T</span><span class="tok tok-symbol">,</span> <span class="tok">addr</span><span class="tok tok-symbol">,</span> <span class="tok">alignment</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">==</span> <span class="tok">addr</span><span class="tok tok-symbol">;</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>Returns the largest slice in the given bytes that conforms to the new alignment,
or `null` if the given bytes contain no conforming address.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L2503">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">alignInBytes</span><span class="tok tok-symbol">(</span><span class="tok">bytes</span><span class="tok tok-symbol">:</span> <span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-type">u8</span><span class="tok tok-symbol">,</span> <span class="tok tok-kw">comptime</span> <span class="tok">new_alignment</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok tok-symbol">[</span><span class="tok tok-symbol">]</span><span class="tok tok-kw">align</span><span class="tok tok-symbol">(</span><span class="tok">new_alignment</span><span class="tok tok-symbol">)</span> <span class="tok tok-type">u8</span></code></pre></div><div class="anal-decl"><b>Returns the largest sub-slice within the given slice that conforms to the new alignment,
or `null` if the given slice contains no conforming address.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L2517">src</a><pre><code class="zig"><span class="tok tok-kw">fn</span> <span class="tok tok-fn">alignInSlice</span><span class="tok tok-symbol">(</span><span class="tok">slice</span><span class="tok tok-symbol">:</span> <span class="tok tok-kw">anytype</span><span class="tok tok-symbol">,</span> <span class="tok tok-kw">comptime</span> <span class="tok">new_alignment</span><span class="tok tok-symbol">:</span> <span class="tok tok-type">usize</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">?</span><span class="tok">AlignedSlice</span><span class="tok tok-symbol">(</span><span class="tok tok-builtin">@TypeOf</span><span class="tok tok-symbol">(</span><span class="tok">slice</span><span class="tok tok-symbol">)</span><span class="tok tok-symbol">,</span> <span class="tok">new_alignment</span><span class="tok tok-symbol">)</span></code></pre></div></div><h2 style="color: orange;">values:</h2><div class="more-decls"><div class="anal-decl"><b>Compile time known minimum page size.
https://github.com/ziglang/zig/issues/4082
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L18">src</a><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">page_size</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">switch</span> <span class="tok tok-symbol">(</span><span class="tok">builtin</span><span class="tok tok-symbol">.</span><span class="tok">arch</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-symbol">.</span><span class="tok">wasm32</span><span class="tok tok-symbol">,</span> <span class="tok tok-symbol">.</span><span class="tok">wasm64</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok tok-number">64</span> <span class="tok tok-symbol">*</span> <span class="tok tok-number">1024</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-symbol">.</span><span class="tok">aarch64</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok tok-kw">switch</span> <span class="tok tok-symbol">(</span><span class="tok">builtin</span><span class="tok tok-symbol">.</span><span class="tok">os</span><span class="tok tok-symbol">.</span><span class="tok">tag</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span>
        <span class="tok tok-symbol">.</span><span class="tok">macos</span><span class="tok tok-symbol">,</span> <span class="tok tok-symbol">.</span><span class="tok">ios</span><span class="tok tok-symbol">,</span> <span class="tok tok-symbol">.</span><span class="tok">watchos</span><span class="tok tok-symbol">,</span> <span class="tok tok-symbol">.</span><span class="tok">tvos</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok tok-number">16</span> <span class="tok tok-symbol">*</span> <span class="tok tok-number">1024</span><span class="tok tok-symbol">,</span>
        <span class="tok tok-kw">else</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok tok-number">4</span> <span class="tok tok-symbol">*</span> <span class="tok tok-number">1024</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-symbol">}</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-symbol">.</span><span class="tok">sparcv9</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok tok-number">8</span> <span class="tok tok-symbol">*</span> <span class="tok tok-number">1024</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-kw">else</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok tok-number">4</span> <span class="tok tok-symbol">*</span> <span class="tok tok-number">1024</span><span class="tok tok-symbol">,</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><b>The standard library currently thoroughly depends on byte size
being 8 bits.  (see the use of u8 throughout allocation code as
the &quot;byte&quot; type.)  Code which depends on this can reference this
declaration.  If we ever try to port the standard library to a
non-8-bit-byte platform, this will allow us to search for things
which need to be updated.
</b><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L34">src</a><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">byte_size_in_bits</span> <span class="tok tok-symbol">=</span> <span class="tok tok-number">8</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L36">src</a><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">Allocator</span> <span class="tok tok-symbol">=</span> <span class="tok tok-builtin">@import</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;mem/Allocator.zig&quot;</span><span class="tok tok-symbol">)</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L514">src</a><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">toSliceConst</span> <span class="tok tok-symbol">=</span> <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;deprecated; use std.mem.spanZ&quot;</span><span class="tok tok-symbol">)</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L515">src</a><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">toSlice</span> <span class="tok tok-symbol">=</span> <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;deprecated; use std.mem.spanZ&quot;</span><span class="tok tok-symbol">)</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1080">src</a><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">readIntLittle</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">switch</span> <span class="tok tok-symbol">(</span><span class="tok">builtin</span><span class="tok tok-symbol">.</span><span class="tok">endian</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-symbol">.</span><span class="tok">Little</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok">readIntNative</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-symbol">.</span><span class="tok">Big</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok">readIntForeign</span><span class="tok tok-symbol">,</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1085">src</a><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">readIntBig</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">switch</span> <span class="tok tok-symbol">(</span><span class="tok">builtin</span><span class="tok tok-symbol">.</span><span class="tok">endian</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-symbol">.</span><span class="tok">Little</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok">readIntForeign</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-symbol">.</span><span class="tok">Big</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok">readIntNative</span><span class="tok tok-symbol">,</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1109">src</a><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">readIntSliceLittle</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">switch</span> <span class="tok tok-symbol">(</span><span class="tok">builtin</span><span class="tok tok-symbol">.</span><span class="tok">endian</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-symbol">.</span><span class="tok">Little</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok">readIntSliceNative</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-symbol">.</span><span class="tok">Big</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok">readIntSliceForeign</span><span class="tok tok-symbol">,</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1114">src</a><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">readIntSliceBig</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">switch</span> <span class="tok tok-symbol">(</span><span class="tok">builtin</span><span class="tok tok-symbol">.</span><span class="tok">endian</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-symbol">.</span><span class="tok">Little</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok">readIntSliceForeign</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-symbol">.</span><span class="tok">Big</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok">readIntSliceNative</span><span class="tok tok-symbol">,</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1191">src</a><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">writeIntLittle</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">switch</span> <span class="tok tok-symbol">(</span><span class="tok">builtin</span><span class="tok tok-symbol">.</span><span class="tok">endian</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-symbol">.</span><span class="tok">Little</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok">writeIntNative</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-symbol">.</span><span class="tok">Big</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok">writeIntForeign</span><span class="tok tok-symbol">,</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1196">src</a><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">writeIntBig</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">switch</span> <span class="tok tok-symbol">(</span><span class="tok">builtin</span><span class="tok tok-symbol">.</span><span class="tok">endian</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-symbol">.</span><span class="tok">Little</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok">writeIntForeign</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-symbol">.</span><span class="tok">Big</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok">writeIntNative</span><span class="tok tok-symbol">,</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1255">src</a><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">writeIntSliceNative</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">switch</span> <span class="tok tok-symbol">(</span><span class="tok">builtin</span><span class="tok tok-symbol">.</span><span class="tok">endian</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-symbol">.</span><span class="tok">Little</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok">writeIntSliceLittle</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-symbol">.</span><span class="tok">Big</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok">writeIntSliceBig</span><span class="tok tok-symbol">,</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1260">src</a><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">writeIntSliceForeign</span> <span class="tok tok-symbol">=</span> <span class="tok tok-kw">switch</span> <span class="tok tok-symbol">(</span><span class="tok">builtin</span><span class="tok tok-symbol">.</span><span class="tok">endian</span><span class="tok tok-symbol">)</span> <span class="tok tok-symbol">{</span>
    <span class="tok tok-symbol">.</span><span class="tok">Little</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok">writeIntSliceBig</span><span class="tok tok-symbol">,</span>
    <span class="tok tok-symbol">.</span><span class="tok">Big</span> <span class="tok tok-symbol">=&gt;</span> <span class="tok">writeIntSliceLittle</span><span class="tok tok-symbol">,</span>
<span class="tok tok-symbol">}</span></code></pre></div><div class="anal-decl"><a href="https://github.com/ziglang/zig/blob/master/lib/std/mem.zig#L1407">src</a><pre><code class="zig"><span class="tok tok-kw">const</span> <span class="tok">separate</span> <span class="tok tok-symbol">=</span> <span class="tok tok-builtin">@compileError</span><span class="tok tok-symbol">(</span><span class="tok tok-str">&quot;deprecated: renamed to split (behavior remains unchanged)&quot;</span><span class="tok tok-symbol">)</span></code></pre></div></div></html>