[{"pl":"pub const ArgIteratorPosix = struct ","src":186,"more_decls":{"pl":"index: usize","src":187,"more_decls":null}{"pl":"count: usize","src":188,"more_decls":null}{"pl":"pub fn init() ArgIteratorPosix {\n    return ArgIteratorPosix{\n        .index = 0,\n        .count = os.argv.len,\n    };\n}","src":190,"more_decls":null}{"pl":"fn next(self: *ArgIteratorPosix) ?[:0]const u8","src":197,"more_decls":null}{"pl":"pub fn skip(self: *ArgIteratorPosix) bool {\n    if (self.index == self.count) return false;\n\n    self.index += 1;\n    return true;\n}","src":205,"more_decls":null}}{"pl":"pub const ArgIteratorWasi = struct ","src":213,"more_decls":{"pl":"allocator: *mem.Allocator","src":214,"more_decls":null}{"pl":"index: usize","src":215,"more_decls":null}{"pl":"args: [][:0]u8","src":216,"more_decls":null}{"doc_comment":"You must call deinit to free the internal buffer of the\niterator after you are done.","pl":"fn init(allocator: *mem.Allocator) InitError!ArgIteratorWasi","src":222,"more_decls":null}{"pl":"fn next(self: *ArgIteratorWasi) ?[:0]const u8","src":260,"more_decls":null}{"pl":"pub fn skip(self: *ArgIteratorWasi) bool {\n    if (self.index == self.args.len) return false;\n\n    self.index += 1;\n    return true;\n}","src":268,"more_decls":null}{"doc_comment":"Call to free the internal buffer of the iterator.","pl":"fn deinit(self: *ArgIteratorWasi) void","src":276,"more_decls":null}{"pl":"const InitError = error{OutOfMemory} || os.UnexpectedError","src":218,"more_decls":null}}{"pl":"pub const ArgIteratorWindows = struct ","src":286,"more_decls":{"pl":"index: usize","src":287,"more_decls":null}{"pl":"cmd_line: [*]const u16","src":288,"more_decls":null}{"pl":"pub fn init() ArgIteratorWindows {\n    return initWithCmdLine(os.windows.kernel32.GetCommandLineW());\n}","src":292,"more_decls":null}{"pl":"pub fn initWithCmdLine(cmd_line: [*]const u16) ArgIteratorWindows {\n    return ArgIteratorWindows{\n        .index = 0,\n        .cmd_line = cmd_line,\n    };\n}","src":296,"more_decls":null}{"doc_comment":"You must free the returned memory when done.","pl":"fn next(self: *ArgIteratorWindows, allocator: *Allocator) ?(NextError![:0]u8)","src":312,"more_decls":null}{"pl":"fn skip(self: *ArgIteratorWindows) bool","src":326,"more_decls":null}{"pl":"const NextError = error{ OutOfMemory, InvalidCmdLine }","src":290,"more_decls":null}}{"pl":"pub const ArgIterator = struct ","src":428,"more_decls":{"pl":"inner: InnerType","src":435,"more_decls":null}{"doc_comment":"Initialize the args iterator.","pl":"fn init() ArgIterator","src":438,"more_decls":null}{"doc_comment":"You must deinitialize iterator's internal buffers by calling `deinit` when done.","pl":"fn initWithAllocator(allocator: *mem.Allocator) InitError!ArgIterator","src":449,"more_decls":null}{"doc_comment":"You must free the returned memory when done.","pl":"fn next(self: *ArgIterator, allocator: *Allocator) ?(NextError![:0]u8)","src":460,"more_decls":null}{"doc_comment":"If you only are targeting posix you can call this and not need an allocator.","pl":"pub fn nextPosix(self: *ArgIterator) ?[:0]const u8 {\n    return self.inner.next();\n}","src":469,"more_decls":null}{"doc_comment":"If you only are targeting WASI, you can call this and not need an allocator.","pl":"pub fn nextWasi(self: *ArgIterator) ?[:0]const u8 {\n    return self.inner.next();\n}","src":474,"more_decls":null}{"doc_comment":"Parse past 1 argument without capturing it.\nReturns `true` if skipped an arg, `false` if we are at the end.","pl":"pub fn skip(self: *ArgIterator) bool {\n    return self.inner.skip();\n}","src":480,"more_decls":null}{"doc_comment":"Call this to free the iterator's internal buffer if the iterator\nwas created with `initWithAllocator` function.","pl":"pub fn deinit(self: *ArgIterator) void {\n    // Unless we're targeting WASI, this is a no-op.\n    if (builtin.os.tag == .wasi) {\n        self.inner.deinit();\n    }\n}","src":486,"more_decls":null}{"pl":"const InitError = ArgIteratorWasi.InitError","src":446,"more_decls":null}{"pl":"const NextError = ArgIteratorWindows.NextError","src":457,"more_decls":null}}{"pl":"pub const UserInfo = struct ","src":603,"more_decls":{"pl":"uid: os.uid_t","src":604,"more_decls":null}{"pl":"gid: os.gid_t","src":605,"more_decls":null}}{"doc_comment":"The result is a slice of `out_buffer`, from index `0`.","pl":"pub fn getCwd(out_buffer: []u8) ![]u8 {\n    return os.getcwd(out_buffer);\n}","src":23,"more_decls":null}{"doc_comment":"Caller must free the returned memory.","pl":"fn getCwdAlloc(allocator: *Allocator) ![]u8","src":28,"more_decls":null}{"doc_comment":"Caller owns resulting `BufMap`.","pl":"fn getEnvMap(allocator: *Allocator) !BufMap","src":61,"more_decls":null}{"doc_comment":"Caller must free returned memory.","pl":"fn getEnvVarOwned(allocator: *mem.Allocator, key: []const u8) GetEnvVarOwnedError![]u8","src":161,"more_decls":null}{"pl":"pub fn args() ArgIterator {\n    return ArgIterator.init();\n}","src":494,"more_decls":null}{"doc_comment":"You must deinitialize iterator's internal buffers by calling `deinit` when done.","pl":"pub fn argsWithAllocator(allocator: *mem.Allocator) ArgIterator.InitError!ArgIterator {\n    return ArgIterator.initWithAllocator(allocator);\n}","src":499,"more_decls":null}{"doc_comment":"Caller must call argsFree on result.","pl":"fn argsAlloc(allocator: *mem.Allocator) ![][:0]u8","src":525,"more_decls":null}{"pl":"fn argsFree(allocator: *mem.Allocator, args_alloc: []const [:0]u8) void","src":565,"more_decls":null}{"doc_comment":"POSIX function which gets a uid from username.","pl":"pub fn getUserInfo(name: []const u8) !UserInfo {\n    return switch (builtin.os.tag) {\n        .linux, .macos, .watchos, .tvos, .ios, .freebsd, .netbsd, .openbsd, .haiku => posixGetUserInfo(name),\n        else => @compileError(\"Unsupported OS\"),\n    };\n}","src":609,"more_decls":null}{"doc_comment":"TODO this reads /etc/passwd. But sometimes the user/id mapping is in something else\nlike NIS, AD, etc. See `man nss` or look at an strace for `id myuser`.","pl":"fn posixGetUserInfo(name: []const u8) !UserInfo","src":618,"more_decls":null}{"pl":"fn getBaseAddress() usize","src":704,"more_decls":null}{"doc_comment":"Caller owns the result value and each inner slice.\nTODO Remove the `Allocator` requirement from this API, which will remove the `Allocator`\nrequirement from `std.zig.system.NativeTargetInfo.detect`. Most likely this will require\nintroducing a new, lower-level function which takes a callback function, and then this\nfunction which takes an allocator can exist on top of it.","pl":"fn getSelfExeSharedLibPaths(allocator: *Allocator) error{OutOfMemory}![][:0]u8","src":727,"more_decls":null}{"doc_comment":"Replaces the current process image with the executed process.\nThis function must allocate memory to add a null terminating bytes on path and each arg.\nIt must also convert to KEY=VALUE\\0 format for environment variables, and include null\npointers after the args and after the environment variables.\n`argv[0]` is the executable path.\nThis function also uses the PATH environment variable to get the full path to the executable.\nDue to the heap-allocation, it is illegal to call this function in a fork() child.\nFor that use case, use the `std.os` functions directly.","pl":"pub fn execv(allocator: *mem.Allocator, argv: []const []const u8) ExecvError {\n    return execve(allocator, argv, null);\n}","src":814,"more_decls":null}{"doc_comment":"Replaces the current process image with the executed process.\nThis function must allocate memory to add a null terminating bytes on path and each arg.\nIt must also convert to KEY=VALUE\\0 format for environment variables, and include null\npointers after the args and after the environment variables.\n`argv[0]` is the executable path.\nThis function also uses the PATH environment variable to get the full path to the executable.\nDue to the heap-allocation, it is illegal to call this function in a fork() child.\nFor that use case, use the `std.os` functions directly.","pl":"fn execve(\n    allocator: *mem.Allocator,\n    argv: []const []const u8,\n    env_map: ?*const std.BufMap,\n) ExecvError","src":826,"more_decls":null}{"pl":"const abort = os.abort","src":17,"more_decls":null}{"pl":"const exit = os.exit","src":18,"more_decls":null}{"pl":"const changeCurDir = os.chdir","src":19,"more_decls":null}{"pl":"const changeCurDirC = os.chdirC","src":20,"more_decls":null}{"pl":"const GetEnvVarOwnedError = error{\n    OutOfMemory,\n    EnvironmentVariableNotFound,\n\n    /// See https://github.com/ziglang/zig/issues/1774\n    InvalidUtf8,\n}","src":152,"more_decls":null}{"doc_comment":"Tells whether calling the `execv` or `execve` functions will be a compile error.","pl":"const can_execv = std.builtin.os.tag != .windows","src":802,"more_decls":null}{"pl":"const ExecvError = std.os.ExecveError || error{OutOfMemory}","src":804,"more_decls":null}]