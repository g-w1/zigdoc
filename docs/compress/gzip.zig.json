[{"pl":"fn GzipStream(comptime ReaderType: type) type","sub_container_type":"struct ","src":22,"more_decls":{"pl":"allocator: *mem.Allocator","src":31,"more_decls":null}{"pl":"inflater: deflate.InflateStream(ReaderType)","src":32,"more_decls":null}{"pl":"in_reader: ReaderType","src":33,"more_decls":null}{"pl":"hasher: std.hash.Crc32","src":34,"more_decls":null}{"pl":"window_slice: []u8","src":35,"more_decls":null}{"pl":"read_amt: usize","src":36,"more_decls":null}{"pl":"info: struct {\n            filename: ?[]const u8,\n            comment: ?[]const u8,\n            modification_time: u32,\n        }","src":38,"more_decls":null}{"pl":"fn deinit(self: *Self) void","src":117,"more_decls":null}{"pl":"fn read(self: *Self, buffer: []u8) Error!usize","src":126,"more_decls":null}{"pl":"pub fn reader(self: *Self) Reader {\n    return .{ .context = self };\n}","src":151,"more_decls":null}{"pl":"const Error = ReaderType.Error ||\n            deflate.InflateStream(ReaderType).Error ||\n            error{ CorruptedData, WrongChecksum }","src":26,"more_decls":null}{"pl":"const Reader = io.Reader(*Self, Error, read)","src":29,"more_decls":null}}{"pl":"pub fn gzipStream(allocator: *mem.Allocator, reader: anytype) !GzipStream(@TypeOf(reader)) {\n    return GzipStream(@TypeOf(reader)).init(allocator, reader);\n}","src":157,"more_decls":null}{"pl":"fn assertEqual(comptime expected: []const u8, input: []const u8) void","src":178,"more_decls":null}]