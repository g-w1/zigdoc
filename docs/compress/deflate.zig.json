[{"pl":"fn InflateStream(comptime ReaderType: type) type","sub_container_type":"struct ","src":139,"more_decls":{"pl":"inner_reader: ReaderType","src":159,"more_decls":null}{"pl":"seen_eos: bool","src":163,"more_decls":null}{"pl":"state: union(enum) {\n            // Parse a compressed block header and set up the internal state for\n            // decompressing its contents.\n            DecodeBlockHeader: void,\n            // Decode all the symbols in a compressed block.\n            DecodeBlockData: void,\n            // Copy N bytes of uncompressed data from the underlying stream into\n            // the window.\n            Copy: usize,\n            // Copy 1 byte into the window.\n            CopyLit: u8,\n            // Copy L bytes from the window itself, starting from D bytes\n            // behind.\n            CopyFrom: struct { distance: u16, length: u16 },\n        }","src":165,"more_decls":null}{"pl":"window: struct {\n            const WSelf = @This();\n\n            // invariant: buffer length is always a power of 2\n            buf: []u8,\n            // invariant: ri <= wi\n            wi: usize = 0, // Write index\n            ri: usize = 0, // Read index\n            el: usize = 0, // Number of readable elements\n\n            fn readable(self: *WSelf) usize {\n                return self.el;\n            }\n\n            fn writable(self: *WSelf) usize {\n                return self.buf.len - self.el;\n            }\n\n            // Insert a single byte into the window.\n            // Returns 1 if there's enough space for the new byte and 0\n            // otherwise.\n            fn append(self: *WSelf, value: u8) usize {\n                if (self.writable() < 1) return 0;\n                self.appendUnsafe(value);\n                return 1;\n            }\n\n            // Insert a single byte into the window.\n            // Assumes there's enough space.\n            fn appendUnsafe(self: *WSelf, value: u8) callconv(.Inline) void {\n                self.buf[self.wi] = value;\n                self.wi = (self.wi + 1) & (self.buf.len - 1);\n                self.el += 1;\n            }\n\n            // Fill dest[] with data from the window, starting from the read\n            // position. This updates the read pointer.\n            // Returns the number of read bytes or 0 if there's nothing to read\n            // yet.\n            fn read(self: *WSelf, dest: []u8) usize {\n                const N = math.min(dest.len, self.readable());\n\n                if (N == 0) return 0;\n\n                if (self.ri + N < self.buf.len) {\n                    // The data doesn't wrap around\n                    mem.copy(u8, dest, self.buf[self.ri .. self.ri + N]);\n                } else {\n                    // The data wraps around the buffer, split the copy\n                    std.mem.copy(u8, dest, self.buf[self.ri..]);\n                    // How much data we've copied from `ri` to the end\n                    const r = self.buf.len - self.ri;\n                    std.mem.copy(u8, dest[r..], self.buf[0 .. N - r]);\n                }\n\n                self.ri = (self.ri + N) & (self.buf.len - 1);\n                self.el -= N;\n\n                return N;\n            }\n\n            // Copy `length` bytes starting from `distance` bytes behind the\n            // write pointer.\n            // Be careful as the length may be greater than the distance, that's\n            // how the compressor encodes run-length encoded sequences.\n            fn copyFrom(self: *WSelf, distance: usize, length: usize) usize {\n                const N = math.min(length, self.writable());\n\n                if (N == 0) return 0;\n\n                // TODO: Profile and, if needed, replace with smarter juggling\n                // of the window memory for the non-overlapping case.\n                var i: usize = 0;\n                while (i < N) : (i += 1) {\n                    const index = (self.wi -% distance) & (self.buf.len - 1);\n                    self.appendUnsafe(self.buf[index]);\n                }\n\n                return N;\n            }\n        }","src":182,"more_decls":null}{"pl":"huffman_tables: [2]Huffman = undefined","src":266,"more_decls":null}{"pl":"hdist: *Huffman","src":269,"more_decls":null}{"pl":"hlen: *Huffman","src":270,"more_decls":null}{"pl":"bits: u32","src":274,"more_decls":null}{"pl":"bits_left: usize","src":275,"more_decls":null}{"pl":"fn read(self: *Self, buffer: []u8) Error!usize","src":626,"more_decls":null}{"pl":"pub fn reader(self: *Self) Reader {\n    return .{ .context = self };\n}","src":648,"more_decls":null}{"pl":"const Error = ReaderType.Error || error{\n            EndOfStream,\n            BadCounts,\n            InvalidBlockType,\n            InvalidDistance,\n            InvalidFixedCode,\n            InvalidLength,\n            InvalidStoredSize,\n            InvalidSymbol,\n            InvalidTree,\n            MissingEOBCode,\n            NoLastLength,\n            OutOfCodes,\n        }","src":143,"more_decls":null}{"pl":"const Reader = io.Reader(*Self, Error, read)","src":157,"more_decls":null}}{"pl":"pub fn inflateStream(reader: anytype, window_slice: []u8) InflateStream(@TypeOf(reader)) {\n    return InflateStream(@TypeOf(reader)).init(reader, window_slice);\n}","src":654,"more_decls":null}]