[{"doc_comment":"A single token slice into the parent string.\n\nUse `token.slice()` on the input at the current position to get the current slice.","pl":"pub const Token = union(enum) ","src":98,"more_decls":{"pl":"ObjectBegin","src":99,"more_decls":null}{"pl":"ObjectEnd","src":100,"more_decls":null}{"pl":"ArrayBegin","src":101,"more_decls":null}{"pl":"ArrayEnd","src":102,"more_decls":null}{"pl":"String: struct {\n        /// How many bytes the token is.\n        count: usize,\n\n        /// Whether string contains an escape sequence and cannot be zero-copied\n        escapes: StringEscapes,\n\n        pub fn decodedLength(self: @This()) usize {\n            return self.count +% switch (self.escapes) {\n                .None => 0,\n                .Some => |s| @bitCast(usize, s.size_diff),\n            };\n        }\n\n        /// Slice into the underlying input string.\n        pub fn slice(self: @This(), input: []const u8, i: usize) []const u8 {\n            return input[i - self.count .. i];\n        }\n    }","src":103,"more_decls":null}{"pl":"Number: struct {\n        /// How many bytes the token is.\n        count: usize,\n\n        /// Whether number is simple and can be represented by an integer (i.e. no `.` or `e`)\n        is_integer: bool,\n\n        /// Slice into the underlying input string.\n        pub fn slice(self: @This(), input: []const u8, i: usize) []const u8 {\n            return input[i - self.count .. i];\n        }\n    }","src":122,"more_decls":null}{"pl":"True","src":134,"more_decls":null}{"pl":"False","src":135,"more_decls":null}{"pl":"Null","src":136,"more_decls":null}}{"doc_comment":"A small streaming JSON parser. This accepts input one byte at a time and returns tokens as\nthey are encountered. No copies or allocations are performed during parsing and the entire\nparsing state requires ~40-50 bytes of stack space.\n\nConforms strictly to RFC8259.\n\nFor a non-byte based wrapper, consider using TokenStream instead.","pl":"pub const StreamingParser = struct ","src":146,"more_decls":{"pl":"state: State","src":148,"more_decls":null}{"pl":"count: usize","src":150,"more_decls":null}{"pl":"after_string_state: State","src":152,"more_decls":null}{"pl":"after_value_state: State","src":154,"more_decls":null}{"pl":"complete: bool","src":156,"more_decls":null}{"pl":"string_escapes: StringEscapes","src":158,"more_decls":null}{"pl":"string_last_was_high_surrogate: bool","src":160,"more_decls":null}{"pl":"string_unicode_codepoint: u21","src":162,"more_decls":null}{"pl":"sequence_first_byte: u8 = undefined","src":164,"more_decls":null}{"pl":"number_is_integer: bool","src":166,"more_decls":null}{"pl":"stack: u256","src":169,"more_decls":null}{"pl":"stack_used: u8","src":170,"more_decls":null}{"pl":"pub const State = enum ","src":197,"more_decls":{"pl":"ObjectSeparator = 0","src":200,"more_decls":null}{"pl":"ValueEnd = 1","src":201,"more_decls":null}{"pl":"TopLevelBegin","src":203,"more_decls":null}{"pl":"TopLevelEnd","src":204,"more_decls":null}{"pl":"ValueBegin","src":206,"more_decls":null}{"pl":"ValueBeginNoClosing","src":207,"more_decls":null}{"pl":"String","src":209,"more_decls":null}{"pl":"StringUtf8Byte2Of2","src":210,"more_decls":null}{"pl":"StringUtf8Byte2Of3","src":211,"more_decls":null}{"pl":"StringUtf8Byte3Of3","src":212,"more_decls":null}{"pl":"StringUtf8Byte2Of4","src":213,"more_decls":null}{"pl":"StringUtf8Byte3Of4","src":214,"more_decls":null}{"pl":"StringUtf8Byte4Of4","src":215,"more_decls":null}{"pl":"StringEscapeCharacter","src":216,"more_decls":null}{"pl":"StringEscapeHexUnicode4","src":217,"more_decls":null}{"pl":"StringEscapeHexUnicode3","src":218,"more_decls":null}{"pl":"StringEscapeHexUnicode2","src":219,"more_decls":null}{"pl":"StringEscapeHexUnicode1","src":220,"more_decls":null}{"pl":"Number","src":222,"more_decls":null}{"pl":"NumberMaybeDotOrExponent","src":223,"more_decls":null}{"pl":"NumberMaybeDigitOrDotOrExponent","src":224,"more_decls":null}{"pl":"NumberFractionalRequired","src":225,"more_decls":null}{"pl":"NumberFractional","src":226,"more_decls":null}{"pl":"NumberMaybeExponent","src":227,"more_decls":null}{"pl":"NumberExponent","src":228,"more_decls":null}{"pl":"NumberExponentDigitsRequired","src":229,"more_decls":null}{"pl":"NumberExponentDigits","src":230,"more_decls":null}{"pl":"TrueLiteral1","src":232,"more_decls":null}{"pl":"TrueLiteral2","src":233,"more_decls":null}{"pl":"TrueLiteral3","src":234,"more_decls":null}{"pl":"FalseLiteral1","src":236,"more_decls":null}{"pl":"FalseLiteral2","src":237,"more_decls":null}{"pl":"FalseLiteral3","src":238,"more_decls":null}{"pl":"FalseLiteral4","src":239,"more_decls":null}{"pl":"NullLiteral1","src":241,"more_decls":null}{"pl":"NullLiteral2","src":242,"more_decls":null}{"pl":"NullLiteral3","src":243,"more_decls":null}{"pl":"pub fn fromInt(x: anytype) State {\n    debug.assert(x == 0 or x == 1);\n    const T = std.meta.Tag(State);\n    return @intToEnum(State, @intCast(T, x));\n}","src":246,"more_decls":null}}{"pl":"pub fn init() StreamingParser {\n    var p: StreamingParser = undefined;\n    p.reset();\n    return p;\n}","src":176,"more_decls":null}{"pl":"fn reset(p: *StreamingParser) void","src":182,"more_decls":null}{"doc_comment":"Give another byte to the parser and obtain any new tokens. This may (rarely) return two\ntokens. token2 is always null if token1 is null.\n\nThere is currently no error recovery on a bad stream.","pl":"fn feed(p: *StreamingParser, c: u8, token1: *?Token, token2: *?Token) Error!void","src":277,"more_decls":null}{"pl":"const Error = error{\n        InvalidTopLevel,\n        TooManyNestedItems,\n        TooManyClosingItems,\n        InvalidValueBegin,\n        InvalidValueEnd,\n        UnbalancedBrackets,\n        UnbalancedBraces,\n        UnexpectedClosingBracket,\n        UnexpectedClosingBrace,\n        InvalidNumber,\n        InvalidSeparator,\n        InvalidLiteral,\n        InvalidEscapeCharacter,\n        InvalidUnicodeHexSymbol,\n        InvalidUtf8Byte,\n        InvalidTopLevelTrailing,\n        InvalidControlCharacter,\n    }","src":253,"more_decls":null}}{"doc_comment":"A small wrapper over a StreamingParser for full slices. Returns a stream of json Tokens.","pl":"pub const TokenStream = struct ","src":1090,"more_decls":{"pl":"i: usize","src":1091,"more_decls":null}{"pl":"slice: []const u8","src":1092,"more_decls":null}{"pl":"parser: StreamingParser","src":1093,"more_decls":null}{"pl":"token: ?Token","src":1094,"more_decls":null}{"pl":"fn init(slice: []const u8) TokenStream","src":1098,"more_decls":null}{"pl":"fn next(self: *TokenStream) Error!?Token","src":1107,"more_decls":null}{"pl":"const Error = StreamingParser.Error || error{UnexpectedEndOfJson}","src":1096,"more_decls":null}}{"pl":"pub const ValueTree = struct ","src":1238,"more_decls":{"pl":"arena: ArenaAllocator","src":1239,"more_decls":null}{"pl":"root: Value","src":1240,"more_decls":null}{"pl":"pub fn deinit(self: *ValueTree) void {\n    self.arena.deinit();\n}","src":1242,"more_decls":null}}{"doc_comment":"Represents a JSON value\nCurrently only supports numbers that fit into i64 or f64.","pl":"pub const Value = union(enum) ","src":1252,"more_decls":{"pl":"Null","src":1253,"more_decls":null}{"pl":"Bool: bool","src":1254,"more_decls":null}{"pl":"Integer: i64","src":1255,"more_decls":null}{"pl":"Float: f64","src":1256,"more_decls":null}{"pl":"NumberString: []const u8","src":1257,"more_decls":null}{"pl":"String: []const u8","src":1258,"more_decls":null}{"pl":"Array: Array","src":1259,"more_decls":null}{"pl":"Object: ObjectMap","src":1260,"more_decls":null}{"pl":"fn jsonStringify(\n    value: @This(),\n    options: StringifyOptions,\n    out_stream: anytype,\n) @TypeOf(out_stream).Error!void","src":1262,"more_decls":null}{"pl":"fn dump(self: Value) void","src":1314,"more_decls":null}}{"pl":"pub const ParseOptions = struct ","src":1443,"more_decls":{"pl":"allocator: ?*Allocator = null","src":1444,"more_decls":null}{"doc_comment":"Behaviour when a duplicate field is encountered.","pl":"duplicate_field_behavior: enum {\n        UseFirst,\n        Error,\n        UseLast,\n    } = .Error","src":1447,"more_decls":null}}{"doc_comment":"A non-stream JSON parser which constructs a tree of Value's.","pl":"pub const Parser = struct ","src":1991,"more_decls":{"pl":"allocator: *Allocator","src":1992,"more_decls":null}{"pl":"state: State","src":1993,"more_decls":null}{"pl":"copy_strings: bool","src":1994,"more_decls":null}{"pl":"stack: Array","src":1996,"more_decls":null}{"pl":"fn init(allocator: *Allocator, copy_strings: bool) Parser","src":2005,"more_decls":null}{"pl":"pub fn deinit(p: *Parser) void {\n    p.stack.deinit();\n}","src":2014,"more_decls":null}{"pl":"pub fn reset(p: *Parser) void {\n    p.state = .Simple;\n    p.stack.shrinkRetainingCapacity(0);\n}","src":2018,"more_decls":null}{"pl":"fn parse(p: *Parser, input: []const u8) !ValueTree","src":2023,"more_decls":null}}{"pl":"pub const StringifyOptions = struct ","src":2489,"more_decls":{"doc_comment":"Controls the whitespace emitted","pl":"whitespace: ?Whitespace = null","src":2525,"more_decls":null}{"pl":"string: StringOptions = StringOptions{ .String = .{} }","src":2527,"more_decls":null}{"pl":"pub const Whitespace = struct ","src":2490,"more_decls":{"doc_comment":"How many indentation levels deep are we?","pl":"indent_level: usize = 0","src":2492,"more_decls":null}{"doc_comment":"What character(s) should be used for indentation?","pl":"indent: union(enum) {\n            Space: u8,\n            Tab: void,\n        } = .{ .Space = 4 }","src":2495,"more_decls":null}{"doc_comment":"After a colon, should whitespace be inserted?","pl":"separator: bool = true","src":2501,"more_decls":null}{"pl":"fn outputIndent(\n    whitespace: @This(),\n    out_stream: anytype,\n) @TypeOf(out_stream).Error!void","src":2503,"more_decls":null}}{"doc_comment":"Should []u8 be serialised as a string? or an array?","pl":"pub const StringOptions = union(enum) ","src":2530,"more_decls":{"pl":"Array","src":2531,"more_decls":null}{"pl":"String: StringOutputOptions","src":2532,"more_decls":null}}}{"doc_comment":"Validate a JSON string. This does not limit number precision so a decoder may not necessarily\nbe able to decode the string even if this returns true.","pl":"fn validate(s: []const u8) bool","src":1209,"more_decls":null}{"pl":"pub fn parse(comptime T: type, tokens: *TokenStream, options: ParseOptions) !T {\n    const token = (try tokens.next()) orelse return error.UnexpectedEndOfJson;\n    return parseInternal(T, token, tokens, options);\n}","src":1695,"more_decls":null}{"doc_comment":"Releases resources created by `parse`.\nShould be called with the same type and `ParseOptions` that were passed to `parse`","pl":"fn parseFree(comptime T: type, value: T, options: ParseOptions) void","src":1702,"more_decls":null}{"doc_comment":"Unescape a JSON string\nOnly to be used on strings already validated by the parser\n(note the unreachable statements and lack of bounds checking)","pl":"fn unescapeValidString(output: []u8, input: []const u8) !void","src":2229,"more_decls":null}{"pl":"fn stringify(\n    value: anytype,\n    options: StringifyOptions,\n    out_stream: anytype,\n) @TypeOf(out_stream).Error!void","src":2568,"more_decls":null}{"pl":"const WriteStream = @import(\"json/write_stream.zig\").WriteStream","src":16,"more_decls":null}{"pl":"const writeStream = @import(\"json/write_stream.zig\").writeStream","src":17,"more_decls":null}{"pl":"const ObjectMap = StringHashMap(Value)","src":1247,"more_decls":null}{"pl":"const Array = ArrayList(Value)","src":1248,"more_decls":null}]