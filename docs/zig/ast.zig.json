[{"pl":"pub const Tree = struct ","src":20,"more_decls":{"doc_comment":"Reference to externally-owned data.","pl":"source: []const u8","src":22,"more_decls":null}{"pl":"tokens: TokenList.Slice","src":24,"more_decls":null}{"doc_comment":"The root AST node is assumed to be index 0. Since there can be no\nreferences to the root node, this means 0 is available to indicate null.","pl":"nodes: NodeList.Slice","src":27,"more_decls":null}{"pl":"extra_data: []Node.Index","src":28,"more_decls":null}{"pl":"errors: []const Error","src":30,"more_decls":null}{"pl":"pub const Location = struct ","src":32,"more_decls":{"pl":"line: usize","src":33,"more_decls":null}{"pl":"column: usize","src":34,"more_decls":null}{"pl":"line_start: usize","src":35,"more_decls":null}{"pl":"line_end: usize","src":36,"more_decls":null}}{"pl":"fn deinit(tree: *Tree, gpa: *mem.Allocator) void","src":39,"more_decls":null}{"doc_comment":"`gpa` is used for allocating the resulting formatted source code, as well as\nfor allocating extra stack memory if needed, because this function utilizes recursion.\nNote: that's not actually true yet, see https://github.com/ziglang/zig/issues/1006.\nCaller owns the returned slice of bytes, allocated with `gpa`.","pl":"fn render(tree: Tree, gpa: *mem.Allocator) RenderError![]u8","src":57,"more_decls":null}{"pl":"pub fn renderToArrayList(tree: Tree, buffer: *std.ArrayList(u8)) RenderError!void {\n    return @import(\"./render.zig\").renderTree(buffer, tree);\n}","src":65,"more_decls":null}{"pl":"fn tokenLocation(self: Tree, start_offset: ByteOffset, token_index: TokenIndex) Location","src":69,"more_decls":null}{"pl":"fn tokenSlice(tree: Tree, token_index: TokenIndex) []const u8","src":96,"more_decls":null}{"pl":"fn extraData(tree: Tree, index: usize, comptime T: type) T","src":117,"more_decls":null}{"pl":"pub fn rootDecls(tree: Tree) []const Node.Index {\n    // Root is always index 0.\n    const nodes_data = tree.nodes.items(.data);\n    return tree.extra_data[nodes_data[0].lhs..nodes_data[0].rhs];\n}","src":127,"more_decls":null}{"pl":"fn renderError(tree: Tree, parse_error: Error, stream: anytype) !void","src":133,"more_decls":null}{"pl":"fn firstToken(tree: Tree, node: Node.Index) TokenIndex","src":315,"more_decls":null}{"pl":"fn lastToken(tree: Tree, node: Node.Index) TokenIndex","src":614,"more_decls":null}{"pl":"pub fn tokensOnSameLine(tree: Tree, token1: TokenIndex, token2: TokenIndex) bool {\n    const token_starts = tree.tokens.items(.start);\n    const source = tree.source[token_starts[token1]..token_starts[token2]];\n    return mem.indexOfScalar(u8, source, '\\n') == null;\n}","src":1126,"more_decls":null}{"pl":"fn getNodeSource(tree: Tree, node: Node.Index) []const u8","src":1132,"more_decls":null}{"pl":"fn globalVarDecl(tree: Tree, node: Node.Index) full.VarDecl","src":1141,"more_decls":null}{"pl":"fn localVarDecl(tree: Tree, node: Node.Index) full.VarDecl","src":1154,"more_decls":null}{"pl":"fn simpleVarDecl(tree: Tree, node: Node.Index) full.VarDecl","src":1167,"more_decls":null}{"pl":"fn alignedVarDecl(tree: Tree, node: Node.Index) full.VarDecl","src":1179,"more_decls":null}{"pl":"fn ifSimple(tree: Tree, node: Node.Index) full.If","src":1191,"more_decls":null}{"pl":"fn ifFull(tree: Tree, node: Node.Index) full.If","src":1202,"more_decls":null}{"pl":"fn containerField(tree: Tree, node: Node.Index) full.ContainerField","src":1214,"more_decls":null}{"pl":"fn containerFieldInit(tree: Tree, node: Node.Index) full.ContainerField","src":1226,"more_decls":null}{"pl":"fn containerFieldAlign(tree: Tree, node: Node.Index) full.ContainerField","src":1237,"more_decls":null}{"pl":"fn fnProtoSimple(tree: Tree, buffer: *[1]Node.Index, node: Node.Index) full.FnProto","src":1248,"more_decls":null}{"pl":"fn fnProtoMulti(tree: Tree, node: Node.Index) full.FnProto","src":1264,"more_decls":null}{"pl":"fn fnProtoOne(tree: Tree, buffer: *[1]Node.Index, node: Node.Index) full.FnProto","src":1280,"more_decls":null}{"pl":"fn fnProto(tree: Tree, node: Node.Index) full.FnProto","src":1297,"more_decls":null}{"pl":"fn structInitOne(tree: Tree, buffer: *[1]Node.Index, node: Node.Index) full.StructInit","src":1313,"more_decls":null}{"pl":"fn structInitDotTwo(tree: Tree, buffer: *[2]Node.Index, node: Node.Index) full.StructInit","src":1326,"more_decls":null}{"pl":"fn structInitDot(tree: Tree, node: Node.Index) full.StructInit","src":1344,"more_decls":null}{"pl":"fn structInit(tree: Tree, node: Node.Index) full.StructInit","src":1355,"more_decls":null}{"pl":"fn arrayInitOne(tree: Tree, buffer: *[1]Node.Index, node: Node.Index) full.ArrayInit","src":1367,"more_decls":null}{"pl":"fn arrayInitDotTwo(tree: Tree, buffer: *[2]Node.Index, node: Node.Index) full.ArrayInit","src":1382,"more_decls":null}{"pl":"fn arrayInitDot(tree: Tree, node: Node.Index) full.ArrayInit","src":1402,"more_decls":null}{"pl":"fn arrayInit(tree: Tree, node: Node.Index) full.ArrayInit","src":1415,"more_decls":null}{"pl":"fn arrayType(tree: Tree, node: Node.Index) full.ArrayType","src":1429,"more_decls":null}{"pl":"fn arrayTypeSentinel(tree: Tree, node: Node.Index) full.ArrayType","src":1442,"more_decls":null}{"pl":"fn ptrTypeAligned(tree: Tree, node: Node.Index) full.PtrType","src":1457,"more_decls":null}{"pl":"fn ptrTypeSentinel(tree: Tree, node: Node.Index) full.PtrType","src":1470,"more_decls":null}{"pl":"fn ptrType(tree: Tree, node: Node.Index) full.PtrType","src":1483,"more_decls":null}{"pl":"fn ptrTypeBitRange(tree: Tree, node: Node.Index) full.PtrType","src":1497,"more_decls":null}{"pl":"fn sliceOpen(tree: Tree, node: Node.Index) full.Slice","src":1511,"more_decls":null}{"pl":"fn slice(tree: Tree, node: Node.Index) full.Slice","src":1525,"more_decls":null}{"pl":"fn sliceSentinel(tree: Tree, node: Node.Index) full.Slice","src":1540,"more_decls":null}{"pl":"fn containerDeclTwo(tree: Tree, buffer: *[2]Node.Index, node: Node.Index) full.ContainerDecl","src":1555,"more_decls":null}{"pl":"fn containerDecl(tree: Tree, node: Node.Index) full.ContainerDecl","src":1574,"more_decls":null}{"pl":"fn containerDeclArg(tree: Tree, node: Node.Index) full.ContainerDecl","src":1586,"more_decls":null}{"pl":"fn taggedUnionTwo(tree: Tree, buffer: *[2]Node.Index, node: Node.Index) full.ContainerDecl","src":1599,"more_decls":null}{"pl":"fn taggedUnion(tree: Tree, node: Node.Index) full.ContainerDecl","src":1619,"more_decls":null}{"pl":"fn taggedUnionEnumTag(tree: Tree, node: Node.Index) full.ContainerDecl","src":1632,"more_decls":null}{"pl":"fn switchCaseOne(tree: Tree, node: Node.Index) full.SwitchCase","src":1646,"more_decls":null}{"pl":"fn switchCase(tree: Tree, node: Node.Index) full.SwitchCase","src":1656,"more_decls":null}{"pl":"fn asmSimple(tree: Tree, node: Node.Index) full.Asm","src":1666,"more_decls":null}{"pl":"fn asmFull(tree: Tree, node: Node.Index) full.Asm","src":1676,"more_decls":null}{"pl":"fn whileSimple(tree: Tree, node: Node.Index) full.While","src":1687,"more_decls":null}{"pl":"fn whileCont(tree: Tree, node: Node.Index) full.While","src":1698,"more_decls":null}{"pl":"fn whileFull(tree: Tree, node: Node.Index) full.While","src":1710,"more_decls":null}{"pl":"fn forSimple(tree: Tree, node: Node.Index) full.While","src":1722,"more_decls":null}{"pl":"fn forFull(tree: Tree, node: Node.Index) full.While","src":1733,"more_decls":null}{"pl":"fn callOne(tree: Tree, buffer: *[1]Node.Index, node: Node.Index) full.Call","src":1745,"more_decls":null}{"pl":"fn callFull(tree: Tree, node: Node.Index) full.Call","src":1756,"more_decls":null}{"pl":"const RenderError = error{\n        /// Ran out of memory allocating call stack frames to complete rendering, or\n        /// ran out of memory allocating space in the output buffer.\n        OutOfMemory,\n    }","src":47,"more_decls":null}}{"doc_comment":"Fully assembled AST node information.","pl":"pub const full = struct ","src":2051,"more_decls":{"pl":"pub const VarDecl = struct ","src":2052,"more_decls":{"pl":"visib_token: ?TokenIndex","src":2053,"more_decls":null}{"pl":"extern_export_token: ?TokenIndex","src":2054,"more_decls":null}{"pl":"lib_name: ?TokenIndex","src":2055,"more_decls":null}{"pl":"threadlocal_token: ?TokenIndex","src":2056,"more_decls":null}{"pl":"comptime_token: ?TokenIndex","src":2057,"more_decls":null}{"pl":"ast: Ast","src":2058,"more_decls":null}{"pl":"pub const Ast = struct ","src":2060,"more_decls":{"pl":"mut_token: TokenIndex","src":2061,"more_decls":null}{"pl":"type_node: Node.Index","src":2062,"more_decls":null}{"pl":"align_node: Node.Index","src":2063,"more_decls":null}{"pl":"section_node: Node.Index","src":2064,"more_decls":null}{"pl":"init_node: Node.Index","src":2065,"more_decls":null}}}{"pl":"pub const If = struct ","src":2069,"more_decls":{"doc_comment":"Points to the first token after the `|`. Will either be an identifier or\na `*` (with an identifier immediately after it).","pl":"payload_token: ?TokenIndex","src":2072,"more_decls":null}{"doc_comment":"Points to the identifier after the `|`.","pl":"error_token: ?TokenIndex","src":2074,"more_decls":null}{"doc_comment":"Populated only if else_expr != 0.","pl":"else_token: TokenIndex","src":2076,"more_decls":null}{"pl":"ast: Ast","src":2077,"more_decls":null}{"pl":"pub const Ast = struct ","src":2079,"more_decls":{"pl":"if_token: TokenIndex","src":2080,"more_decls":null}{"pl":"cond_expr: Node.Index","src":2081,"more_decls":null}{"pl":"then_expr: Node.Index","src":2082,"more_decls":null}{"pl":"else_expr: Node.Index","src":2083,"more_decls":null}}}{"pl":"pub const While = struct ","src":2087,"more_decls":{"pl":"ast: Ast","src":2088,"more_decls":null}{"pl":"inline_token: ?TokenIndex","src":2089,"more_decls":null}{"pl":"label_token: ?TokenIndex","src":2090,"more_decls":null}{"pl":"payload_token: ?TokenIndex","src":2091,"more_decls":null}{"pl":"error_token: ?TokenIndex","src":2092,"more_decls":null}{"doc_comment":"Populated only if else_expr != 0.","pl":"else_token: TokenIndex","src":2094,"more_decls":null}{"pl":"pub const Ast = struct ","src":2096,"more_decls":{"pl":"while_token: TokenIndex","src":2097,"more_decls":null}{"pl":"cond_expr: Node.Index","src":2098,"more_decls":null}{"pl":"cont_expr: Node.Index","src":2099,"more_decls":null}{"pl":"then_expr: Node.Index","src":2100,"more_decls":null}{"pl":"else_expr: Node.Index","src":2101,"more_decls":null}}}{"pl":"pub const ContainerField = struct ","src":2105,"more_decls":{"pl":"comptime_token: ?TokenIndex","src":2106,"more_decls":null}{"pl":"ast: Ast","src":2107,"more_decls":null}{"pl":"pub const Ast = struct ","src":2109,"more_decls":{"pl":"name_token: TokenIndex","src":2110,"more_decls":null}{"pl":"type_expr: Node.Index","src":2111,"more_decls":null}{"pl":"value_expr: Node.Index","src":2112,"more_decls":null}{"pl":"align_expr: Node.Index","src":2113,"more_decls":null}}}{"pl":"pub const FnProto = struct ","src":2117,"more_decls":{"pl":"visib_token: ?TokenIndex","src":2118,"more_decls":null}{"pl":"extern_export_token: ?TokenIndex","src":2119,"more_decls":null}{"pl":"lib_name: ?TokenIndex","src":2120,"more_decls":null}{"pl":"name_token: ?TokenIndex","src":2121,"more_decls":null}{"pl":"lparen: TokenIndex","src":2122,"more_decls":null}{"pl":"ast: Ast","src":2123,"more_decls":null}{"pl":"pub const Ast = struct ","src":2125,"more_decls":{"pl":"proto_node: Node.Index","src":2126,"more_decls":null}{"pl":"fn_token: TokenIndex","src":2127,"more_decls":null}{"pl":"return_type: Node.Index","src":2128,"more_decls":null}{"pl":"params: []const Node.Index","src":2129,"more_decls":null}{"pl":"align_expr: Node.Index","src":2130,"more_decls":null}{"pl":"section_expr: Node.Index","src":2131,"more_decls":null}{"pl":"callconv_expr: Node.Index","src":2132,"more_decls":null}}{"pl":"pub const Param = struct ","src":2135,"more_decls":{"pl":"first_doc_comment: ?TokenIndex","src":2136,"more_decls":null}{"pl":"name_token: ?TokenIndex","src":2137,"more_decls":null}{"pl":"comptime_noalias: ?TokenIndex","src":2138,"more_decls":null}{"pl":"anytype_ellipsis3: ?TokenIndex","src":2139,"more_decls":null}{"pl":"type_expr: Node.Index","src":2140,"more_decls":null}}{"doc_comment":"Abstracts over the fact that anytype and ... are not included\nin the params slice, since they are simple identifiers and\nnot sub-expressions.","pl":"pub const Iterator = struct ","src":2146,"more_decls":{"pl":"tree: *const Tree","src":2147,"more_decls":null}{"pl":"fn_proto: *const FnProto","src":2148,"more_decls":null}{"pl":"param_i: usize","src":2149,"more_decls":null}{"pl":"tok_i: TokenIndex","src":2150,"more_decls":null}{"pl":"tok_flag: bool","src":2151,"more_decls":null}{"pl":"fn next(it: *Iterator) ?Param","src":2153,"more_decls":null}}{"pl":"fn iterate(fn_proto: FnProto, tree: Tree) Iterator","src":2233,"more_decls":null}}{"pl":"pub const StructInit = struct ","src":2244,"more_decls":{"pl":"ast: Ast","src":2245,"more_decls":null}{"pl":"pub const Ast = struct ","src":2247,"more_decls":{"pl":"lbrace: TokenIndex","src":2248,"more_decls":null}{"pl":"fields: []const Node.Index","src":2249,"more_decls":null}{"pl":"type_expr: Node.Index","src":2250,"more_decls":null}}}{"pl":"pub const ArrayInit = struct ","src":2254,"more_decls":{"pl":"ast: Ast","src":2255,"more_decls":null}{"pl":"pub const Ast = struct ","src":2257,"more_decls":{"pl":"lbrace: TokenIndex","src":2258,"more_decls":null}{"pl":"elements: []const Node.Index","src":2259,"more_decls":null}{"pl":"type_expr: Node.Index","src":2260,"more_decls":null}}}{"pl":"pub const ArrayType = struct ","src":2264,"more_decls":{"pl":"ast: Ast","src":2265,"more_decls":null}{"pl":"pub const Ast = struct ","src":2267,"more_decls":{"pl":"lbracket: TokenIndex","src":2268,"more_decls":null}{"pl":"elem_count: Node.Index","src":2269,"more_decls":null}{"pl":"sentinel: Node.Index","src":2270,"more_decls":null}{"pl":"elem_type: Node.Index","src":2271,"more_decls":null}}}{"pl":"pub const PtrType = struct ","src":2275,"more_decls":{"pl":"size: std.builtin.TypeInfo.Pointer.Size","src":2276,"more_decls":null}{"pl":"allowzero_token: ?TokenIndex","src":2277,"more_decls":null}{"pl":"const_token: ?TokenIndex","src":2278,"more_decls":null}{"pl":"volatile_token: ?TokenIndex","src":2279,"more_decls":null}{"pl":"ast: Ast","src":2280,"more_decls":null}{"pl":"pub const Ast = struct ","src":2282,"more_decls":{"pl":"main_token: TokenIndex","src":2283,"more_decls":null}{"pl":"align_node: Node.Index","src":2284,"more_decls":null}{"pl":"sentinel: Node.Index","src":2285,"more_decls":null}{"pl":"bit_range_start: Node.Index","src":2286,"more_decls":null}{"pl":"bit_range_end: Node.Index","src":2287,"more_decls":null}{"pl":"child_type: Node.Index","src":2288,"more_decls":null}}}{"pl":"pub const Slice = struct ","src":2292,"more_decls":{"pl":"ast: Ast","src":2293,"more_decls":null}{"pl":"pub const Ast = struct ","src":2295,"more_decls":{"pl":"sliced: Node.Index","src":2296,"more_decls":null}{"pl":"lbracket: TokenIndex","src":2297,"more_decls":null}{"pl":"start: Node.Index","src":2298,"more_decls":null}{"pl":"end: Node.Index","src":2299,"more_decls":null}{"pl":"sentinel: Node.Index","src":2300,"more_decls":null}}}{"pl":"pub const ContainerDecl = struct ","src":2304,"more_decls":{"pl":"layout_token: ?TokenIndex","src":2305,"more_decls":null}{"pl":"ast: Ast","src":2306,"more_decls":null}{"pl":"pub const Ast = struct ","src":2308,"more_decls":{"pl":"main_token: TokenIndex","src":2309,"more_decls":null}{"doc_comment":"Populated when main_token is Keyword_union.","pl":"enum_token: ?TokenIndex","src":2311,"more_decls":null}{"pl":"members: []const Node.Index","src":2312,"more_decls":null}{"pl":"arg: Node.Index","src":2313,"more_decls":null}}}{"pl":"pub const SwitchCase = struct ","src":2317,"more_decls":{"doc_comment":"Points to the first token after the `|`. Will either be an identifier or\na `*` (with an identifier immediately after it).","pl":"payload_token: ?TokenIndex","src":2320,"more_decls":null}{"pl":"ast: Ast","src":2321,"more_decls":null}{"pl":"pub const Ast = struct ","src":2323,"more_decls":{"doc_comment":"If empty, this is an else case","pl":"values: []const Node.Index","src":2325,"more_decls":null}{"pl":"arrow_token: TokenIndex","src":2326,"more_decls":null}{"pl":"target_expr: Node.Index","src":2327,"more_decls":null}}}{"pl":"pub const Asm = struct ","src":2331,"more_decls":{"pl":"ast: Ast","src":2332,"more_decls":null}{"pl":"volatile_token: ?TokenIndex","src":2333,"more_decls":null}{"pl":"first_clobber: ?TokenIndex","src":2334,"more_decls":null}{"pl":"outputs: []const Node.Index","src":2335,"more_decls":null}{"pl":"inputs: []const Node.Index","src":2336,"more_decls":null}{"pl":"pub const Ast = struct ","src":2338,"more_decls":{"pl":"asm_token: TokenIndex","src":2339,"more_decls":null}{"pl":"template: Node.Index","src":2340,"more_decls":null}{"pl":"items: []const Node.Index","src":2341,"more_decls":null}{"pl":"rparen: TokenIndex","src":2342,"more_decls":null}}}{"pl":"pub const Call = struct ","src":2346,"more_decls":{"pl":"ast: Ast","src":2347,"more_decls":null}{"pl":"async_token: ?TokenIndex","src":2348,"more_decls":null}{"pl":"pub const Ast = struct ","src":2350,"more_decls":{"pl":"lparen: TokenIndex","src":2351,"more_decls":null}{"pl":"fn_expr: Node.Index","src":2352,"more_decls":null}{"pl":"params: []const Node.Index","src":2353,"more_decls":null}}}}{"pl":"pub const Error = struct ","src":2358,"more_decls":{"pl":"tag: Tag","src":2359,"more_decls":null}{"pl":"token: TokenIndex","src":2360,"more_decls":null}{"pl":"extra: union {\n        none: void,\n        expected_tag: Token.Tag,\n    } = .{ .none = {} }","src":2361,"more_decls":null}{"pl":"pub const Tag = enum ","src":2366,"more_decls":{"pl":"asterisk_after_ptr_deref","src":2367,"more_decls":null}{"pl":"decl_between_fields","src":2368,"more_decls":null}{"pl":"expected_block","src":2369,"more_decls":null}{"pl":"expected_block_or_assignment","src":2370,"more_decls":null}{"pl":"expected_block_or_expr","src":2371,"more_decls":null}{"pl":"expected_block_or_field","src":2372,"more_decls":null}{"pl":"expected_container_members","src":2373,"more_decls":null}{"pl":"expected_expr","src":2374,"more_decls":null}{"pl":"expected_expr_or_assignment","src":2375,"more_decls":null}{"pl":"expected_fn","src":2376,"more_decls":null}{"pl":"expected_inlinable","src":2377,"more_decls":null}{"pl":"expected_labelable","src":2378,"more_decls":null}{"pl":"expected_param_list","src":2379,"more_decls":null}{"pl":"expected_prefix_expr","src":2380,"more_decls":null}{"pl":"expected_primary_type_expr","src":2381,"more_decls":null}{"pl":"expected_pub_item","src":2382,"more_decls":null}{"pl":"expected_return_type","src":2383,"more_decls":null}{"pl":"expected_semi_or_else","src":2384,"more_decls":null}{"pl":"expected_semi_or_lbrace","src":2385,"more_decls":null}{"pl":"expected_statement","src":2386,"more_decls":null}{"pl":"expected_string_literal","src":2387,"more_decls":null}{"pl":"expected_suffix_op","src":2388,"more_decls":null}{"pl":"expected_type_expr","src":2389,"more_decls":null}{"pl":"expected_var_decl","src":2390,"more_decls":null}{"pl":"expected_var_decl_or_fn","src":2391,"more_decls":null}{"pl":"expected_loop_payload","src":2392,"more_decls":null}{"pl":"expected_container","src":2393,"more_decls":null}{"pl":"extra_align_qualifier","src":2394,"more_decls":null}{"pl":"extra_allowzero_qualifier","src":2395,"more_decls":null}{"pl":"extra_const_qualifier","src":2396,"more_decls":null}{"pl":"extra_volatile_qualifier","src":2397,"more_decls":null}{"pl":"ptr_mod_on_array_child_type","src":2398,"more_decls":null}{"pl":"invalid_and","src":2399,"more_decls":null}{"pl":"invalid_bit_range","src":2400,"more_decls":null}{"pl":"invalid_token","src":2401,"more_decls":null}{"pl":"same_line_doc_comment","src":2402,"more_decls":null}{"pl":"unattached_doc_comment","src":2403,"more_decls":null}{"doc_comment":"`expected_tag` is populated.","pl":"expected_token","src":2406,"more_decls":null}}}{"pl":"pub const Node = struct ","src":2410,"more_decls":{"pl":"tag: Tag","src":2411,"more_decls":null}{"pl":"main_token: TokenIndex","src":2412,"more_decls":null}{"pl":"data: Data","src":2413,"more_decls":null}{"doc_comment":"Note: The FooComma/FooSemicolon variants exist to ease the implementation of\nTree.lastToken()","pl":"pub const Tag = enum ","src":2424,"more_decls":{"doc_comment":"sub_list[lhs...rhs]","pl":"root","src":2426,"more_decls":null}{"doc_comment":"`usingnamespace lhs;`. rhs unused. main_token is `usingnamespace`.","pl":"@\"usingnamespace\"","src":2428,"more_decls":null}{"doc_comment":"lhs is test name token (must be string literal), if any.\nrhs is the body node.","pl":"test_decl","src":2431,"more_decls":null}{"doc_comment":"lhs is the index into extra_data.\nrhs is the initialization expression, if any.\nmain_token is `var` or `const`.","pl":"global_var_decl","src":2435,"more_decls":null}{"doc_comment":"`var a: x align(y) = rhs`\nlhs is the index into extra_data.\nmain_token is `var` or `const`.","pl":"local_var_decl","src":2439,"more_decls":null}{"doc_comment":"`var a: lhs = rhs`. lhs and rhs may be unused.\nCan be local or global.\nmain_token is `var` or `const`.","pl":"simple_var_decl","src":2443,"more_decls":null}{"doc_comment":"`var a align(lhs) = rhs`. lhs and rhs may be unused.\nCan be local or global.\nmain_token is `var` or `const`.","pl":"aligned_var_decl","src":2447,"more_decls":null}{"doc_comment":"lhs is the identifier token payload if any,\nrhs is the deferred expression.","pl":"@\"errdefer\"","src":2450,"more_decls":null}{"doc_comment":"lhs is unused.\nrhs is the deferred expression.","pl":"@\"defer\"","src":2453,"more_decls":null}{"doc_comment":"lhs catch rhs\nlhs catch |err| rhs\nmain_token is the `catch` keyword.\npayload is determined by looking at the next token after the `catch` keyword.","pl":"@\"catch\"","src":2458,"more_decls":null}{"doc_comment":"`lhs.a`. main_token is the dot. rhs is the identifier token index.","pl":"field_access","src":2460,"more_decls":null}{"doc_comment":"`lhs.?`. main_token is the dot. rhs is the `?` token index.","pl":"unwrap_optional","src":2462,"more_decls":null}{"doc_comment":"`lhs == rhs`. main_token is op.","pl":"equal_equal","src":2464,"more_decls":null}{"doc_comment":"`lhs != rhs`. main_token is op.","pl":"bang_equal","src":2466,"more_decls":null}{"doc_comment":"`lhs < rhs`. main_token is op.","pl":"less_than","src":2468,"more_decls":null}{"doc_comment":"`lhs > rhs`. main_token is op.","pl":"greater_than","src":2470,"more_decls":null}{"doc_comment":"`lhs <= rhs`. main_token is op.","pl":"less_or_equal","src":2472,"more_decls":null}{"doc_comment":"`lhs >= rhs`. main_token is op.","pl":"greater_or_equal","src":2474,"more_decls":null}{"doc_comment":"`lhs *= rhs`. main_token is op.","pl":"assign_mul","src":2476,"more_decls":null}{"doc_comment":"`lhs /= rhs`. main_token is op.","pl":"assign_div","src":2478,"more_decls":null}{"doc_comment":"`lhs *= rhs`. main_token is op.","pl":"assign_mod","src":2480,"more_decls":null}{"doc_comment":"`lhs += rhs`. main_token is op.","pl":"assign_add","src":2482,"more_decls":null}{"doc_comment":"`lhs -= rhs`. main_token is op.","pl":"assign_sub","src":2484,"more_decls":null}{"doc_comment":"`lhs <<= rhs`. main_token is op.","pl":"assign_bit_shift_left","src":2486,"more_decls":null}{"doc_comment":"`lhs >>= rhs`. main_token is op.","pl":"assign_bit_shift_right","src":2488,"more_decls":null}{"doc_comment":"`lhs &= rhs`. main_token is op.","pl":"assign_bit_and","src":2490,"more_decls":null}{"doc_comment":"`lhs ^= rhs`. main_token is op.","pl":"assign_bit_xor","src":2492,"more_decls":null}{"doc_comment":"`lhs |= rhs`. main_token is op.","pl":"assign_bit_or","src":2494,"more_decls":null}{"doc_comment":"`lhs *%= rhs`. main_token is op.","pl":"assign_mul_wrap","src":2496,"more_decls":null}{"doc_comment":"`lhs +%= rhs`. main_token is op.","pl":"assign_add_wrap","src":2498,"more_decls":null}{"doc_comment":"`lhs -%= rhs`. main_token is op.","pl":"assign_sub_wrap","src":2500,"more_decls":null}{"doc_comment":"`lhs = rhs`. main_token is op.","pl":"assign","src":2502,"more_decls":null}{"doc_comment":"`lhs || rhs`. main_token is the `||`.","pl":"merge_error_sets","src":2504,"more_decls":null}{"doc_comment":"`lhs * rhs`. main_token is the `*`.","pl":"mul","src":2506,"more_decls":null}{"doc_comment":"`lhs / rhs`. main_token is the `/`.","pl":"div","src":2508,"more_decls":null}{"doc_comment":"`lhs % rhs`. main_token is the `%`.","pl":"mod","src":2510,"more_decls":null}{"doc_comment":"`lhs ** rhs`. main_token is the `**`.","pl":"array_mult","src":2512,"more_decls":null}{"doc_comment":"`lhs *% rhs`. main_token is the `*%`.","pl":"mul_wrap","src":2514,"more_decls":null}{"doc_comment":"`lhs + rhs`. main_token is the `+`.","pl":"add","src":2516,"more_decls":null}{"doc_comment":"`lhs - rhs`. main_token is the `-`.","pl":"sub","src":2518,"more_decls":null}{"doc_comment":"`lhs ++ rhs`. main_token is the `++`.","pl":"array_cat","src":2520,"more_decls":null}{"doc_comment":"`lhs +% rhs`. main_token is the `+%`.","pl":"add_wrap","src":2522,"more_decls":null}{"doc_comment":"`lhs -% rhs`. main_token is the `-%`.","pl":"sub_wrap","src":2524,"more_decls":null}{"doc_comment":"`lhs << rhs`. main_token is the `<<`.","pl":"bit_shift_left","src":2526,"more_decls":null}{"doc_comment":"`lhs >> rhs`. main_token is the `>>`.","pl":"bit_shift_right","src":2528,"more_decls":null}{"doc_comment":"`lhs & rhs`. main_token is the `&`.","pl":"bit_and","src":2530,"more_decls":null}{"doc_comment":"`lhs ^ rhs`. main_token is the `^`.","pl":"bit_xor","src":2532,"more_decls":null}{"doc_comment":"`lhs | rhs`. main_token is the `|`.","pl":"bit_or","src":2534,"more_decls":null}{"doc_comment":"`lhs orelse rhs`. main_token is the `orelse`.","pl":"@\"orelse\"","src":2536,"more_decls":null}{"doc_comment":"`lhs and rhs`. main_token is the `and`.","pl":"bool_and","src":2538,"more_decls":null}{"doc_comment":"`lhs or rhs`. main_token is the `or`.","pl":"bool_or","src":2540,"more_decls":null}{"doc_comment":"`op lhs`. rhs unused. main_token is op.","pl":"bool_not","src":2542,"more_decls":null}{"doc_comment":"`op lhs`. rhs unused. main_token is op.","pl":"negation","src":2544,"more_decls":null}{"doc_comment":"`op lhs`. rhs unused. main_token is op.","pl":"bit_not","src":2546,"more_decls":null}{"doc_comment":"`op lhs`. rhs unused. main_token is op.","pl":"negation_wrap","src":2548,"more_decls":null}{"doc_comment":"`op lhs`. rhs unused. main_token is op.","pl":"address_of","src":2550,"more_decls":null}{"doc_comment":"`op lhs`. rhs unused. main_token is op.","pl":"@\"try\"","src":2552,"more_decls":null}{"doc_comment":"`op lhs`. rhs unused. main_token is op.","pl":"@\"await\"","src":2554,"more_decls":null}{"doc_comment":"`?lhs`. rhs unused. main_token is the `?`.","pl":"optional_type","src":2556,"more_decls":null}{"doc_comment":"`[lhs]rhs`.","pl":"array_type","src":2558,"more_decls":null}{"doc_comment":"`[lhs:a]b`. `ArrayTypeSentinel[rhs]`.","pl":"array_type_sentinel","src":2560,"more_decls":null}{"doc_comment":"`[*]align(lhs) rhs`. lhs can be omitted.\n`*align(lhs) rhs`. lhs can be omitted.\n`[]rhs`.\nmain_token is the asterisk if a pointer or the lbracket if a slice\nmain_token might be a ** token, which is shared with a parent/child\npointer type and may require special handling.","pl":"ptr_type_aligned","src":2567,"more_decls":null}{"doc_comment":"`[*:lhs]rhs`. lhs can be omitted.\n`*rhs`.\n`[:lhs]rhs`.\nmain_token is the asterisk if a pointer or the lbracket if a slice\nmain_token might be a ** token, which is shared with a parent/child\npointer type and may require special handling.","pl":"ptr_type_sentinel","src":2574,"more_decls":null}{"doc_comment":"lhs is index into ptr_type. rhs is the element type expression.\nmain_token is the asterisk if a pointer or the lbracket if a slice\nmain_token might be a ** token, which is shared with a parent/child\npointer type and may require special handling.","pl":"ptr_type","src":2579,"more_decls":null}{"doc_comment":"lhs is index into ptr_type_bit_range. rhs is the element type expression.\nmain_token is the asterisk if a pointer or the lbracket if a slice\nmain_token might be a ** token, which is shared with a parent/child\npointer type and may require special handling.","pl":"ptr_type_bit_range","src":2584,"more_decls":null}{"doc_comment":"`lhs[rhs..]`\nmain_token is the lbracket.","pl":"slice_open","src":2587,"more_decls":null}{"doc_comment":"`lhs[b..c]`. rhs is index into Slice\nmain_token is the lbracket.","pl":"slice","src":2590,"more_decls":null}{"doc_comment":"`lhs[b..c :d]`. rhs is index into SliceSentinel\nmain_token is the lbracket.","pl":"slice_sentinel","src":2593,"more_decls":null}{"doc_comment":"`lhs.*`. rhs is unused.","pl":"deref","src":2595,"more_decls":null}{"doc_comment":"`lhs[rhs]`.","pl":"array_access","src":2597,"more_decls":null}{"doc_comment":"`lhs{rhs}`. rhs can be omitted.","pl":"array_init_one","src":2599,"more_decls":null}{"doc_comment":"`lhs{rhs,}`. rhs can *not* be omitted","pl":"array_init_one_comma","src":2601,"more_decls":null}{"doc_comment":"`.{lhs, rhs}`. lhs and rhs can be omitted.","pl":"array_init_dot_two","src":2603,"more_decls":null}{"doc_comment":"Same as `array_init_dot_two` except there is known to be a trailing comma\nbefore the final rbrace.","pl":"array_init_dot_two_comma","src":2606,"more_decls":null}{"doc_comment":"`.{a, b}`. `sub_list[lhs..rhs]`.","pl":"array_init_dot","src":2608,"more_decls":null}{"doc_comment":"Same as `array_init_dot` except there is known to be a trailing comma\nbefore the final rbrace.","pl":"array_init_dot_comma","src":2611,"more_decls":null}{"doc_comment":"`lhs{a, b}`. `sub_range_list[rhs]`. lhs can be omitted which means `.{a, b}`.","pl":"array_init","src":2613,"more_decls":null}{"doc_comment":"Same as `array_init` except there is known to be a trailing comma\nbefore the final rbrace.","pl":"array_init_comma","src":2616,"more_decls":null}{"doc_comment":"`lhs{.a = rhs}`. rhs can be omitted making it empty.\nmain_token is the lbrace.","pl":"struct_init_one","src":2619,"more_decls":null}{"doc_comment":"`lhs{.a = rhs,}`. rhs can *not* be omitted.\nmain_token is the lbrace.","pl":"struct_init_one_comma","src":2622,"more_decls":null}{"doc_comment":"`.{.a = lhs, .b = rhs}`. lhs and rhs can be omitted.\nmain_token is the lbrace.\nNo trailing comma before the rbrace.","pl":"struct_init_dot_two","src":2626,"more_decls":null}{"doc_comment":"Same as `struct_init_dot_two` except there is known to be a trailing comma\nbefore the final rbrace.","pl":"struct_init_dot_two_comma","src":2629,"more_decls":null}{"doc_comment":"`.{.a = b, .c = d}`. `sub_list[lhs..rhs]`.\nmain_token is the lbrace.","pl":"struct_init_dot","src":2632,"more_decls":null}{"doc_comment":"Same as `struct_init_dot` except there is known to be a trailing comma\nbefore the final rbrace.","pl":"struct_init_dot_comma","src":2635,"more_decls":null}{"doc_comment":"`lhs{.a = b, .c = d}`. `sub_range_list[rhs]`.\nlhs can be omitted which means `.{.a = b, .c = d}`.\nmain_token is the lbrace.","pl":"struct_init","src":2639,"more_decls":null}{"doc_comment":"Same as `struct_init` except there is known to be a trailing comma\nbefore the final rbrace.","pl":"struct_init_comma","src":2642,"more_decls":null}{"doc_comment":"`lhs(rhs)`. rhs can be omitted.\nmain_token is the lparen.","pl":"call_one","src":2645,"more_decls":null}{"doc_comment":"`lhs(rhs,)`. rhs can be omitted.\nmain_token is the lparen.","pl":"call_one_comma","src":2648,"more_decls":null}{"doc_comment":"`async lhs(rhs)`. rhs can be omitted.","pl":"async_call_one","src":2650,"more_decls":null}{"doc_comment":"`async lhs(rhs,)`.","pl":"async_call_one_comma","src":2652,"more_decls":null}{"doc_comment":"`lhs(a, b, c)`. `SubRange[rhs]`.\nmain_token is the `(`.","pl":"call","src":2655,"more_decls":null}{"doc_comment":"`lhs(a, b, c,)`. `SubRange[rhs]`.\nmain_token is the `(`.","pl":"call_comma","src":2658,"more_decls":null}{"doc_comment":"`async lhs(a, b, c)`. `SubRange[rhs]`.\nmain_token is the `(`.","pl":"async_call","src":2661,"more_decls":null}{"doc_comment":"`async lhs(a, b, c,)`. `SubRange[rhs]`.\nmain_token is the `(`.","pl":"async_call_comma","src":2664,"more_decls":null}{"doc_comment":"`switch(lhs) {}`. `SubRange[rhs]`.","pl":"@\"switch\"","src":2666,"more_decls":null}{"doc_comment":"Same as switch except there is known to be a trailing comma\nbefore the final rbrace","pl":"switch_comma","src":2669,"more_decls":null}{"doc_comment":"`lhs => rhs`. If lhs is omitted it means `else`.\nmain_token is the `=>`","pl":"switch_case_one","src":2672,"more_decls":null}{"doc_comment":"`a, b, c => rhs`. `SubRange[lhs]`.\nmain_token is the `=>`","pl":"switch_case","src":2675,"more_decls":null}{"doc_comment":"`lhs...rhs`.","pl":"switch_range","src":2677,"more_decls":null}{"doc_comment":"`while (lhs) rhs`.\n`while (lhs) |x| rhs`.","pl":"while_simple","src":2680,"more_decls":null}{"doc_comment":"`while (lhs) : (a) b`. `WhileCont[rhs]`.\n`while (lhs) : (a) b`. `WhileCont[rhs]`.","pl":"while_cont","src":2683,"more_decls":null}{"doc_comment":"`while (lhs) : (a) b else c`. `While[rhs]`.\n`while (lhs) |x| : (a) b else c`. `While[rhs]`.\n`while (lhs) |x| : (a) b else |y| c`. `While[rhs]`.","pl":"@\"while\"","src":2687,"more_decls":null}{"doc_comment":"`for (lhs) rhs`.","pl":"for_simple","src":2689,"more_decls":null}{"doc_comment":"`for (lhs) a else b`. `if_list[rhs]`.","pl":"@\"for\"","src":2691,"more_decls":null}{"doc_comment":"`if (lhs) rhs`.\n`if (lhs) |a| rhs`.","pl":"if_simple","src":2694,"more_decls":null}{"doc_comment":"`if (lhs) a else b`. `If[rhs]`.\n`if (lhs) |x| a else b`. `If[rhs]`.\n`if (lhs) |x| a else |y| b`. `If[rhs]`.","pl":"@\"if\"","src":2698,"more_decls":null}{"doc_comment":"`suspend lhs`. lhs can be omitted. rhs is unused.","pl":"@\"suspend\"","src":2700,"more_decls":null}{"doc_comment":"`resume lhs`. rhs is unused.","pl":"@\"resume\"","src":2702,"more_decls":null}{"doc_comment":"`continue`. lhs is token index of label if any. rhs is unused.","pl":"@\"continue\"","src":2704,"more_decls":null}{"doc_comment":"`break :lhs rhs`\nboth lhs and rhs may be omitted.","pl":"@\"break\"","src":2707,"more_decls":null}{"doc_comment":"`return lhs`. lhs can be omitted. rhs is unused.","pl":"@\"return\"","src":2709,"more_decls":null}{"doc_comment":"`fn(a: lhs) rhs`. lhs can be omitted.\nanytype and ... parameters are omitted from the AST tree.\nmain_token is the `fn` keyword.\nextern function declarations use this tag.","pl":"fn_proto_simple","src":2714,"more_decls":null}{"doc_comment":"`fn(a: b, c: d) rhs`. `sub_range_list[lhs]`.\nanytype and ... parameters are omitted from the AST tree.\nmain_token is the `fn` keyword.\nextern function declarations use this tag.","pl":"fn_proto_multi","src":2719,"more_decls":null}{"doc_comment":"`fn(a: b) rhs linksection(e) callconv(f)`. `FnProtoOne[lhs]`.\nzero or one parameters.\nanytype and ... parameters are omitted from the AST tree.\nmain_token is the `fn` keyword.\nextern function declarations use this tag.","pl":"fn_proto_one","src":2725,"more_decls":null}{"doc_comment":"`fn(a: b, c: d) rhs linksection(e) callconv(f)`. `FnProto[lhs]`.\nanytype and ... parameters are omitted from the AST tree.\nmain_token is the `fn` keyword.\nextern function declarations use this tag.","pl":"fn_proto","src":2730,"more_decls":null}{"doc_comment":"lhs is the fn_proto.\nrhs is the function body block.\nNote that extern function declarations use the fn_proto tags rather\nthan this one.","pl":"fn_decl","src":2735,"more_decls":null}{"doc_comment":"`anyframe->rhs`. main_token is `anyframe`. `lhs` is arrow token index.","pl":"anyframe_type","src":2737,"more_decls":null}{"doc_comment":"Both lhs and rhs unused.","pl":"anyframe_literal","src":2739,"more_decls":null}{"doc_comment":"Both lhs and rhs unused.","pl":"char_literal","src":2741,"more_decls":null}{"doc_comment":"Both lhs and rhs unused.","pl":"integer_literal","src":2743,"more_decls":null}{"doc_comment":"Both lhs and rhs unused.","pl":"float_literal","src":2745,"more_decls":null}{"doc_comment":"Both lhs and rhs unused.","pl":"false_literal","src":2747,"more_decls":null}{"doc_comment":"Both lhs and rhs unused.","pl":"true_literal","src":2749,"more_decls":null}{"doc_comment":"Both lhs and rhs unused.","pl":"null_literal","src":2751,"more_decls":null}{"doc_comment":"Both lhs and rhs unused.","pl":"undefined_literal","src":2753,"more_decls":null}{"doc_comment":"Both lhs and rhs unused.","pl":"unreachable_literal","src":2755,"more_decls":null}{"doc_comment":"Both lhs and rhs unused.\nMost identifiers will not have explicit AST nodes, however for expressions\nwhich could be one of many different kinds of AST nodes, there will be an\nidentifier AST node for it.","pl":"identifier","src":2760,"more_decls":null}{"doc_comment":"lhs is the dot token index, rhs unused, main_token is the identifier.","pl":"enum_literal","src":2762,"more_decls":null}{"doc_comment":"main_token is the string literal token\nBoth lhs and rhs unused.","pl":"string_literal","src":2765,"more_decls":null}{"doc_comment":"main_token is the first token index (redundant with lhs)\nlhs is the first token index; rhs is the last token index.\nCould be a series of multiline_string_literal_line tokens, or a single\nstring_literal token.","pl":"multiline_string_literal","src":2770,"more_decls":null}{"doc_comment":"`(lhs)`. main_token is the `(`; rhs is the token index of the `)`.","pl":"grouped_expression","src":2772,"more_decls":null}{"doc_comment":"`@a(lhs, rhs)`. lhs and rhs may be omitted.\nmain_token is the builtin token.","pl":"builtin_call_two","src":2775,"more_decls":null}{"doc_comment":"Same as builtin_call_two but there is known to be a trailing comma before the rparen.","pl":"builtin_call_two_comma","src":2777,"more_decls":null}{"doc_comment":"`@a(b, c)`. `sub_list[lhs..rhs]`.\nmain_token is the builtin token.","pl":"builtin_call","src":2780,"more_decls":null}{"doc_comment":"Same as builtin_call but there is known to be a trailing comma before the rparen.","pl":"builtin_call_comma","src":2782,"more_decls":null}{"doc_comment":"`error{a, b}`.\nrhs is the rbrace, lhs is unused.","pl":"error_set_decl","src":2785,"more_decls":null}{"doc_comment":"`struct {}`, `union {}`, `opaque {}`, `enum {}`. `extra_data[lhs..rhs]`.\nmain_token is `struct`, `union`, `opaque`, `enum` keyword.","pl":"container_decl","src":2788,"more_decls":null}{"doc_comment":"Same as ContainerDecl but there is known to be a trailing comma\nor semicolon before the rbrace.","pl":"container_decl_trailing","src":2791,"more_decls":null}{"doc_comment":"`struct {lhs, rhs}`, `union {lhs, rhs}`, `opaque {lhs, rhs}`, `enum {lhs, rhs}`.\nlhs or rhs can be omitted.\nmain_token is `struct`, `union`, `opaque`, `enum` keyword.","pl":"container_decl_two","src":2795,"more_decls":null}{"doc_comment":"Same as ContainerDeclTwo except there is known to be a trailing comma\nor semicolon before the rbrace.","pl":"container_decl_two_trailing","src":2798,"more_decls":null}{"doc_comment":"`union(lhs)` / `enum(lhs)`. `SubRange[rhs]`.","pl":"container_decl_arg","src":2800,"more_decls":null}{"doc_comment":"Same as container_decl_arg but there is known to be a trailing\ncomma or semicolon before the rbrace.","pl":"container_decl_arg_trailing","src":2803,"more_decls":null}{"doc_comment":"`union(enum) {}`. `sub_list[lhs..rhs]`.\nNote that tagged unions with explicitly provided enums are represented\nby `container_decl_arg`.","pl":"tagged_union","src":2807,"more_decls":null}{"doc_comment":"Same as tagged_union but there is known to be a trailing comma\nor semicolon before the rbrace.","pl":"tagged_union_trailing","src":2810,"more_decls":null}{"doc_comment":"`union(enum) {lhs, rhs}`. lhs or rhs may be omitted.\nNote that tagged unions with explicitly provided enums are represented\nby `container_decl_arg`.","pl":"tagged_union_two","src":2814,"more_decls":null}{"doc_comment":"Same as tagged_union_two but there is known to be a trailing comma\nor semicolon before the rbrace.","pl":"tagged_union_two_trailing","src":2817,"more_decls":null}{"doc_comment":"`union(enum(lhs)) {}`. `SubRange[rhs]`.","pl":"tagged_union_enum_tag","src":2819,"more_decls":null}{"doc_comment":"Same as tagged_union_enum_tag but there is known to be a trailing comma\nor semicolon before the rbrace.","pl":"tagged_union_enum_tag_trailing","src":2822,"more_decls":null}{"doc_comment":"`a: lhs = rhs,`. lhs and rhs can be omitted.\nmain_token is the field name identifier.\nlastToken() does not include the possible trailing comma.","pl":"container_field_init","src":2826,"more_decls":null}{"doc_comment":"`a: lhs align(rhs),`. rhs can be omitted.\nmain_token is the field name identifier.\nlastToken() does not include the possible trailing comma.","pl":"container_field_align","src":2830,"more_decls":null}{"doc_comment":"`a: lhs align(c) = d,`. `container_field_list[rhs]`.\nmain_token is the field name identifier.\nlastToken() does not include the possible trailing comma.","pl":"container_field","src":2834,"more_decls":null}{"doc_comment":"`anytype`. both lhs and rhs unused.\nUsed by `ContainerField`.","pl":"@\"anytype\"","src":2837,"more_decls":null}{"doc_comment":"`comptime lhs`. rhs unused.","pl":"@\"comptime\"","src":2839,"more_decls":null}{"doc_comment":"`nosuspend lhs`. rhs unused.","pl":"@\"nosuspend\"","src":2841,"more_decls":null}{"doc_comment":"`{lhs rhs}`. rhs or lhs can be omitted.\nmain_token points at the lbrace.","pl":"block_two","src":2844,"more_decls":null}{"doc_comment":"Same as block_two but there is known to be a semicolon before the rbrace.","pl":"block_two_semicolon","src":2846,"more_decls":null}{"doc_comment":"`{}`. `sub_list[lhs..rhs]`.\nmain_token points at the lbrace.","pl":"block","src":2849,"more_decls":null}{"doc_comment":"Same as block but there is known to be a semicolon before the rbrace.","pl":"block_semicolon","src":2851,"more_decls":null}{"doc_comment":"`asm(lhs)`. rhs is the token index of the rparen.","pl":"asm_simple","src":2853,"more_decls":null}{"doc_comment":"`asm(lhs, a)`. `Asm[rhs]`.","pl":"@\"asm\"","src":2855,"more_decls":null}{"doc_comment":"`[a] \"b\" (c)`. lhs is 0, rhs is token index of the rparen.\n`[a] \"b\" (-> lhs)`. rhs is token index of the rparen.\nmain_token is `a`.","pl":"asm_output","src":2859,"more_decls":null}{"doc_comment":"`[a] \"b\" (lhs)`. rhs is token index of the rparen.\nmain_token is `a`.","pl":"asm_input","src":2862,"more_decls":null}{"doc_comment":"`error.a`. lhs is token index of `.`. rhs is token index of `a`.","pl":"error_value","src":2864,"more_decls":null}{"doc_comment":"`lhs!rhs`. main_token is the `!`.","pl":"error_union","src":2866,"more_decls":null}{"pl":"fn isContainerField(tag: Tag) bool","src":2868,"more_decls":null}}{"pl":"pub const Data = struct ","src":2880,"more_decls":{"pl":"lhs: Index","src":2881,"more_decls":null}{"pl":"rhs: Index","src":2882,"more_decls":null}}{"pl":"pub const LocalVarDecl = struct ","src":2885,"more_decls":{"pl":"type_node: Index","src":2886,"more_decls":null}{"pl":"align_node: Index","src":2887,"more_decls":null}}{"pl":"pub const ArrayTypeSentinel = struct ","src":2890,"more_decls":{"pl":"elem_type: Index","src":2891,"more_decls":null}{"pl":"sentinel: Index","src":2892,"more_decls":null}}{"pl":"pub const PtrType = struct ","src":2895,"more_decls":{"pl":"sentinel: Index","src":2896,"more_decls":null}{"pl":"align_node: Index","src":2897,"more_decls":null}}{"pl":"pub const PtrTypeBitRange = struct ","src":2900,"more_decls":{"pl":"sentinel: Index","src":2901,"more_decls":null}{"pl":"align_node: Index","src":2902,"more_decls":null}{"pl":"bit_range_start: Index","src":2903,"more_decls":null}{"pl":"bit_range_end: Index","src":2904,"more_decls":null}}{"pl":"pub const SubRange = struct ","src":2907,"more_decls":{"doc_comment":"Index into sub_list.","pl":"start: Index","src":2909,"more_decls":null}{"doc_comment":"Index into sub_list.","pl":"end: Index","src":2911,"more_decls":null}}{"pl":"pub const If = struct ","src":2914,"more_decls":{"pl":"then_expr: Index","src":2915,"more_decls":null}{"pl":"else_expr: Index","src":2916,"more_decls":null}}{"pl":"pub const ContainerField = struct ","src":2919,"more_decls":{"pl":"value_expr: Index","src":2920,"more_decls":null}{"pl":"align_expr: Index","src":2921,"more_decls":null}}{"pl":"pub const GlobalVarDecl = struct ","src":2924,"more_decls":{"pl":"type_node: Index","src":2925,"more_decls":null}{"pl":"align_node: Index","src":2926,"more_decls":null}{"pl":"section_node: Index","src":2927,"more_decls":null}}{"pl":"pub const Slice = struct ","src":2930,"more_decls":{"pl":"start: Index","src":2931,"more_decls":null}{"pl":"end: Index","src":2932,"more_decls":null}}{"pl":"pub const SliceSentinel = struct ","src":2935,"more_decls":{"pl":"start: Index","src":2936,"more_decls":null}{"doc_comment":"May be 0 if the slice is \"open\"","pl":"end: Index","src":2938,"more_decls":null}{"pl":"sentinel: Index","src":2939,"more_decls":null}}{"pl":"pub const While = struct ","src":2942,"more_decls":{"pl":"cont_expr: Index","src":2943,"more_decls":null}{"pl":"then_expr: Index","src":2944,"more_decls":null}{"pl":"else_expr: Index","src":2945,"more_decls":null}}{"pl":"pub const WhileCont = struct ","src":2948,"more_decls":{"pl":"cont_expr: Index","src":2949,"more_decls":null}{"pl":"then_expr: Index","src":2950,"more_decls":null}}{"pl":"pub const FnProtoOne = struct ","src":2953,"more_decls":{"doc_comment":"Populated if there is exactly 1 parameter. Otherwise there are 0 parameters.","pl":"param: Index","src":2955,"more_decls":null}{"doc_comment":"Populated if align(A) is present.","pl":"align_expr: Index","src":2957,"more_decls":null}{"doc_comment":"Populated if linksection(A) is present.","pl":"section_expr: Index","src":2959,"more_decls":null}{"doc_comment":"Populated if callconv(A) is present.","pl":"callconv_expr: Index","src":2961,"more_decls":null}}{"pl":"pub const FnProto = struct ","src":2964,"more_decls":{"pl":"params_start: Index","src":2965,"more_decls":null}{"pl":"params_end: Index","src":2966,"more_decls":null}{"doc_comment":"Populated if align(A) is present.","pl":"align_expr: Index","src":2968,"more_decls":null}{"doc_comment":"Populated if linksection(A) is present.","pl":"section_expr: Index","src":2970,"more_decls":null}{"doc_comment":"Populated if callconv(A) is present.","pl":"callconv_expr: Index","src":2972,"more_decls":null}}{"pl":"pub const Asm = struct ","src":2975,"more_decls":{"pl":"items_start: Index","src":2976,"more_decls":null}{"pl":"items_end: Index","src":2977,"more_decls":null}{"doc_comment":"Needed to make lastToken() work.","pl":"rparen: TokenIndex","src":2979,"more_decls":null}}{"pl":"const Index = u32","src":2415,"more_decls":null}}{"pl":"const TokenIndex = u32","src":11,"more_decls":null}{"pl":"const ByteOffset = u32","src":12,"more_decls":null}{"pl":"const TokenList = std.MultiArrayList(struct {\n    tag: Token.Tag,\n    start: ByteOffset,\n})","src":14,"more_decls":null}{"pl":"const NodeList = std.MultiArrayList(Node)","src":18,"more_decls":null}]