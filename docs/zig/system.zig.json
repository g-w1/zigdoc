[{"pl":"pub const NativePaths = struct ","src":20,"more_decls":{"pl":"include_dirs: ArrayList([:0]u8)","src":21,"more_decls":null}{"pl":"lib_dirs: ArrayList([:0]u8)","src":22,"more_decls":null}{"pl":"framework_dirs: ArrayList([:0]u8)","src":23,"more_decls":null}{"pl":"rpaths: ArrayList([:0]u8)","src":24,"more_decls":null}{"pl":"warnings: ArrayList([:0]u8)","src":25,"more_decls":null}{"pl":"fn detect(allocator: *Allocator, native_info: NativeTargetInfo) !NativePaths","src":27,"more_decls":null}{"pl":"fn deinit(self: *NativePaths) void","src":137,"more_decls":null}{"pl":"pub fn addIncludeDir(self: *NativePaths, s: []const u8) !void {\n    return self.appendArray(&self.include_dirs, s);\n}","src":153,"more_decls":null}{"pl":"pub fn addIncludeDirFmt(self: *NativePaths, comptime fmt: []const u8, args: anytype) !void {\n    const item = try std.fmt.allocPrint0(self.include_dirs.allocator, fmt, args);\n    errdefer self.include_dirs.allocator.free(item);\n    try self.include_dirs.append(item);\n}","src":157,"more_decls":null}{"pl":"pub fn addLibDir(self: *NativePaths, s: []const u8) !void {\n    return self.appendArray(&self.lib_dirs, s);\n}","src":163,"more_decls":null}{"pl":"pub fn addLibDirFmt(self: *NativePaths, comptime fmt: []const u8, args: anytype) !void {\n    const item = try std.fmt.allocPrint0(self.lib_dirs.allocator, fmt, args);\n    errdefer self.lib_dirs.allocator.free(item);\n    try self.lib_dirs.append(item);\n}","src":167,"more_decls":null}{"pl":"pub fn addWarning(self: *NativePaths, s: []const u8) !void {\n    return self.appendArray(&self.warnings, s);\n}","src":173,"more_decls":null}{"pl":"pub fn addFrameworkDir(self: *NativePaths, s: []const u8) !void {\n    return self.appendArray(&self.framework_dirs, s);\n}","src":177,"more_decls":null}{"pl":"pub fn addFrameworkDirFmt(self: *NativePaths, comptime fmt: []const u8, args: anytype) !void {\n    const item = try std.fmt.allocPrint0(self.framework_dirs.allocator, fmt, args);\n    errdefer self.framework_dirs.allocator.free(item);\n    try self.framework_dirs.append(item);\n}","src":181,"more_decls":null}{"pl":"pub fn addWarningFmt(self: *NativePaths, comptime fmt: []const u8, args: anytype) !void {\n    const item = try std.fmt.allocPrint0(self.warnings.allocator, fmt, args);\n    errdefer self.warnings.allocator.free(item);\n    try self.warnings.append(item);\n}","src":187,"more_decls":null}{"pl":"pub fn addRPath(self: *NativePaths, s: []const u8) !void {\n    return self.appendArray(&self.rpaths, s);\n}","src":193,"more_decls":null}}{"pl":"pub const NativeTargetInfo = struct ","src":204,"more_decls":{"pl":"target: Target","src":205,"more_decls":null}{"pl":"dynamic_linker: DynamicLinker = DynamicLinker{}","src":207,"more_decls":null}{"doc_comment":"Only some architectures have CPU detection implemented. This field reveals whether\nCPU detection actually occurred. When this is `true` it means that the reported\nCPU is baseline only because of a missing implementation for that architecture.","pl":"cpu_detection_unimplemented: bool = false","src":212,"more_decls":null}{"pl":"pub const LdInfo = struct ","src":862,"more_decls":{"pl":"ld: DynamicLinker","src":863,"more_decls":null}{"pl":"abi: Target.Abi","src":864,"more_decls":null}}{"doc_comment":"Given a `CrossTarget`, which specifies in detail which parts of the target should be detected\nnatively, which should be standard or default, and which are provided explicitly, this function\nresolves the native components by detecting the native system, and then resolves standard/default parts\nrelative to that.\nAny resources this function allocates are released before returning, and so there is no\ndeinitialization method.\nTODO Remove the Allocator requirement from this function.","pl":"fn detect(allocator: *Allocator, cross_target: CrossTarget) DetectError!NativeTargetInfo","src":234,"more_decls":null}{"pl":"fn abiAndDynamicLinkerFromFile(\n    file: fs.File,\n    cpu: Target.Cpu,\n    os: Target.Os,\n    ld_info_list: []const LdInfo,\n    cross_target: CrossTarget,\n) AbiAndDynamicLinkerFromFileError!NativeTargetInfo","src":566,"more_decls":null}{"pl":"fn elfInt(is_64: bool, need_bswap: bool, int_32: anytype, int_64: anytype) @TypeOf(int_64)","src":867,"more_decls":null}{"pl":"const DynamicLinker = Target.DynamicLinker","src":214,"more_decls":null}{"pl":"const DetectError = error{\n        OutOfMemory,\n        FileSystem,\n        SystemResources,\n        SymLinkLoop,\n        ProcessFdQuotaExceeded,\n        SystemFdQuotaExceeded,\n        DeviceBusy,\n        OSVersionDetectionFail,\n    }","src":216,"more_decls":null}{"pl":"const AbiAndDynamicLinkerFromFileError = error{\n        FileSystem,\n        SystemResources,\n        SymLinkLoop,\n        ProcessFdQuotaExceeded,\n        SystemFdQuotaExceeded,\n        UnableToReadElfFile,\n        InvalidElfClass,\n        InvalidElfVersion,\n        InvalidElfEndian,\n        InvalidElfFile,\n        InvalidElfMagic,\n        Unexpected,\n        UnexpectedEndOfFile,\n        NameTooLong,\n    }","src":549,"more_decls":null}}{"pl":"const windows = @import(\"system/windows.zig\")","src":16,"more_decls":null}{"pl":"const getSDKPath = macos.getSDKPath","src":18,"more_decls":null}]