[{"doc_comment":"Contains all the same data as `Target`, additionally introducing the concept of \"the native target\".\nThe purpose of this abstraction is to provide meaningful and unsurprising defaults.\nThis struct does reference any resources and it is copyable.","pl":"pub const CrossTarget = struct ","src":13,"more_decls":{"doc_comment":"`null` means native.","pl":"cpu_arch: ?Target.Cpu.Arch = null","src":15,"more_decls":null}{"pl":"cpu_model: CpuModel = CpuModel.determined_by_cpu_arch","src":17,"more_decls":null}{"doc_comment":"Sparse set of CPU features to add to the set from `cpu_model`.","pl":"cpu_features_add: Target.Cpu.Feature.Set = Target.Cpu.Feature.Set.empty","src":20,"more_decls":null}{"doc_comment":"Sparse set of CPU features to remove from the set from `cpu_model`.","pl":"cpu_features_sub: Target.Cpu.Feature.Set = Target.Cpu.Feature.Set.empty","src":23,"more_decls":null}{"doc_comment":"`null` means native.","pl":"os_tag: ?Target.Os.Tag = null","src":26,"more_decls":null}{"doc_comment":"`null` means the default version range for `os_tag`. If `os_tag` is `null` (native)\nthen `null` for this field means native.","pl":"os_version_min: ?OsVersion = null","src":30,"more_decls":null}{"doc_comment":"When cross compiling, `null` means default (latest known OS version).\nWhen `os_tag` is native, `null` means equal to the native OS version.","pl":"os_version_max: ?OsVersion = null","src":34,"more_decls":null}{"doc_comment":"`null` means default when cross compiling, or native when os_tag is native.\nIf `isGnuLibC()` is `false`, this must be `null` and is ignored.","pl":"glibc_version: ?SemVer = null","src":38,"more_decls":null}{"doc_comment":"`null` means the native C ABI, if `os_tag` is native, otherwise it means the default C ABI.","pl":"abi: ?Target.Abi = null","src":41,"more_decls":null}{"doc_comment":"When `os_tag` is `null`, then `null` means native. Otherwise it means the standard path\nbased on the `os_tag`.","pl":"dynamic_linker: DynamicLinker = DynamicLinker{}","src":45,"more_decls":null}{"pl":"pub const CpuModel = union(enum) ","src":47,"more_decls":{"doc_comment":"Always native","pl":"native","src":49,"more_decls":null}{"doc_comment":"Always baseline","pl":"baseline","src":52,"more_decls":null}{"doc_comment":"If CPU Architecture is native, then the CPU model will be native. Otherwise,\nit will be baseline.","pl":"determined_by_cpu_arch","src":56,"more_decls":null}{"pl":"explicit: *const Target.Cpu.Model","src":58,"more_decls":null}}{"pl":"pub const OsVersion = union(enum) ","src":61,"more_decls":{"pl":"none: void","src":62,"more_decls":null}{"pl":"semver: SemVer","src":63,"more_decls":null}{"pl":"windows: Target.Os.WindowsVersion","src":64,"more_decls":null}}{"pl":"pub const ParseOptions = struct ","src":175,"more_decls":{"doc_comment":"This is sometimes called a \"triple\". It looks roughly like this:\nriscv64-linux-musl\nThe fields are, respectively:\n* CPU Architecture\n* Operating System (and optional version range)\n* C ABI (optional, with optional glibc version)\nThe string \"native\" can be used for CPU architecture as well as Operating System.\nIf the CPU Architecture is specified as \"native\", then the Operating System and C ABI may be omitted.","pl":"arch_os_abi: []const u8 = \"native\"","src":184,"more_decls":null}{"doc_comment":"Looks like \"name+a+b-c-d+e\", where \"name\" is a CPU Model name, \"a\", \"b\", and \"e\"\nare examples of CPU features to add to the set, and \"c\" and \"d\" are examples of CPU features\nto remove from the set.\nThe following special strings are recognized for CPU Model name:\n* \"baseline\" - The \"default\" set of CPU features for cross-compiling. A conservative set\nof features that is expected to be supported on most available hardware.\n* \"native\"   - The native CPU model is to be detected when compiling.\nIf this field is not provided (`null`), then the value will depend on the\nparsed CPU Architecture. If native, then this will be \"native\". Otherwise, it will be \"baseline\".","pl":"cpu_features: ?[]const u8 = null","src":195,"more_decls":null}{"doc_comment":"Absolute path to dynamic linker, to override the default, which is either a natively\ndetected path, or a standard path.","pl":"dynamic_linker: ?[]const u8 = null","src":199,"more_decls":null}{"doc_comment":"If this is provided, the function will populate some information about parsing failures,\nso that user-friendly error messages can be delivered.","pl":"diagnostics: ?*Diagnostics = null","src":203,"more_decls":null}{"pl":"pub const Diagnostics = struct ","src":205,"more_decls":{"doc_comment":"If the architecture was determined, this will be populated.","pl":"arch: ?Target.Cpu.Arch = null","src":207,"more_decls":null}{"doc_comment":"If the OS name was determined, this will be populated.","pl":"os_name: ?[]const u8 = null","src":210,"more_decls":null}{"doc_comment":"If the OS tag was determined, this will be populated.","pl":"os_tag: ?Target.Os.Tag = null","src":213,"more_decls":null}{"doc_comment":"If the ABI was determined, this will be populated.","pl":"abi: ?Target.Abi = null","src":216,"more_decls":null}{"doc_comment":"If the CPU name was determined, this will be populated.","pl":"cpu_name: ?[]const u8 = null","src":219,"more_decls":null}{"doc_comment":"If error.UnknownCpuFeature is returned, this will be populated.","pl":"unknown_feature_name: ?[]const u8 = null","src":222,"more_decls":null}}}{"pl":"pub const Executor = union(enum) ","src":603,"more_decls":{"pl":"native","src":604,"more_decls":null}{"pl":"qemu: []const u8","src":605,"more_decls":null}{"pl":"wine: []const u8","src":606,"more_decls":null}{"pl":"wasmtime: []const u8","src":607,"more_decls":null}{"pl":"unavailable","src":608,"more_decls":null}}{"pl":"fn fromTarget(target: Target) CrossTarget","src":71,"more_decls":null}{"doc_comment":"TODO deprecated, use `std.zig.system.NativeTargetInfo.detect`.","pl":"fn toTarget(self: CrossTarget) Target","src":167,"more_decls":null}{"pl":"fn parse(args: ParseOptions) !CrossTarget","src":226,"more_decls":null}{"doc_comment":"TODO deprecated, use `std.zig.system.NativeTargetInfo.detect`.","pl":"fn getCpu(self: CrossTarget) Target.Cpu","src":329,"more_decls":null}{"pl":"pub fn getCpuArch(self: CrossTarget) Target.Cpu.Arch {\n    return self.cpu_arch orelse Target.current.cpu.arch;\n}","src":360,"more_decls":null}{"pl":"pub fn getCpuModel(self: CrossTarget) *const Target.Cpu.Model {\n    return switch (self.cpu_model) {\n        .explicit => |cpu_model| cpu_model,\n        else => self.getCpu().model,\n    };\n}","src":364,"more_decls":null}{"pl":"pub fn getCpuFeatures(self: CrossTarget) Target.Cpu.Feature.Set {\n    return self.getCpu().features;\n}","src":371,"more_decls":null}{"doc_comment":"TODO deprecated, use `std.zig.system.NativeTargetInfo.detect`.","pl":"fn getOs(self: CrossTarget) Target.Os","src":376,"more_decls":null}{"pl":"pub fn getOsTag(self: CrossTarget) Target.Os.Tag {\n    return self.os_tag orelse Target.current.os.tag;\n}","src":408,"more_decls":null}{"doc_comment":"TODO deprecated, use `std.zig.system.NativeTargetInfo.detect`.","pl":"pub fn getOsVersionMin(self: CrossTarget) OsVersion {\n    if (self.os_version_min) |version_min| return version_min;\n    var tmp: CrossTarget = undefined;\n    tmp.updateOsVersionRange(self.getOs());\n    return tmp.os_version_min.?;\n}","src":413,"more_decls":null}{"doc_comment":"TODO deprecated, use `std.zig.system.NativeTargetInfo.detect`.","pl":"pub fn getOsVersionMax(self: CrossTarget) OsVersion {\n    if (self.os_version_max) |version_max| return version_max;\n    var tmp: CrossTarget = undefined;\n    tmp.updateOsVersionRange(self.getOs());\n    return tmp.os_version_max.?;\n}","src":421,"more_decls":null}{"doc_comment":"TODO deprecated, use `std.zig.system.NativeTargetInfo.detect`.","pl":"fn getAbi(self: CrossTarget) Target.Abi","src":429,"more_decls":null}{"pl":"pub fn isFreeBSD(self: CrossTarget) bool {\n    return self.getOsTag() == .freebsd;\n}","src":442,"more_decls":null}{"pl":"pub fn isDarwin(self: CrossTarget) bool {\n    return self.getOsTag().isDarwin();\n}","src":446,"more_decls":null}{"pl":"pub fn isNetBSD(self: CrossTarget) bool {\n    return self.getOsTag() == .netbsd;\n}","src":450,"more_decls":null}{"pl":"pub fn isOpenBSD(self: CrossTarget) bool {\n    return self.getOsTag() == .openbsd;\n}","src":454,"more_decls":null}{"pl":"pub fn isUefi(self: CrossTarget) bool {\n    return self.getOsTag() == .uefi;\n}","src":458,"more_decls":null}{"pl":"pub fn isDragonFlyBSD(self: CrossTarget) bool {\n    return self.getOsTag() == .dragonfly;\n}","src":462,"more_decls":null}{"pl":"pub fn isLinux(self: CrossTarget) bool {\n    return self.getOsTag() == .linux;\n}","src":466,"more_decls":null}{"pl":"pub fn isWindows(self: CrossTarget) bool {\n    return self.getOsTag() == .windows;\n}","src":470,"more_decls":null}{"pl":"pub fn oFileExt(self: CrossTarget) [:0]const u8 {\n    return Target.oFileExt_cpu_arch_abi(self.getCpuArch(), self.getAbi());\n}","src":474,"more_decls":null}{"pl":"pub fn exeFileExt(self: CrossTarget) [:0]const u8 {\n    return Target.exeFileExtSimple(self.getCpuArch(), self.getOsTag());\n}","src":478,"more_decls":null}{"pl":"pub fn staticLibSuffix(self: CrossTarget) [:0]const u8 {\n    return Target.staticLibSuffix_cpu_arch_abi(self.getCpuArch(), self.getAbi());\n}","src":482,"more_decls":null}{"pl":"pub fn dynamicLibSuffix(self: CrossTarget) [:0]const u8 {\n    return self.getOsTag().dynamicLibSuffix();\n}","src":486,"more_decls":null}{"pl":"pub fn libPrefix(self: CrossTarget) [:0]const u8 {\n    return Target.libPrefix_cpu_arch_abi(self.getCpuArch(), self.getAbi());\n}","src":490,"more_decls":null}{"pl":"pub fn isNativeCpu(self: CrossTarget) bool {\n    return self.cpu_arch == null and\n        (self.cpu_model == .native or self.cpu_model == .determined_by_cpu_arch) and\n        self.cpu_features_sub.isEmpty() and self.cpu_features_add.isEmpty();\n}","src":494,"more_decls":null}{"pl":"pub fn isNativeOs(self: CrossTarget) bool {\n    return self.os_tag == null and self.os_version_min == null and self.os_version_max == null and\n        self.dynamic_linker.get() == null and self.glibc_version == null;\n}","src":500,"more_decls":null}{"pl":"pub fn isNativeAbi(self: CrossTarget) bool {\n    return self.os_tag == null and self.abi == null;\n}","src":505,"more_decls":null}{"pl":"pub fn isNative(self: CrossTarget) bool {\n    return self.isNativeCpu() and self.isNativeOs() and self.isNativeAbi();\n}","src":509,"more_decls":null}{"pl":"fn zigTriple(self: CrossTarget, allocator: *mem.Allocator) error{OutOfMemory}![]u8","src":513,"more_decls":null}{"pl":"pub fn allocDescription(self: CrossTarget, allocator: *mem.Allocator) ![]u8 {\n    // TODO is there anything else worthy of the description that is not\n    // already captured in the triple?\n    return self.zigTriple(allocator);\n}","src":552,"more_decls":null}{"pl":"pub fn linuxTriple(self: CrossTarget, allocator: *mem.Allocator) ![]u8 {\n    return Target.linuxTripleSimple(allocator, self.getCpuArch(), self.getOsTag(), self.getAbi());\n}","src":558,"more_decls":null}{"pl":"pub fn wantSharedLibSymLinks(self: CrossTarget) bool {\n    return self.getOsTag() != .windows;\n}","src":562,"more_decls":null}{"doc_comment":"Returned slice must be freed by the caller.","pl":"fn vcpkgTriplet(self: CrossTarget, allocator: *mem.Allocator, linkage: VcpkgLinkage) ![]u8","src":569,"more_decls":null}{"doc_comment":"Note that even a `CrossTarget` which returns `false` for `isNative` could still be natively executed.\nFor example `-target arm-native` running on an aarch64 host.","pl":"fn getExternalExecutor(self: CrossTarget) Executor","src":613,"more_decls":null}{"pl":"pub fn isGnuLibC(self: CrossTarget) bool {\n    return Target.isGnuLibC_os_tag_abi(self.getOsTag(), self.getAbi());\n}","src":673,"more_decls":null}{"pl":"pub fn setGnuLibCVersion(self: *CrossTarget, major: u32, minor: u32, patch: u32) void {\n    assert(self.isGnuLibC());\n    self.glibc_version = SemVer{ .major = major, .minor = minor, .patch = patch };\n}","src":677,"more_decls":null}{"pl":"pub fn getObjectFormat(self: CrossTarget) Target.ObjectFormat {\n    return Target.getObjectFormatSimple(self.getOsTag(), self.getCpuArch());\n}","src":682,"more_decls":null}{"pl":"pub fn updateCpuFeatures(self: CrossTarget, set: *Target.Cpu.Feature.Set) void {\n    set.removeFeatureSet(self.cpu_features_sub);\n    set.addFeatureSet(self.cpu_features_add);\n    set.populateDependencies(self.getCpuArch().allFeaturesList());\n    set.removeFeatureSet(self.cpu_features_sub);\n}","src":686,"more_decls":null}{"pl":"const SemVer = std.builtin.Version","src":67,"more_decls":null}{"pl":"const DynamicLinker = Target.DynamicLinker","src":69,"more_decls":null}{"pl":"const VcpkgLinkage = std.builtin.LinkMode","src":566,"more_decls":null}}]