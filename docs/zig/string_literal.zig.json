[{"pl":"pub const Result = union(enum) ","src":13,"more_decls":{"pl":"success","src":14,"more_decls":null}{"doc_comment":"Found an invalid character at this index.","pl":"invalid_character: usize","src":16,"more_decls":null}{"doc_comment":"Expected hex digits at this index.","pl":"expected_hex_digits: usize","src":18,"more_decls":null}{"doc_comment":"Invalid hex digits at this index.","pl":"invalid_hex_escape: usize","src":20,"more_decls":null}{"doc_comment":"Invalid unicode escape at this index.","pl":"invalid_unicode_escape: usize","src":22,"more_decls":null}{"doc_comment":"The left brace at this index is missing a matching right brace.","pl":"missing_matching_rbrace: usize","src":24,"more_decls":null}{"doc_comment":"Expected unicode digits at this index.","pl":"expected_unicode_digits: usize","src":26,"more_decls":null}}{"doc_comment":"Parses `bytes` as a Zig string literal and appends the result to `buf`.\nAsserts `bytes` has '\"' at beginning and end.","pl":"fn parseAppend(buf: *std.ArrayList(u8), bytes: []const u8) error{OutOfMemory}!Result","src":31,"more_decls":null}{"doc_comment":"Higher level API. Does not return extra info about parse errors.\nCaller owns returned memory.","pl":"fn parseAlloc(allocator: *std.mem.Allocator, bytes: []const u8) ParseError![]u8","src":137,"more_decls":null}{"pl":"const ParseError = error{\n    OutOfMemory,\n    InvalidStringLiteral,\n}","src":8,"more_decls":null}]