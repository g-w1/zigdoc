[{"pl":"pub const Config = struct ","src":133,"more_decls":{"doc_comment":"Number of stack frames to capture.","pl":"stack_trace_frames: usize = default_stack_trace_frames","src":135,"more_decls":null}{"doc_comment":"If true, the allocator will have two fields:\n* `total_requested_bytes` which tracks the total allocated bytes of memory requested.\n* `requested_memory_limit` which causes allocations to return `error.OutOfMemory`\nwhen the `total_requested_bytes` exceeds this limit.\nIf false, these fields will be `void`.","pl":"enable_memory_limit: bool = false","src":142,"more_decls":null}{"doc_comment":"Whether to enable safety checks.","pl":"safety: bool = std.debug.runtime_safety","src":145,"more_decls":null}{"doc_comment":"Whether the allocator may be used simultaneously from multiple threads.","pl":"thread_safe: bool = !std.builtin.single_threaded","src":148,"more_decls":null}{"doc_comment":"What type of mutex you'd like to use, for thread safety.\nwhen specfied, the mutex type must have the same shape as `std.Thread.Mutex` and\n`std.Thread.Mutex.Dummy`, and have no required fields. Specifying this field causes\nthe `thread_safe` field to be ignored.\n\nwhen null (default):\n* the mutex type defaults to `std.Thread.Mutex` when thread_safe is enabled.\n* the mutex type defaults to `std.Thread.Mutex.Dummy` otherwise.","pl":"MutexType: ?type = null","src":158,"more_decls":null}{"doc_comment":"This is a temporary debugging trick you can use to turn segfaults into more helpful\nlogged error messages with stack trace details. The downside is that every allocation\nwill be leaked!","pl":"never_unmap: bool = false","src":163,"more_decls":null}{"doc_comment":"Enables emitting info messages with the size and address of every allocation.","pl":"verbose_log: bool = false","src":166,"more_decls":null}}{"pl":"fn GeneralPurposeAllocator(comptime config: Config) type","sub_container_type":"struct ","src":169,"more_decls":{"pl":"allocator: Allocator = Allocator{\n            .allocFn = alloc,\n            .resizeFn = resize,\n        }","src":171,"more_decls":null}{"pl":"backing_allocator: *Allocator = std.heap.page_allocator","src":175,"more_decls":null}{"pl":"buckets: [small_bucket_count]?*BucketHeader = [1]?*BucketHeader{null} ** small_bucket_count","src":176,"more_decls":null}{"pl":"large_allocations: LargeAllocTable = .{}","src":177,"more_decls":null}{"pl":"total_requested_bytes: @TypeOf(total_requested_bytes_init) = total_requested_bytes_init","src":179,"more_decls":null}{"pl":"requested_memory_limit: @TypeOf(requested_memory_limit_init) = requested_memory_limit_init","src":180,"more_decls":null}{"pl":"mutex: @TypeOf(mutex_init) = mutex_init","src":182,"more_decls":null}{"doc_comment":"Emits log messages for leaks and then returns whether there were any leaks.","pl":"fn detectLeaks(self: *Self) bool","src":331,"more_decls":null}{"pl":"pub fn deinit(self: *Self) bool {\n    const leaks = if (config.safety) self.detectLeaks() else false;\n    self.large_allocations.deinit(self.backing_allocator);\n    self.* = undefined;\n    return leaks;\n}","src":353,"more_decls":null}{"pl":"pub fn setRequestedMemoryLimit(self: *Self, limit: usize) void {\n    self.requested_memory_limit = limit;\n}","src":477,"more_decls":null}{"pl":"const Error = mem.Allocator.Error","src":200,"more_decls":null}}]