[{"doc_comment":"TODO Nearly all the functions in this namespace would be\nbetter off if https://github.com/ziglang/zig/issues/425\nwas solved.","pl":"pub const Target = struct ","src":13,"more_decls":{"pl":"cpu: Cpu","src":14,"more_decls":null}{"pl":"os: Os","src":15,"more_decls":null}{"pl":"abi: Abi","src":16,"more_decls":null}{"pl":"pub const Os = struct ","src":18,"more_decls":{"pl":"tag: Tag","src":19,"more_decls":null}{"pl":"version_range: VersionRange","src":20,"more_decls":null}{"pl":"pub const Tag = enum ","src":22,"more_decls":{"pl":"freestanding","src":23,"more_decls":null}{"pl":"ananas","src":24,"more_decls":null}{"pl":"cloudabi","src":25,"more_decls":null}{"pl":"dragonfly","src":26,"more_decls":null}{"pl":"freebsd","src":27,"more_decls":null}{"pl":"fuchsia","src":28,"more_decls":null}{"pl":"ios","src":29,"more_decls":null}{"pl":"kfreebsd","src":30,"more_decls":null}{"pl":"linux","src":31,"more_decls":null}{"pl":"lv2","src":32,"more_decls":null}{"pl":"macos","src":33,"more_decls":null}{"pl":"netbsd","src":34,"more_decls":null}{"pl":"openbsd","src":35,"more_decls":null}{"pl":"solaris","src":36,"more_decls":null}{"pl":"windows","src":37,"more_decls":null}{"pl":"haiku","src":38,"more_decls":null}{"pl":"minix","src":39,"more_decls":null}{"pl":"rtems","src":40,"more_decls":null}{"pl":"nacl","src":41,"more_decls":null}{"pl":"cnk","src":42,"more_decls":null}{"pl":"aix","src":43,"more_decls":null}{"pl":"cuda","src":44,"more_decls":null}{"pl":"nvcl","src":45,"more_decls":null}{"pl":"amdhsa","src":46,"more_decls":null}{"pl":"ps4","src":47,"more_decls":null}{"pl":"elfiamcu","src":48,"more_decls":null}{"pl":"tvos","src":49,"more_decls":null}{"pl":"watchos","src":50,"more_decls":null}{"pl":"mesa3d","src":51,"more_decls":null}{"pl":"contiki","src":52,"more_decls":null}{"pl":"amdpal","src":53,"more_decls":null}{"pl":"hermit","src":54,"more_decls":null}{"pl":"hurd","src":55,"more_decls":null}{"pl":"wasi","src":56,"more_decls":null}{"pl":"emscripten","src":57,"more_decls":null}{"pl":"uefi","src":58,"more_decls":null}{"pl":"opencl","src":59,"more_decls":null}{"pl":"glsl450","src":60,"more_decls":null}{"pl":"vulkan","src":61,"more_decls":null}{"pl":"other","src":62,"more_decls":null}{"pl":"pub fn isDarwin(tag: Tag) bool {\n    return switch (tag) {\n        .ios, .macos, .watchos, .tvos => true,\n        else => false,\n    };\n}","src":64,"more_decls":null}{"pl":"fn dynamicLibSuffix(tag: Tag) [:0]const u8","src":71,"more_decls":null}{"pl":"pub fn defaultVersionRange(tag: Tag) Os {\n    return .{\n        .tag = tag,\n        .version_range = VersionRange.default(tag),\n    };\n}","src":81,"more_decls":null}}{"doc_comment":"Based on NTDDI version constants from\nhttps://docs.microsoft.com/en-us/cpp/porting/modifying-winver-and-win32-winnt","pl":"pub const WindowsVersion = enum","src":91,"more_decls":{"pl":"nt4 = 0x04000000","src":92,"more_decls":null}{"pl":"win2k = 0x05000000","src":93,"more_decls":null}{"pl":"xp = 0x05010000","src":94,"more_decls":null}{"pl":"ws2003 = 0x05020000","src":95,"more_decls":null}{"pl":"vista = 0x06000000","src":96,"more_decls":null}{"pl":"win7 = 0x06010000","src":97,"more_decls":null}{"pl":"win8 = 0x06020000","src":98,"more_decls":null}{"pl":"win8_1 = 0x06030000","src":99,"more_decls":null}{"pl":"win10 = 0x0A000000","src":100,"more_decls":null}{"pl":"win10_th2 = 0x0A000001","src":101,"more_decls":null}{"pl":"win10_rs1 = 0x0A000002","src":102,"more_decls":null}{"pl":"win10_rs2 = 0x0A000003","src":103,"more_decls":null}{"pl":"win10_rs3 = 0x0A000004","src":104,"more_decls":null}{"pl":"win10_rs4 = 0x0A000005","src":105,"more_decls":null}{"pl":"win10_rs5 = 0x0A000006","src":106,"more_decls":null}{"pl":"win10_19h1 = 0x0A000007","src":107,"more_decls":null}{"pl":"win10_vb = 0x0A000008","src":108,"more_decls":null}{"pl":"win10_mn = 0x0A000009","src":109,"more_decls":null}{"pl":"win10_fe = 0x0A00000A","src":110,"more_decls":null}{"pl":"_","src":111,"more_decls":null}{"pl":"pub const Range = struct ","src":137,"more_decls":{"pl":"min: WindowsVersion","src":138,"more_decls":null}{"pl":"max: WindowsVersion","src":139,"more_decls":null}{"pl":"pub fn includesVersion(self: Range, ver: WindowsVersion) bool {\n    return @enumToInt(ver) >= @enumToInt(self.min) and @enumToInt(ver) <= @enumToInt(self.max);\n}","src":141,"more_decls":null}{"doc_comment":"Checks if system is guaranteed to be at least `version` or older than `version`.\nReturns `null` if a runtime check is required.","pl":"pub fn isAtLeast(self: Range, ver: WindowsVersion) ?bool {\n    if (@enumToInt(self.min) >= @enumToInt(ver)) return true;\n    if (@enumToInt(self.max) < @enumToInt(ver)) return false;\n    return null;\n}","src":147,"more_decls":null}}{"doc_comment":"Returns whether the first version `self` is newer (greater) than or equal to the second version `ver`.","pl":"pub fn isAtLeast(self: WindowsVersion, ver: WindowsVersion) bool {\n    return @enumToInt(self) >= @enumToInt(ver);\n}","src":133,"more_decls":null}{"doc_comment":"This function is defined to serialize a Zig source code representation of this\ntype, that, when parsed, will deserialize into the same data.","pl":"fn format(\n    self: WindowsVersion,\n    comptime fmt: []const u8,\n    options: std.fmt.FormatOptions,\n    out_stream: anytype,\n) !void","src":156,"more_decls":null}{"doc_comment":"Latest Windows version that the Zig Standard Library is aware of","pl":"const latest = WindowsVersion.win10_fe","src":114,"more_decls":null}{"doc_comment":"Compared against build numbers reported by the runtime to distinguish win10 versions,\nwhere 0x0A000000 + index corresponds to the WindowsVersion u32 value.","pl":"const known_win10_build_numbers = [_]u32{\n                10240, //win10 aka win10_th1\n                10586, //win10_th2\n                14393, //win10_rs1\n                15063, //win10_rs2\n                16299, //win10_rs3\n                17134, //win10_rs4\n                17763, //win10_rs5\n                18362, //win10_19h1\n                18363, //win10_vb aka win10_19h2\n                19041, //win10_mn aka win10_20h1\n                19042, //win10_fe aka win10_20h2\n            }","src":118,"more_decls":null}}{"pl":"pub const LinuxVersionRange = struct ","src":179,"more_decls":{"pl":"range: Version.Range","src":180,"more_decls":null}{"pl":"glibc: Version","src":181,"more_decls":null}{"pl":"pub fn includesVersion(self: LinuxVersionRange, ver: Version) bool {\n    return self.range.includesVersion(ver);\n}","src":183,"more_decls":null}{"doc_comment":"Checks if system is guaranteed to be at least `version` or older than `version`.\nReturns `null` if a runtime check is required.","pl":"pub fn isAtLeast(self: LinuxVersionRange, ver: Version) ?bool {\n    return self.range.isAtLeast(ver);\n}","src":189,"more_decls":null}}{"doc_comment":"The version ranges here represent the minimum OS version to be supported\nand the maximum OS version to be supported. The default values represent\nthe range that the Zig Standard Library bases its abstractions on.\n\nThe minimum version of the range is the main setting to tweak for a target.\nUsually, the maximum target OS version will remain the default, which is\nthe latest released version of the OS.\n\nTo test at compile time if the target is guaranteed to support a given OS feature,\none should check that the minimum version of the range is greater than or equal to\nthe version the feature was introduced in.\n\nTo test at compile time if the target certainly will not support a given OS feature,\none should check that the maximum version of the range is less than the version the\nfeature was introduced in.\n\nIf neither of these cases apply, a runtime check should be used to determine if the\ntarget supports a given OS feature.\n\nBinaries built with a given maximum version will continue to function on newer operating system\nversions. However, such a binary may not take full advantage of the newer operating system APIs.\n\nSee `Os.isAtLeast`.","pl":"pub const VersionRange = union ","src":217,"more_decls":{"pl":"none: void","src":218,"more_decls":null}{"pl":"semver: Version.Range","src":219,"more_decls":null}{"pl":"linux: LinuxVersionRange","src":220,"more_decls":null}{"pl":"windows: WindowsVersion.Range","src":221,"more_decls":null}{"doc_comment":"The default `VersionRange` represents the range that the Zig Standard Library\nbases its abstractions on.","pl":"fn default(tag: Tag) VersionRange","src":225,"more_decls":null}}{"pl":"pub const TaggedVersionRange = union(enum) ","src":328,"more_decls":{"pl":"none: void","src":329,"more_decls":null}{"pl":"semver: Version.Range","src":330,"more_decls":null}{"pl":"linux: LinuxVersionRange","src":331,"more_decls":null}{"pl":"windows: WindowsVersion.Range","src":332,"more_decls":null}}{"doc_comment":"Provides a tagged union. `Target` does not store the tag because it is\nredundant with the OS tag; this function abstracts that part away.","pl":"fn getVersionRange(self: Os) TaggedVersionRange","src":337,"more_decls":null}{"doc_comment":"Checks if system is guaranteed to be at least `version` or older than `version`.\nReturns `null` if a runtime check is required.","pl":"fn isAtLeast(self: Os, comptime tag: Tag, version: anytype) ?bool","src":358,"more_decls":null}{"doc_comment":"On Darwin, we always link libSystem which contains libc.\nSimilarly on FreeBSD and NetBSD we always link system libc\nsince this is the stable syscall interface.","pl":"fn requiresLibC(os: Os) bool","src":371,"more_decls":null}}{"pl":"pub const Abi = enum ","src":437,"more_decls":{"pl":"none","src":438,"more_decls":null}{"pl":"gnu","src":439,"more_decls":null}{"pl":"gnuabin32","src":440,"more_decls":null}{"pl":"gnuabi64","src":441,"more_decls":null}{"pl":"gnueabi","src":442,"more_decls":null}{"pl":"gnueabihf","src":443,"more_decls":null}{"pl":"gnux32","src":444,"more_decls":null}{"pl":"code16","src":445,"more_decls":null}{"pl":"eabi","src":446,"more_decls":null}{"pl":"eabihf","src":447,"more_decls":null}{"pl":"android","src":448,"more_decls":null}{"pl":"musl","src":449,"more_decls":null}{"pl":"musleabi","src":450,"more_decls":null}{"pl":"musleabihf","src":451,"more_decls":null}{"pl":"msvc","src":452,"more_decls":null}{"pl":"itanium","src":453,"more_decls":null}{"pl":"cygnus","src":454,"more_decls":null}{"pl":"coreclr","src":455,"more_decls":null}{"pl":"simulator","src":456,"more_decls":null}{"pl":"macabi","src":457,"more_decls":null}{"pl":"fn default(arch: Cpu.Arch, target_os: Os) Abi","src":459,"more_decls":null}{"pl":"pub fn isGnu(abi: Abi) bool {\n    return switch (abi) {\n        .gnu, .gnuabin32, .gnuabi64, .gnueabi, .gnueabihf, .gnux32 => true,\n        else => false,\n    };\n}","src":512,"more_decls":null}{"pl":"pub fn isMusl(abi: Abi) bool {\n    return switch (abi) {\n        .musl, .musleabi, .musleabihf => true,\n        else => false,\n    };\n}","src":519,"more_decls":null}{"pl":"fn floatAbi(abi: Abi) FloatAbi","src":526,"more_decls":null}}{"pl":"pub const ObjectFormat = enum ","src":537,"more_decls":{"pl":"coff","src":538,"more_decls":null}{"pl":"pe","src":539,"more_decls":null}{"pl":"elf","src":540,"more_decls":null}{"pl":"macho","src":541,"more_decls":null}{"pl":"wasm","src":542,"more_decls":null}{"pl":"c","src":543,"more_decls":null}{"pl":"spirv","src":544,"more_decls":null}{"pl":"hex","src":545,"more_decls":null}{"pl":"raw","src":546,"more_decls":null}}{"pl":"pub const SubSystem = enum ","src":549,"more_decls":{"pl":"Console","src":550,"more_decls":null}{"pl":"Windows","src":551,"more_decls":null}{"pl":"Posix","src":552,"more_decls":null}{"pl":"Native","src":553,"more_decls":null}{"pl":"EfiApplication","src":554,"more_decls":null}{"pl":"EfiBootServiceDriver","src":555,"more_decls":null}{"pl":"EfiRom","src":556,"more_decls":null}{"pl":"EfiRuntimeDriver","src":557,"more_decls":null}}{"pl":"pub const Cpu = struct ","src":560,"more_decls":{"doc_comment":"Architecture","pl":"arch: Arch","src":562,"more_decls":null}{"doc_comment":"The CPU model to target. It has a set of features\nwhich are overridden with the `features` field.","pl":"model: *const Model","src":566,"more_decls":null}{"doc_comment":"An explicit list of the entire CPU feature set. It may differ from the specific CPU model's features.","pl":"features: Feature.Set","src":569,"more_decls":null}{"pl":"pub const Feature = struct ","src":571,"more_decls":{"doc_comment":"The bit index into `Set`. Has a default value of `undefined` because the canonical\nstructures are populated via comptime logic.","pl":"index: Set.Index = undefined","src":574,"more_decls":null}{"doc_comment":"Has a default value of `undefined` because the canonical\nstructures are populated via comptime logic.","pl":"name: []const u8 = undefined","src":578,"more_decls":null}{"doc_comment":"If this corresponds to an LLVM-recognized feature, this will be populated;\notherwise null.","pl":"llvm_name: ?[:0]const u8","src":582,"more_decls":null}{"doc_comment":"Human-friendly UTF-8 text.","pl":"description: []const u8","src":585,"more_decls":null}{"doc_comment":"Sparse `Set` of features this depends on.","pl":"dependencies: Set","src":588,"more_decls":null}{"doc_comment":"A bit set of all the features.","pl":"pub const Set = struct ","src":591,"more_decls":{"pl":"ints: [usize_count]usize","src":592,"more_decls":null}{"pl":"pub fn empty_workaround() Set {\n    return Set{ .ints = [1]usize{0} ** usize_count };\n}","src":601,"more_decls":null}{"pl":"pub fn isEmpty(set: Set) bool {\n    return for (set.ints) |x| {\n        if (x != 0) break false;\n    } else true;\n}","src":605,"more_decls":null}{"pl":"pub fn isEnabled(set: Set, arch_feature_index: Index) bool {\n    const usize_index = arch_feature_index / @bitSizeOf(usize);\n    const bit_index = @intCast(ShiftInt, arch_feature_index % @bitSizeOf(usize));\n    return (set.ints[usize_index] & (@as(usize, 1) << bit_index)) != 0;\n}","src":611,"more_decls":null}{"doc_comment":"Adds the specified feature but not its dependencies.","pl":"pub fn addFeature(set: *Set, arch_feature_index: Index) void {\n    const usize_index = arch_feature_index / @bitSizeOf(usize);\n    const bit_index = @intCast(ShiftInt, arch_feature_index % @bitSizeOf(usize));\n    set.ints[usize_index] |= @as(usize, 1) << bit_index;\n}","src":618,"more_decls":null}{"doc_comment":"Adds the specified feature set but not its dependencies.","pl":"pub fn addFeatureSet(set: *Set, other_set: Set) void {\n    set.ints = @as(std.meta.Vector(usize_count, usize), set.ints) |\n        @as(std.meta.Vector(usize_count, usize), other_set.ints);\n}","src":625,"more_decls":null}{"doc_comment":"Removes the specified feature but not its dependents.","pl":"pub fn removeFeature(set: *Set, arch_feature_index: Index) void {\n    const usize_index = arch_feature_index / @bitSizeOf(usize);\n    const bit_index = @intCast(ShiftInt, arch_feature_index % @bitSizeOf(usize));\n    set.ints[usize_index] &= ~(@as(usize, 1) << bit_index);\n}","src":631,"more_decls":null}{"doc_comment":"Removes the specified feature but not its dependents.","pl":"pub fn removeFeatureSet(set: *Set, other_set: Set) void {\n    set.ints = @as(std.meta.Vector(usize_count, usize), set.ints) &\n        ~@as(std.meta.Vector(usize_count, usize), other_set.ints);\n}","src":638,"more_decls":null}{"pl":"fn populateDependencies(set: *Set, all_features_list: []const Cpu.Feature) void","src":643,"more_decls":null}{"pl":"pub fn asBytes(set: *const Set) *const [byte_count]u8 {\n    return @ptrCast(*const [byte_count]u8, &set.ints);\n}","src":660,"more_decls":null}{"pl":"pub fn eql(set: Set, other: Set) bool {\n    return mem.eql(usize, &set.ints, &other.ints);\n}","src":664,"more_decls":null}{"pl":"const needed_bit_count = 168","src":594,"more_decls":null}{"pl":"const byte_count = (needed_bit_count + 7) / 8","src":595,"more_decls":null}{"pl":"const usize_count = (byte_count + (@sizeOf(usize) - 1)) / @sizeOf(usize)","src":596,"more_decls":null}{"pl":"const Index = std.math.Log2Int(std.meta.Int(.unsigned, usize_count * @bitSizeOf(usize)))","src":597,"more_decls":null}{"pl":"const ShiftInt = std.math.Log2Int(usize)","src":598,"more_decls":null}{"pl":"const empty = Set{ .ints = [1]usize{0} ** usize_count }","src":600,"more_decls":null}}{"pl":"fn feature_set_fns(comptime F: type) type","sub_container_type":"struct ","src":669,"more_decls":{"doc_comment":"Populates only the feature bits specified.","pl":"fn featureSet(features: []const F) Set","src":672,"more_decls":null}{"doc_comment":"Returns true if the specified feature is enabled.","pl":"pub fn featureSetHas(set: Set, feature: F) bool {\n    return set.isEnabled(@enumToInt(feature));\n}","src":681,"more_decls":null}{"doc_comment":"Returns true if any specified feature is enabled.","pl":"fn featureSetHasAny(set: Set, features: anytype) bool","src":686,"more_decls":null}{"doc_comment":"Returns true if every specified feature is enabled.","pl":"fn featureSetHasAll(set: Set, features: anytype) bool","src":695,"more_decls":null}}}{"pl":"pub const Arch = enum ","src":706,"more_decls":{"pl":"arm","src":707,"more_decls":null}{"pl":"armeb","src":708,"more_decls":null}{"pl":"aarch64","src":709,"more_decls":null}{"pl":"aarch64_be","src":710,"more_decls":null}{"pl":"aarch64_32","src":711,"more_decls":null}{"pl":"arc","src":712,"more_decls":null}{"pl":"avr","src":713,"more_decls":null}{"pl":"bpfel","src":714,"more_decls":null}{"pl":"bpfeb","src":715,"more_decls":null}{"pl":"hexagon","src":716,"more_decls":null}{"pl":"mips","src":717,"more_decls":null}{"pl":"mipsel","src":718,"more_decls":null}{"pl":"mips64","src":719,"more_decls":null}{"pl":"mips64el","src":720,"more_decls":null}{"pl":"msp430","src":721,"more_decls":null}{"pl":"powerpc","src":722,"more_decls":null}{"pl":"powerpc64","src":723,"more_decls":null}{"pl":"powerpc64le","src":724,"more_decls":null}{"pl":"r600","src":725,"more_decls":null}{"pl":"amdgcn","src":726,"more_decls":null}{"pl":"riscv32","src":727,"more_decls":null}{"pl":"riscv64","src":728,"more_decls":null}{"pl":"sparc","src":729,"more_decls":null}{"pl":"sparcv9","src":730,"more_decls":null}{"pl":"sparcel","src":731,"more_decls":null}{"pl":"s390x","src":732,"more_decls":null}{"pl":"tce","src":733,"more_decls":null}{"pl":"tcele","src":734,"more_decls":null}{"pl":"thumb","src":735,"more_decls":null}{"pl":"thumbeb","src":736,"more_decls":null}{"pl":"i386","src":737,"more_decls":null}{"pl":"x86_64","src":738,"more_decls":null}{"pl":"xcore","src":739,"more_decls":null}{"pl":"nvptx","src":740,"more_decls":null}{"pl":"nvptx64","src":741,"more_decls":null}{"pl":"le32","src":742,"more_decls":null}{"pl":"le64","src":743,"more_decls":null}{"pl":"amdil","src":744,"more_decls":null}{"pl":"amdil64","src":745,"more_decls":null}{"pl":"hsail","src":746,"more_decls":null}{"pl":"hsail64","src":747,"more_decls":null}{"pl":"spir","src":748,"more_decls":null}{"pl":"spir64","src":749,"more_decls":null}{"pl":"kalimba","src":750,"more_decls":null}{"pl":"shave","src":751,"more_decls":null}{"pl":"lanai","src":752,"more_decls":null}{"pl":"wasm32","src":753,"more_decls":null}{"pl":"wasm64","src":754,"more_decls":null}{"pl":"renderscript32","src":755,"more_decls":null}{"pl":"renderscript64","src":756,"more_decls":null}{"pl":"ve","src":757,"more_decls":null}{"pl":"spu_2","src":760,"more_decls":null}{"pl":"spirv32","src":761,"more_decls":null}{"pl":"spirv64","src":762,"more_decls":null}{"pl":"pub fn isARM(arch: Arch) bool {\n    return switch (arch) {\n        .arm, .armeb => true,\n        else => false,\n    };\n}","src":764,"more_decls":null}{"pl":"pub fn isThumb(arch: Arch) bool {\n    return switch (arch) {\n        .thumb, .thumbeb => true,\n        else => false,\n    };\n}","src":771,"more_decls":null}{"pl":"pub fn isWasm(arch: Arch) bool {\n    return switch (arch) {\n        .wasm32, .wasm64 => true,\n        else => false,\n    };\n}","src":778,"more_decls":null}{"pl":"pub fn isRISCV(arch: Arch) bool {\n    return switch (arch) {\n        .riscv32, .riscv64 => true,\n        else => false,\n    };\n}","src":785,"more_decls":null}{"pl":"pub fn isMIPS(arch: Arch) bool {\n    return switch (arch) {\n        .mips, .mipsel, .mips64, .mips64el => true,\n        else => false,\n    };\n}","src":792,"more_decls":null}{"pl":"pub fn isPPC64(arch: Arch) bool {\n    return switch (arch) {\n        .powerpc64, .powerpc64le => true,\n        else => false,\n    };\n}","src":799,"more_decls":null}{"pl":"pub fn isSPARC(arch: Arch) bool {\n    return switch (arch) {\n        .sparc, .sparcel, .sparcv9 => true,\n        else => false,\n    };\n}","src":806,"more_decls":null}{"pl":"fn parseCpuModel(arch: Arch, cpu_name: []const u8) !*const Cpu.Model","src":813,"more_decls":null}{"pl":"fn toElfMachine(arch: Arch) std.elf.EM","src":822,"more_decls":null}{"pl":"fn toCoffMachine(arch: Arch) std.coff.MachineType","src":881,"more_decls":null}{"pl":"fn endian(arch: Arch) builtin.Endian","src":940,"more_decls":null}{"pl":"fn ptrBitWidth(arch: Arch) u16","src":1003,"more_decls":null}{"doc_comment":"Returns a name that matches the lib/std/target/* directory name.","pl":"fn genericName(arch: Arch) []const u8","src":1068,"more_decls":null}{"doc_comment":"All CPU features Zig is aware of, sorted lexicographically by name.","pl":"fn allFeaturesList(arch: Arch) []const Cpu.Feature","src":1091,"more_decls":null}{"doc_comment":"All processors Zig is aware of, sorted lexicographically by name.","pl":"fn allCpuModels(arch: Arch) []const *const Cpu.Model","src":1114,"more_decls":null}}{"pl":"pub const Model = struct ","src":1146,"more_decls":{"pl":"name: []const u8","src":1147,"more_decls":null}{"pl":"llvm_name: ?[:0]const u8","src":1148,"more_decls":null}{"pl":"features: Feature.Set","src":1149,"more_decls":null}{"pl":"fn toCpu(model: *const Model, arch: Arch) Cpu","src":1151,"more_decls":null}{"pl":"fn generic(arch: Arch) *const Model","src":1161,"more_decls":null}{"pl":"fn baseline(arch: Arch) *const Model","src":1196,"more_decls":null}}{"doc_comment":"The \"default\" set of CPU features for cross-compiling. A conservative set\nof features that is expected to be supported on most available hardware.","pl":"pub fn baseline(arch: Arch) Cpu {\n    return Model.baseline(arch).toCpu(arch);\n}","src":1211,"more_decls":null}}{"pl":"pub const FloatAbi = enum ","src":1353,"more_decls":{"pl":"hard","src":1354,"more_decls":null}{"pl":"soft","src":1355,"more_decls":null}{"pl":"soft_fp","src":1356,"more_decls":null}}{"pl":"pub const DynamicLinker = struct ","src":1385,"more_decls":{"doc_comment":"Contains the memory used to store the dynamic linker path. This field should\nnot be used directly. See `get` and `set`. This field exists so that this API requires no allocator.","pl":"buffer: [255]u8 = undefined","src":1388,"more_decls":null}{"doc_comment":"Used to construct the dynamic linker path. This field should not be used\ndirectly. See `get` and `set`.","pl":"max_byte: ?u8 = null","src":1392,"more_decls":null}{"doc_comment":"Asserts that the length is less than or equal to 255 bytes.","pl":"pub fn init(dl_or_null: ?[]const u8) DynamicLinker {\n    var result: DynamicLinker = undefined;\n    result.set(dl_or_null);\n    return result;\n}","src":1395,"more_decls":null}{"doc_comment":"The returned memory has the same lifetime as the `DynamicLinker`.","pl":"pub fn get(self: *const DynamicLinker) ?[]const u8 {\n    const m: usize = self.max_byte orelse return null;\n    return self.buffer[0 .. m + 1];\n}","src":1402,"more_decls":null}{"doc_comment":"Asserts that the length is less than or equal to 255 bytes.","pl":"fn set(self: *DynamicLinker, dl_or_null: ?[]const u8) void","src":1408,"more_decls":null}}{"pl":"pub fn zigTriple(self: Target, allocator: *mem.Allocator) ![]u8 {\n    return std.zig.CrossTarget.fromTarget(self).zigTriple(allocator);\n}","src":1224,"more_decls":null}{"pl":"pub fn linuxTripleSimple(allocator: *mem.Allocator, cpu_arch: Cpu.Arch, os_tag: Os.Tag, abi: Abi) ![]u8 {\n    return std.fmt.allocPrint(allocator, \"{s}-{s}-{s}\", .{ @tagName(cpu_arch), @tagName(os_tag), @tagName(abi) });\n}","src":1228,"more_decls":null}{"pl":"pub fn linuxTriple(self: Target, allocator: *mem.Allocator) ![]u8 {\n    return linuxTripleSimple(allocator, self.cpu.arch, self.os.tag, self.abi);\n}","src":1232,"more_decls":null}{"pl":"fn oFileExt_cpu_arch_abi(cpu_arch: Cpu.Arch, abi: Abi) [:0]const u8","src":1236,"more_decls":null}{"pl":"pub fn oFileExt(self: Target) [:0]const u8 {\n    return oFileExt_cpu_arch_abi(self.cpu.arch, self.abi);\n}","src":1246,"more_decls":null}{"pl":"fn exeFileExtSimple(cpu_arch: Cpu.Arch, os_tag: Os.Tag) [:0]const u8","src":1250,"more_decls":null}{"pl":"pub fn exeFileExt(self: Target) [:0]const u8 {\n    return exeFileExtSimple(self.cpu.arch, self.os.tag);\n}","src":1262,"more_decls":null}{"pl":"fn staticLibSuffix_cpu_arch_abi(cpu_arch: Cpu.Arch, abi: Abi) [:0]const u8","src":1266,"more_decls":null}{"pl":"pub fn staticLibSuffix(self: Target) [:0]const u8 {\n    return staticLibSuffix_cpu_arch_abi(self.cpu.arch, self.abi);\n}","src":1276,"more_decls":null}{"pl":"pub fn dynamicLibSuffix(self: Target) [:0]const u8 {\n    return self.os.tag.dynamicLibSuffix();\n}","src":1280,"more_decls":null}{"pl":"fn libPrefix_cpu_arch_abi(cpu_arch: Cpu.Arch, abi: Abi) [:0]const u8","src":1284,"more_decls":null}{"pl":"pub fn libPrefix(self: Target) [:0]const u8 {\n    return libPrefix_cpu_arch_abi(self.cpu.arch, self.abi);\n}","src":1294,"more_decls":null}{"pl":"fn getObjectFormatSimple(os_tag: Os.Tag, cpu_arch: Cpu.Arch) ObjectFormat","src":1298,"more_decls":null}{"pl":"pub fn getObjectFormat(self: Target) ObjectFormat {\n    return getObjectFormatSimple(self.os.tag, self.cpu.arch);\n}","src":1310,"more_decls":null}{"pl":"pub fn isMinGW(self: Target) bool {\n    return self.os.tag == .windows and self.isGnu();\n}","src":1314,"more_decls":null}{"pl":"pub fn isGnu(self: Target) bool {\n    return self.abi.isGnu();\n}","src":1318,"more_decls":null}{"pl":"pub fn isMusl(self: Target) bool {\n    return self.abi.isMusl();\n}","src":1322,"more_decls":null}{"pl":"pub fn isAndroid(self: Target) bool {\n    return switch (self.abi) {\n        .android => true,\n        else => false,\n    };\n}","src":1326,"more_decls":null}{"pl":"pub fn isWasm(self: Target) bool {\n    return self.cpu.arch.isWasm();\n}","src":1333,"more_decls":null}{"pl":"pub fn isDarwin(self: Target) bool {\n    return self.os.tag.isDarwin();\n}","src":1337,"more_decls":null}{"pl":"pub fn isGnuLibC_os_tag_abi(os_tag: Os.Tag, abi: Abi) bool {\n    return os_tag == .linux and abi.isGnu();\n}","src":1341,"more_decls":null}{"pl":"pub fn isGnuLibC(self: Target) bool {\n    return isGnuLibC_os_tag_abi(self.os.tag, self.abi);\n}","src":1345,"more_decls":null}{"pl":"pub fn supportsNewStackCall(self: Target) bool {\n    return !self.cpu.arch.isWasm();\n}","src":1349,"more_decls":null}{"pl":"pub fn getFloatAbi(self: Target) FloatAbi {\n    return self.abi.floatAbi();\n}","src":1359,"more_decls":null}{"pl":"fn hasDynamicLinker(self: Target) bool","src":1363,"more_decls":null}{"pl":"fn standardDynamicLinkerPath(self: Target) DynamicLinker","src":1418,"more_decls":null}{"doc_comment":"Return whether or not the given host target is capable of executing natively executables\nof the other target.","pl":"fn canExecBinariesOf(host_target: Target, binary_target: Target) bool","src":1596,"more_decls":null}{"pl":"const aarch64 = @import(\"target/aarch64.zig\")","src":420,"more_decls":null}{"pl":"const amdgpu = @import(\"target/amdgpu.zig\")","src":421,"more_decls":null}{"pl":"const arm = @import(\"target/arm.zig\")","src":422,"more_decls":null}{"pl":"const avr = @import(\"target/avr.zig\")","src":423,"more_decls":null}{"pl":"const bpf = @import(\"target/bpf.zig\")","src":424,"more_decls":null}{"pl":"const hexagon = @import(\"target/hexagon.zig\")","src":425,"more_decls":null}{"pl":"const mips = @import(\"target/mips.zig\")","src":426,"more_decls":null}{"pl":"const msp430 = @import(\"target/msp430.zig\")","src":427,"more_decls":null}{"pl":"const nvptx = @import(\"target/nvptx.zig\")","src":428,"more_decls":null}{"pl":"const powerpc = @import(\"target/powerpc.zig\")","src":429,"more_decls":null}{"pl":"const riscv = @import(\"target/riscv.zig\")","src":430,"more_decls":null}{"pl":"const sparc = @import(\"target/sparc.zig\")","src":431,"more_decls":null}{"pl":"const spirv = @import(\"target/spirv.zig\")","src":432,"more_decls":null}{"pl":"const systemz = @import(\"target/systemz.zig\")","src":433,"more_decls":null}{"pl":"const wasm = @import(\"target/wasm.zig\")","src":434,"more_decls":null}{"pl":"const x86 = @import(\"target/x86.zig\")","src":435,"more_decls":null}{"pl":"const current = Target{\n        .cpu = builtin.cpu,\n        .os = builtin.os,\n        .abi = builtin.abi,\n    }","src":1216,"more_decls":null}{"pl":"const stack_align = 16","src":1222,"more_decls":null}}]