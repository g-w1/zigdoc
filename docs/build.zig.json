[{"pl":"pub const Builder = struct ","src":31,"more_decls":{"pl":"install_tls: TopLevelStep","src":32,"more_decls":null}{"pl":"uninstall_tls: TopLevelStep","src":33,"more_decls":null}{"pl":"allocator: *Allocator","src":34,"more_decls":null}{"pl":"user_input_options: UserInputOptionsMap","src":35,"more_decls":null}{"pl":"available_options_map: AvailableOptionsMap","src":36,"more_decls":null}{"pl":"available_options_list: ArrayList(AvailableOption)","src":37,"more_decls":null}{"pl":"verbose: bool","src":38,"more_decls":null}{"pl":"verbose_tokenize: bool","src":39,"more_decls":null}{"pl":"verbose_ast: bool","src":40,"more_decls":null}{"pl":"verbose_link: bool","src":41,"more_decls":null}{"pl":"verbose_cc: bool","src":42,"more_decls":null}{"pl":"verbose_ir: bool","src":43,"more_decls":null}{"pl":"verbose_llvm_ir: bool","src":44,"more_decls":null}{"pl":"verbose_cimport: bool","src":45,"more_decls":null}{"pl":"verbose_llvm_cpu_features: bool","src":46,"more_decls":null}{"pl":"color: enum { auto, on, off } = .auto","src":47,"more_decls":null}{"pl":"invalid_user_input: bool","src":48,"more_decls":null}{"pl":"zig_exe: []const u8","src":49,"more_decls":null}{"pl":"default_step: *Step","src":50,"more_decls":null}{"pl":"env_map: *BufMap","src":51,"more_decls":null}{"pl":"top_level_steps: ArrayList(*TopLevelStep)","src":52,"more_decls":null}{"pl":"install_prefix: []const u8","src":53,"more_decls":null}{"pl":"dest_dir: ?[]const u8","src":54,"more_decls":null}{"pl":"lib_dir: []const u8","src":55,"more_decls":null}{"pl":"exe_dir: []const u8","src":56,"more_decls":null}{"pl":"h_dir: []const u8","src":57,"more_decls":null}{"pl":"install_path: []const u8","src":58,"more_decls":null}{"pl":"search_prefixes: ArrayList([]const u8)","src":59,"more_decls":null}{"pl":"installed_files: ArrayList(InstalledFile)","src":60,"more_decls":null}{"pl":"build_root: []const u8","src":61,"more_decls":null}{"pl":"cache_root: []const u8","src":62,"more_decls":null}{"pl":"global_cache_root: []const u8","src":63,"more_decls":null}{"pl":"release_mode: ?builtin.Mode","src":64,"more_decls":null}{"pl":"is_release: bool","src":65,"more_decls":null}{"pl":"override_lib_dir: ?[]const u8","src":66,"more_decls":null}{"pl":"vcpkg_root: VcpkgRoot","src":67,"more_decls":null}{"pl":"pkg_config_pkg_list: ?(PkgConfigError![]const PkgConfigPkg) = null","src":68,"more_decls":null}{"pl":"args: ?[][]const u8 = null","src":69,"more_decls":null}{"pl":"pub const PkgConfigPkg = struct ","src":78,"more_decls":{"pl":"name: []const u8","src":79,"more_decls":null}{"pl":"desc: []const u8","src":80,"more_decls":null}}{"pl":"pub const CStd = enum ","src":83,"more_decls":{"pl":"C89","src":84,"more_decls":null}{"pl":"C99","src":85,"more_decls":null}{"pl":"C11","src":86,"more_decls":null}}{"pl":"pub const StandardTargetOptionsArgs = struct ","src":669,"more_decls":{"pl":"whitelist: ?[]const CrossTarget = null","src":670,"more_decls":null}{"pl":"default_target: CrossTarget = CrossTarget{}","src":672,"more_decls":null}}{"pl":"fn create(\n    allocator: *Allocator,\n    zig_exe: []const u8,\n    build_root: []const u8,\n    cache_root: []const u8,\n    global_cache_root: []const u8,\n) !*Builder","src":124,"more_decls":null}{"pl":"pub fn destroy(self: *Builder) void {\n    self.env_map.deinit();\n    self.top_level_steps.deinit();\n    self.allocator.destroy(self);\n}","src":185,"more_decls":null}{"doc_comment":"This function is intended to be called by std/special/build_runner.zig, not a build.zig file.","pl":"fn resolveInstallPrefix(self: *Builder, install_prefix: ?[]const u8) void","src":192,"more_decls":null}{"pl":"fn addExecutable(self: *Builder, name: []const u8, root_src: ?[]const u8) *LibExeObjStep","src":205,"more_decls":null}{"pl":"fn addExecutableFromWriteFileStep(\n    self: *Builder,\n    name: []const u8,\n    wfs: *WriteFileStep,\n    basename: []const u8,\n) *LibExeObjStep","src":214,"more_decls":null}{"pl":"fn addExecutableSource(\n    self: *Builder,\n    name: []const u8,\n    root_src: ?FileSource,\n) *LibExeObjStep","src":228,"more_decls":null}{"pl":"pub fn addObject(self: *Builder, name: []const u8, root_src: ?[]const u8) *LibExeObjStep {\n    const root_src_param = if (root_src) |p| @as(FileSource, .{ .path = p }) else null;\n    return LibExeObjStep.createObject(self, name, root_src_param);\n}","src":236,"more_decls":null}{"pl":"fn addObjectFromWriteFileStep(\n    self: *Builder,\n    name: []const u8,\n    wfs: *WriteFileStep,\n    basename: []const u8,\n) *LibExeObjStep","src":241,"more_decls":null}{"pl":"fn addSharedLibrary(\n    self: *Builder,\n    name: []const u8,\n    root_src: ?[]const u8,\n    kind: LibExeObjStep.SharedLibKind,\n) *LibExeObjStep","src":255,"more_decls":null}{"pl":"fn addSharedLibraryFromWriteFileStep(\n    self: *Builder,\n    name: []const u8,\n    wfs: *WriteFileStep,\n    basename: []const u8,\n    kind: LibExeObjStep.SharedLibKind,\n) *LibExeObjStep","src":265,"more_decls":null}{"pl":"pub fn addStaticLibrary(self: *Builder, name: []const u8, root_src: ?[]const u8) *LibExeObjStep {\n    const root_src_param = if (root_src) |p| @as(FileSource, .{ .path = p }) else null;\n    return LibExeObjStep.createStaticLibrary(self, name, root_src_param);\n}","src":280,"more_decls":null}{"pl":"fn addStaticLibraryFromWriteFileStep(\n    self: *Builder,\n    name: []const u8,\n    wfs: *WriteFileStep,\n    basename: []const u8,\n) *LibExeObjStep","src":285,"more_decls":null}{"pl":"pub fn addTest(self: *Builder, root_src: []const u8) *LibExeObjStep {\n    return LibExeObjStep.createTest(self, \"test\", .{ .path = root_src });\n}","src":299,"more_decls":null}{"pl":"fn addTestFromWriteFileStep(\n    self: *Builder,\n    wfs: *WriteFileStep,\n    basename: []const u8,\n) *LibExeObjStep","src":303,"more_decls":null}{"pl":"pub fn addAssemble(self: *Builder, name: []const u8, src: []const u8) *LibExeObjStep {\n    const obj_step = LibExeObjStep.createObject(self, name, null);\n    obj_step.addAssemblyFile(src);\n    return obj_step;\n}","src":316,"more_decls":null}{"doc_comment":"Initializes a RunStep with argv, which must at least have the path to the\nexecutable. More command line arguments can be added with `addArg`,\n`addArgs`, and `addArtifactArg`.\nBe careful using this function, as it introduces a system dependency.\nTo run an executable built with zig build, see `LibExeObjStep.run`.","pl":"pub fn addSystemCommand(self: *Builder, argv: []const []const u8) *RunStep {\n    assert(argv.len >= 1);\n    const run_step = RunStep.create(self, self.fmt(\"run {s}\", .{argv[0]}));\n    run_step.addArgs(argv);\n    return run_step;\n}","src":327,"more_decls":null}{"pl":"pub fn dupe(self: *Builder, bytes: []const u8) []u8 {\n    return self.allocator.dupe(u8, bytes) catch unreachable;\n}","src":334,"more_decls":null}{"pl":"fn dupeStrings(self: *Builder, strings: []const []const u8) [][]u8","src":338,"more_decls":null}{"pl":"fn dupePath(self: *Builder, bytes: []const u8) []u8","src":346,"more_decls":null}{"pl":"fn dupePkg(self: *Builder, package: Pkg) Pkg","src":357,"more_decls":null}{"pl":"pub fn addWriteFile(self: *Builder, file_path: []const u8, data: []const u8) *WriteFileStep {\n    const write_file_step = self.addWriteFiles();\n    write_file_step.add(file_path, data);\n    return write_file_step;\n}","src":374,"more_decls":null}{"pl":"pub fn addWriteFiles(self: *Builder) *WriteFileStep {\n    const write_file_step = self.allocator.create(WriteFileStep) catch unreachable;\n    write_file_step.* = WriteFileStep.init(self);\n    return write_file_step;\n}","src":380,"more_decls":null}{"pl":"pub fn addLog(self: *Builder, comptime format: []const u8, args: anytype) *LogStep {\n    const data = self.fmt(format, args);\n    const log_step = self.allocator.create(LogStep) catch unreachable;\n    log_step.* = LogStep.init(self, data);\n    return log_step;\n}","src":386,"more_decls":null}{"pl":"pub fn addRemoveDirTree(self: *Builder, dir_path: []const u8) *RemoveDirStep {\n    const remove_dir_step = self.allocator.create(RemoveDirStep) catch unreachable;\n    remove_dir_step.* = RemoveDirStep.init(self, dir_path);\n    return remove_dir_step;\n}","src":393,"more_decls":null}{"pl":"pub fn addFmt(self: *Builder, paths: []const []const u8) *FmtStep {\n    return FmtStep.create(self, paths);\n}","src":399,"more_decls":null}{"pl":"pub fn addTranslateC(self: *Builder, source: FileSource) *TranslateCStep {\n    return TranslateCStep.create(self, source);\n}","src":403,"more_decls":null}{"pl":"fn version(self: *const Builder, major: u32, minor: u32, patch: u32) LibExeObjStep.SharedLibKind","src":407,"more_decls":null}{"pl":"fn make(self: *Builder, step_names: []const []const u8) !void","src":417,"more_decls":null}{"pl":"pub fn getInstallStep(self: *Builder) *Step {\n    return &self.install_tls.step;\n}","src":437,"more_decls":null}{"pl":"pub fn getUninstallStep(self: *Builder) *Step {\n    return &self.uninstall_tls.step;\n}","src":441,"more_decls":null}{"pl":"fn option(self: *Builder, comptime T: type, name_raw: []const u8, description_raw: []const u8) ?T","src":491,"more_decls":null}{"pl":"fn step(self: *Builder, name: []const u8, description: []const u8) *Step","src":622,"more_decls":null}{"doc_comment":"This provides the -Drelease option to the build user and does not give them the choice.","pl":"fn setPreferredReleaseMode(self: *Builder, mode: builtin.Mode) void","src":633,"more_decls":null}{"doc_comment":"If you call this without first calling `setPreferredReleaseMode` then it gives the build user\nthe choice of what kind of release.","pl":"fn standardReleaseOptions(self: *Builder) builtin.Mode","src":644,"more_decls":null}{"doc_comment":"Exposes standard `zig build` options for choosing a target.","pl":"fn standardTargetOptions(self: *Builder, args: StandardTargetOptionsArgs) CrossTarget","src":676,"more_decls":null}{"pl":"fn addUserInputOption(self: *Builder, name_raw: []const u8, value_raw: []const u8) !bool","src":763,"more_decls":null}{"pl":"fn addUserInputFlag(self: *Builder, name_raw: []const u8) !bool","src":806,"more_decls":null}{"pl":"fn typeIdName(id: TypeId) []const u8","src":851,"more_decls":null}{"pl":"fn validateUserInputDidItFail(self: *Builder) bool","src":862,"more_decls":null}{"pl":"pub fn spawnChild(self: *Builder, argv: []const []const u8) !void {\n    return self.spawnChildEnvMap(null, self.env_map, argv);\n}","src":876,"more_decls":null}{"pl":"pub fn makePath(self: *Builder, path: []const u8) !void {\n    fs.cwd().makePath(self.pathFromRoot(path)) catch |err| {\n        warn(\"Unable to create path {s}: {s}\\n\", .{ path, @errorName(err) });\n        return err;\n    };\n}","src":921,"more_decls":null}{"pl":"pub fn installArtifact(self: *Builder, artifact: *LibExeObjStep) void {\n    self.getInstallStep().dependOn(&self.addInstallArtifact(artifact).step);\n}","src":928,"more_decls":null}{"pl":"pub fn addInstallArtifact(self: *Builder, artifact: *LibExeObjStep) *InstallArtifactStep {\n    return InstallArtifactStep.create(self, artifact);\n}","src":932,"more_decls":null}{"doc_comment":"`dest_rel_path` is relative to prefix path","pl":"pub fn installFile(self: *Builder, src_path: []const u8, dest_rel_path: []const u8) void {\n    self.getInstallStep().dependOn(&self.addInstallFileWithDir(src_path, .Prefix, dest_rel_path).step);\n}","src":937,"more_decls":null}{"pl":"pub fn installDirectory(self: *Builder, options: InstallDirectoryOptions) void {\n    self.getInstallStep().dependOn(&self.addInstallDirectory(options).step);\n}","src":941,"more_decls":null}{"doc_comment":"`dest_rel_path` is relative to bin path","pl":"pub fn installBinFile(self: *Builder, src_path: []const u8, dest_rel_path: []const u8) void {\n    self.getInstallStep().dependOn(&self.addInstallFileWithDir(src_path, .Bin, dest_rel_path).step);\n}","src":946,"more_decls":null}{"doc_comment":"`dest_rel_path` is relative to lib path","pl":"pub fn installLibFile(self: *Builder, src_path: []const u8, dest_rel_path: []const u8) void {\n    self.getInstallStep().dependOn(&self.addInstallFileWithDir(src_path, .Lib, dest_rel_path).step);\n}","src":951,"more_decls":null}{"pl":"pub fn installRaw(self: *Builder, artifact: *LibExeObjStep, dest_filename: []const u8) void {\n    self.getInstallStep().dependOn(&self.addInstallRaw(artifact, dest_filename).step);\n}","src":955,"more_decls":null}{"doc_comment":"`dest_rel_path` is relative to install prefix path","pl":"pub fn addInstallFile(self: *Builder, src_path: []const u8, dest_rel_path: []const u8) *InstallFileStep {\n    return self.addInstallFileWithDir(src_path, .Prefix, dest_rel_path);\n}","src":960,"more_decls":null}{"doc_comment":"`dest_rel_path` is relative to bin path","pl":"pub fn addInstallBinFile(self: *Builder, src_path: []const u8, dest_rel_path: []const u8) *InstallFileStep {\n    return self.addInstallFileWithDir(src_path, .Bin, dest_rel_path);\n}","src":965,"more_decls":null}{"doc_comment":"`dest_rel_path` is relative to lib path","pl":"pub fn addInstallLibFile(self: *Builder, src_path: []const u8, dest_rel_path: []const u8) *InstallFileStep {\n    return self.addInstallFileWithDir(src_path, .Lib, dest_rel_path);\n}","src":970,"more_decls":null}{"pl":"pub fn addInstallRaw(self: *Builder, artifact: *LibExeObjStep, dest_filename: []const u8) *InstallRawStep {\n    return InstallRawStep.create(self, artifact, dest_filename);\n}","src":974,"more_decls":null}{"pl":"fn addInstallFileWithDir(\n    self: *Builder,\n    src_path: []const u8,\n    install_dir: InstallDir,\n    dest_rel_path: []const u8,\n) *InstallFileStep","src":978,"more_decls":null}{"pl":"pub fn addInstallDirectory(self: *Builder, options: InstallDirectoryOptions) *InstallDirStep {\n    const install_step = self.allocator.create(InstallDirStep) catch unreachable;\n    install_step.* = InstallDirStep.init(self, options);\n    return install_step;\n}","src":992,"more_decls":null}{"pl":"fn pushInstalledFile(self: *Builder, dir: InstallDir, dest_rel_path: []const u8) void","src":998,"more_decls":null}{"pl":"fn updateFile(self: *Builder, source_path: []const u8, dest_path: []const u8) !void","src":1006,"more_decls":null}{"pl":"pub fn pathFromRoot(self: *Builder, rel_path: []const u8) []u8 {\n    return fs.path.resolve(self.allocator, &[_][]const u8{ self.build_root, rel_path }) catch unreachable;\n}","src":1018,"more_decls":null}{"pl":"pub fn fmt(self: *Builder, comptime format: []const u8, args: anytype) []u8 {\n    return fmt_lib.allocPrint(self.allocator, format, args) catch unreachable;\n}","src":1022,"more_decls":null}{"pl":"fn findProgram(self: *Builder, names: []const []const u8, paths: []const []const u8) ![]const u8","src":1026,"more_decls":null}{"pl":"fn execAllowFail(\n    self: *Builder,\n    argv: []const []const u8,\n    out_code: *u8,\n    stderr_behavior: std.ChildProcess.StdIo,\n) ![]u8","src":1072,"more_decls":null}{"pl":"fn execFromStep(self: *Builder, argv: []const []const u8, src_step: ?*Step) ![]u8","src":1110,"more_decls":null}{"pl":"pub fn exec(self: *Builder, argv: []const []const u8) ![]u8 {\n    return self.execFromStep(argv, null);\n}","src":1141,"more_decls":null}{"pl":"pub fn addSearchPrefix(self: *Builder, search_prefix: []const u8) void {\n    self.search_prefixes.append(self.dupePath(search_prefix)) catch unreachable;\n}","src":1145,"more_decls":null}{"pl":"fn getInstallPath(self: *Builder, dir: InstallDir, dest_rel_path: []const u8) []const u8","src":1149,"more_decls":null}}{"pl":"pub const Pkg = struct ","src":1226,"more_decls":{"pl":"name: []const u8","src":1227,"more_decls":null}{"pl":"path: []const u8","src":1228,"more_decls":null}{"pl":"dependencies: ?[]const Pkg = null","src":1229,"more_decls":null}}{"pl":"pub const CSourceFile = struct ","src":1232,"more_decls":{"pl":"source: FileSource","src":1233,"more_decls":null}{"pl":"args: []const []const u8","src":1234,"more_decls":null}}{"pl":"pub const FileSource = union(enum) ","src":1258,"more_decls":{"doc_comment":"Relative to build root","pl":"path: []const u8","src":1260,"more_decls":null}{"pl":"write_file: struct {\n        step: *WriteFileStep,\n        basename: []const u8,\n    }","src":1261,"more_decls":null}{"pl":"translate_c: *TranslateCStep","src":1265,"more_decls":null}{"pl":"fn addStepDependencies(self: FileSource, step: *Step) void","src":1267,"more_decls":null}{"doc_comment":"Should only be called during make()","pl":"fn getPath(self: FileSource, builder: *Builder) []const u8","src":1276,"more_decls":null}{"pl":"fn dupe(self: FileSource, b: *Builder) FileSource","src":1284,"more_decls":null}}{"pl":"pub const LibExeObjStep = struct ","src":1307,"more_decls":{"pl":"step: Step","src":1308,"more_decls":null}{"pl":"builder: *Builder","src":1309,"more_decls":null}{"pl":"name: []const u8","src":1310,"more_decls":null}{"pl":"target: CrossTarget = CrossTarget{}","src":1311,"more_decls":null}{"pl":"linker_script: ?[]const u8 = null","src":1312,"more_decls":null}{"pl":"version_script: ?[]const u8 = null","src":1313,"more_decls":null}{"pl":"out_filename: []const u8","src":1314,"more_decls":null}{"pl":"is_dynamic: bool","src":1315,"more_decls":null}{"pl":"version: ?Version","src":1316,"more_decls":null}{"pl":"build_mode: builtin.Mode","src":1317,"more_decls":null}{"pl":"kind: Kind","src":1318,"more_decls":null}{"pl":"major_only_filename: []const u8","src":1319,"more_decls":null}{"pl":"name_only_filename: []const u8","src":1320,"more_decls":null}{"pl":"strip: bool","src":1321,"more_decls":null}{"pl":"lib_paths: ArrayList([]const u8)","src":1322,"more_decls":null}{"pl":"framework_dirs: ArrayList([]const u8)","src":1323,"more_decls":null}{"pl":"frameworks: BufSet","src":1324,"more_decls":null}{"pl":"verbose_link: bool","src":1325,"more_decls":null}{"pl":"verbose_cc: bool","src":1326,"more_decls":null}{"pl":"emit_llvm_ir: bool = false","src":1327,"more_decls":null}{"pl":"emit_asm: bool = false","src":1328,"more_decls":null}{"pl":"emit_bin: bool = true","src":1329,"more_decls":null}{"pl":"emit_docs: bool = false","src":1330,"more_decls":null}{"pl":"emit_h: bool = false","src":1331,"more_decls":null}{"pl":"bundle_compiler_rt: ?bool = null","src":1332,"more_decls":null}{"pl":"disable_stack_probing: bool","src":1333,"more_decls":null}{"pl":"disable_sanitize_c: bool","src":1334,"more_decls":null}{"pl":"sanitize_thread: bool","src":1335,"more_decls":null}{"pl":"rdynamic: bool","src":1336,"more_decls":null}{"pl":"c_std: Builder.CStd","src":1337,"more_decls":null}{"pl":"override_lib_dir: ?[]const u8","src":1338,"more_decls":null}{"pl":"main_pkg_path: ?[]const u8","src":1339,"more_decls":null}{"pl":"exec_cmd_args: ?[]const ?[]const u8","src":1340,"more_decls":null}{"pl":"name_prefix: []const u8","src":1341,"more_decls":null}{"pl":"filter: ?[]const u8","src":1342,"more_decls":null}{"pl":"single_threaded: bool","src":1343,"more_decls":null}{"pl":"test_evented_io: bool = false","src":1344,"more_decls":null}{"pl":"code_model: builtin.CodeModel = .default","src":1345,"more_decls":null}{"pl":"root_src: ?FileSource","src":1347,"more_decls":null}{"pl":"out_h_filename: []const u8","src":1348,"more_decls":null}{"pl":"out_lib_filename: []const u8","src":1349,"more_decls":null}{"pl":"out_pdb_filename: []const u8","src":1350,"more_decls":null}{"pl":"packages: ArrayList(Pkg)","src":1351,"more_decls":null}{"pl":"build_options_contents: std.ArrayList(u8)","src":1352,"more_decls":null}{"pl":"build_options_artifact_args: std.ArrayList(BuildOptionArtifactArg)","src":1353,"more_decls":null}{"pl":"build_options_write_file_args: std.ArrayList(BuildOptionWriteFileArg)","src":1354,"more_decls":null}{"pl":"object_src: []const u8","src":1356,"more_decls":null}{"pl":"link_objects: ArrayList(LinkObject)","src":1358,"more_decls":null}{"pl":"include_dirs: ArrayList(IncludeDir)","src":1359,"more_decls":null}{"pl":"c_macros: ArrayList([]const u8)","src":1360,"more_decls":null}{"pl":"output_dir: ?[]const u8","src":1361,"more_decls":null}{"pl":"is_linking_libc: bool = false","src":1362,"more_decls":null}{"pl":"vcpkg_bin_path: ?[]const u8 = null","src":1363,"more_decls":null}{"doc_comment":"This may be set in order to override the default install directory","pl":"override_dest_dir: ?InstallDir","src":1366,"more_decls":null}{"pl":"installed_path: ?[]const u8","src":1367,"more_decls":null}{"pl":"install_step: ?*InstallArtifactStep","src":1368,"more_decls":null}{"doc_comment":"Base address for an executable image.","pl":"image_base: ?u64 = null","src":1371,"more_decls":null}{"pl":"libc_file: ?[]const u8 = null","src":1373,"more_decls":null}{"pl":"valgrind_support: ?bool = null","src":1375,"more_decls":null}{"doc_comment":"Create a .eh_frame_hdr section and a PT_GNU_EH_FRAME segment in the ELF\nfile.","pl":"link_eh_frame_hdr: bool = false","src":1379,"more_decls":null}{"pl":"link_emit_relocs: bool = false","src":1380,"more_decls":null}{"doc_comment":"Place every function in its own section so that unused ones may be\nsafely garbage-collected during the linking phase.","pl":"link_function_sections: bool = false","src":1384,"more_decls":null}{"doc_comment":"Uses system Wine installation to run cross compiled Windows build artifacts.","pl":"enable_wine: bool = false","src":1387,"more_decls":null}{"doc_comment":"Uses system QEMU installation to run cross compiled foreign architecture build artifacts.","pl":"enable_qemu: bool = false","src":1390,"more_decls":null}{"doc_comment":"Uses system Wasmtime installation to run cross compiled wasm/wasi build artifacts.","pl":"enable_wasmtime: bool = false","src":1393,"more_decls":null}{"doc_comment":"After following the steps in https://github.com/ziglang/zig/wiki/Updating-libc#glibc,\nthis will be the directory $glibc-build-dir/install/glibcs\nGiven the example of the aarch64 target, this is the directory\nthat contains the path `aarch64-linux-gnu/lib/ld-linux-aarch64.so.1`.","pl":"glibc_multi_install_dir: ?[]const u8 = null","src":1399,"more_decls":null}{"doc_comment":"Position Independent Code","pl":"force_pic: ?bool = null","src":1402,"more_decls":null}{"doc_comment":"Position Independent Executable","pl":"pie: ?bool = null","src":1405,"more_decls":null}{"pl":"red_zone: ?bool = null","src":1407,"more_decls":null}{"pl":"subsystem: ?builtin.SubSystem = null","src":1409,"more_decls":null}{"doc_comment":"Overrides the default stack size","pl":"stack_size: ?u64 = null","src":1412,"more_decls":null}{"pl":"want_lto: ?bool = null","src":1414,"more_decls":null}{"pl":"fn createSharedLibrary(builder: *Builder, name: []const u8, root_src: ?FileSource, kind: SharedLibKind) *LibExeObjStep","src":1443,"more_decls":null}{"pl":"pub fn createStaticLibrary(builder: *Builder, name: []const u8, root_src: ?FileSource) *LibExeObjStep {\n    const self = builder.allocator.create(LibExeObjStep) catch unreachable;\n    self.* = initExtraArgs(builder, name, root_src, Kind.Lib, false, null);\n    return self;\n}","src":1452,"more_decls":null}{"pl":"pub fn createObject(builder: *Builder, name: []const u8, root_src: ?FileSource) *LibExeObjStep {\n    const self = builder.allocator.create(LibExeObjStep) catch unreachable;\n    self.* = initExtraArgs(builder, name, root_src, Kind.Obj, false, null);\n    return self;\n}","src":1458,"more_decls":null}{"pl":"pub fn createExecutable(builder: *Builder, name: []const u8, root_src: ?FileSource, is_dynamic: bool) *LibExeObjStep {\n    const self = builder.allocator.create(LibExeObjStep) catch unreachable;\n    self.* = initExtraArgs(builder, name, root_src, Kind.Exe, is_dynamic, null);\n    return self;\n}","src":1464,"more_decls":null}{"pl":"pub fn createTest(builder: *Builder, name: []const u8, root_src: FileSource) *LibExeObjStep {\n    const self = builder.allocator.create(LibExeObjStep) catch unreachable;\n    self.* = initExtraArgs(builder, name, root_src, Kind.Test, false, null);\n    return self;\n}","src":1470,"more_decls":null}{"pl":"pub fn setTarget(self: *LibExeObjStep, target: CrossTarget) void {\n    self.target = target;\n    self.computeOutFileNames();\n}","src":1587,"more_decls":null}{"pl":"pub fn setOutputDir(self: *LibExeObjStep, dir: []const u8) void {\n    self.output_dir = self.builder.dupePath(dir);\n}","src":1592,"more_decls":null}{"pl":"pub fn install(self: *LibExeObjStep) void {\n    self.builder.installArtifact(self);\n}","src":1596,"more_decls":null}{"pl":"pub fn installRaw(self: *LibExeObjStep, dest_filename: []const u8) void {\n    self.builder.installRaw(self, dest_filename);\n}","src":1600,"more_decls":null}{"doc_comment":"Creates a `RunStep` with an executable built with `addExecutable`.\nAdd command line arguments with `addArg`.","pl":"fn run(exe: *LibExeObjStep) *RunStep","src":1606,"more_decls":null}{"pl":"pub fn setLinkerScriptPath(self: *LibExeObjStep, path: []const u8) void {\n    self.linker_script = self.builder.dupePath(path);\n}","src":1622,"more_decls":null}{"pl":"pub fn linkFramework(self: *LibExeObjStep, framework_name: []const u8) void {\n    assert(self.target.isDarwin());\n    self.frameworks.put(self.builder.dupe(framework_name)) catch unreachable;\n}","src":1626,"more_decls":null}{"doc_comment":"Returns whether the library, executable, or object depends on a particular system library.","pl":"fn dependsOnSystemLibrary(self: LibExeObjStep, name: []const u8) bool","src":1632,"more_decls":null}{"pl":"pub fn linkLibrary(self: *LibExeObjStep, lib: *LibExeObjStep) void {\n    assert(lib.kind == Kind.Lib);\n    self.linkLibraryOrObject(lib);\n}","src":1645,"more_decls":null}{"pl":"pub fn isDynamicLibrary(self: *LibExeObjStep) bool {\n    return self.kind == Kind.Lib and self.is_dynamic;\n}","src":1650,"more_decls":null}{"pl":"pub fn producesPdbFile(self: *LibExeObjStep) bool {\n    if (!self.target.isWindows() and !self.target.isUefi()) return false;\n    if (self.strip) return false;\n    return self.isDynamicLibrary() or self.kind == .Exe;\n}","src":1654,"more_decls":null}{"pl":"pub fn linkLibC(self: *LibExeObjStep) void {\n    if (!self.is_linking_libc) {\n        self.is_linking_libc = true;\n        self.link_objects.append(LinkObject{ .SystemLib = \"c\" }) catch unreachable;\n    }\n}","src":1660,"more_decls":null}{"doc_comment":"name_and_value looks like [name]=[value]. If the value is omitted, it is set to 1.","pl":"pub fn defineCMacro(self: *LibExeObjStep, name_and_value: []const u8) void {\n    self.c_macros.append(self.builder.dupe(name_and_value)) catch unreachable;\n}","src":1668,"more_decls":null}{"doc_comment":"This one has no integration with anything, it just puts -lname on the command line.\nPrefer to use `linkSystemLibrary` instead.","pl":"pub fn linkSystemLibraryName(self: *LibExeObjStep, name: []const u8) void {\n    self.link_objects.append(LinkObject{ .SystemLib = self.builder.dupe(name) }) catch unreachable;\n}","src":1674,"more_decls":null}{"doc_comment":"This links against a system library, exclusively using pkg-config to find the library.\nPrefer to use `linkSystemLibrary` instead.","pl":"fn linkSystemLibraryPkgConfigOnly(self: *LibExeObjStep, lib_name: []const u8) !void","src":1680,"more_decls":null}{"pl":"fn linkSystemLibrary(self: *LibExeObjStep, name: []const u8) void","src":1768,"more_decls":null}{"pl":"pub fn setNamePrefix(self: *LibExeObjStep, text: []const u8) void {\n    assert(self.kind == Kind.Test);\n    self.name_prefix = self.builder.dupe(text);\n}","src":1790,"more_decls":null}{"pl":"pub fn setFilter(self: *LibExeObjStep, text: ?[]const u8) void {\n    assert(self.kind == Kind.Test);\n    self.filter = if (text) |t| self.builder.dupe(t) else null;\n}","src":1795,"more_decls":null}{"doc_comment":"Handy when you have many C/C++ source files and want them all to have the same flags.","pl":"fn addCSourceFiles(self: *LibExeObjStep, files: []const []const u8, flags: []const []const u8) void","src":1801,"more_decls":null}{"pl":"pub fn addCSourceFile(self: *LibExeObjStep, file: []const u8, flags: []const []const u8) void {\n    self.addCSourceFileSource(.{\n        .args = flags,\n        .source = .{ .path = file },\n    });\n}","src":1814,"more_decls":null}{"pl":"pub fn addCSourceFileSource(self: *LibExeObjStep, source: CSourceFile) void {\n    const c_source_file = self.builder.allocator.create(CSourceFile) catch unreachable;\n    c_source_file.* = source.dupe(self.builder);\n    self.link_objects.append(LinkObject{ .CSourceFile = c_source_file }) catch unreachable;\n}","src":1821,"more_decls":null}{"pl":"pub fn setVerboseLink(self: *LibExeObjStep, value: bool) void {\n    self.verbose_link = value;\n}","src":1827,"more_decls":null}{"pl":"pub fn setVerboseCC(self: *LibExeObjStep, value: bool) void {\n    self.verbose_cc = value;\n}","src":1831,"more_decls":null}{"pl":"pub fn setBuildMode(self: *LibExeObjStep, mode: builtin.Mode) void {\n    self.build_mode = mode;\n}","src":1835,"more_decls":null}{"pl":"pub fn overrideZigLibDir(self: *LibExeObjStep, dir_path: []const u8) void {\n    self.override_lib_dir = self.builder.dupePath(dir_path);\n}","src":1839,"more_decls":null}{"pl":"pub fn setMainPkgPath(self: *LibExeObjStep, dir_path: []const u8) void {\n    self.main_pkg_path = self.builder.dupePath(dir_path);\n}","src":1843,"more_decls":null}{"pl":"pub fn setLibCFile(self: *LibExeObjStep, libc_file: ?[]const u8) void {\n    self.libc_file = if (libc_file) |f| self.builder.dupe(f) else null;\n}","src":1847,"more_decls":null}{"doc_comment":"Unless setOutputDir was called, this function must be called only in\nthe make step, from a step that has declared a dependency on this one.\nTo run an executable built with zig build, use `run`, or create an install step and invoke it.","pl":"pub fn getOutputPath(self: *LibExeObjStep) []const u8 {\n    return fs.path.join(\n        self.builder.allocator,\n        &[_][]const u8{ self.output_dir.?, self.out_filename },\n    ) catch unreachable;\n}","src":1854,"more_decls":null}{"doc_comment":"Unless setOutputDir was called, this function must be called only in\nthe make step, from a step that has declared a dependency on this one.","pl":"fn getOutputLibPath(self: *LibExeObjStep) []const u8","src":1863,"more_decls":null}{"doc_comment":"Unless setOutputDir was called, this function must be called only in\nthe make step, from a step that has declared a dependency on this one.","pl":"fn getOutputHPath(self: *LibExeObjStep) []const u8","src":1873,"more_decls":null}{"doc_comment":"Unless setOutputDir was called, this function must be called only in\nthe make step, from a step that has declared a dependency on this one.","pl":"fn getOutputPdbPath(self: *LibExeObjStep) []const u8","src":1884,"more_decls":null}{"pl":"pub fn addAssemblyFile(self: *LibExeObjStep, path: []const u8) void {\n    self.link_objects.append(LinkObject{\n        .AssemblyFile = .{ .path = self.builder.dupe(path) },\n    }) catch unreachable;\n}","src":1892,"more_decls":null}{"pl":"fn addAssemblyFileFromWriteFileStep(self: *LibExeObjStep, wfs: *WriteFileStep, basename: []const u8) void","src":1898,"more_decls":null}{"pl":"pub fn addAssemblyFileSource(self: *LibExeObjStep, source: FileSource) void {\n    const source_duped = source.dupe(self.builder);\n    self.link_objects.append(LinkObject{ .AssemblyFile = source_duped }) catch unreachable;\n    source_duped.addStepDependencies(&self.step);\n}","src":1907,"more_decls":null}{"pl":"pub fn addObjectFile(self: *LibExeObjStep, path: []const u8) void {\n    self.link_objects.append(LinkObject{ .StaticPath = self.builder.dupe(path) }) catch unreachable;\n}","src":1913,"more_decls":null}{"pl":"pub fn addObject(self: *LibExeObjStep, obj: *LibExeObjStep) void {\n    assert(obj.kind == Kind.Obj);\n    self.linkLibraryOrObject(obj);\n}","src":1917,"more_decls":null}{"pl":"fn addBuildOption(self: *LibExeObjStep, comptime T: type, name: []const u8, value: T) void","src":1922,"more_decls":null}{"doc_comment":"The value is the path in the cache dir.\nAdds a dependency automatically.","pl":"pub fn addBuildOptionArtifact(self: *LibExeObjStep, name: []const u8, artifact: *LibExeObjStep) void {\n    self.build_options_artifact_args.append(.{ .name = self.builder.dupe(name), .artifact = artifact }) catch unreachable;\n    self.step.dependOn(&artifact.step);\n}","src":2006,"more_decls":null}{"doc_comment":"The value is the path in the cache dir.\nAdds a dependency automatically.\nbasename refers to the basename of the WriteFileStep","pl":"fn addBuildOptionWriteFile(\n    self: *LibExeObjStep,\n    name: []const u8,\n    write_file: *WriteFileStep,\n    basename: []const u8,\n) void","src":2014,"more_decls":null}{"pl":"pub fn addSystemIncludeDir(self: *LibExeObjStep, path: []const u8) void {\n    self.include_dirs.append(IncludeDir{ .RawPathSystem = self.builder.dupe(path) }) catch unreachable;\n}","src":2028,"more_decls":null}{"pl":"pub fn addIncludeDir(self: *LibExeObjStep, path: []const u8) void {\n    self.include_dirs.append(IncludeDir{ .RawPath = self.builder.dupe(path) }) catch unreachable;\n}","src":2032,"more_decls":null}{"pl":"pub fn addLibPath(self: *LibExeObjStep, path: []const u8) void {\n    self.lib_paths.append(self.builder.dupe(path)) catch unreachable;\n}","src":2036,"more_decls":null}{"pl":"pub fn addFrameworkDir(self: *LibExeObjStep, dir_path: []const u8) void {\n    self.framework_dirs.append(self.builder.dupe(dir_path)) catch unreachable;\n}","src":2040,"more_decls":null}{"pl":"pub fn addPackage(self: *LibExeObjStep, package: Pkg) void {\n    self.packages.append(self.builder.dupePkg(package)) catch unreachable;\n}","src":2044,"more_decls":null}{"pl":"pub fn addPackagePath(self: *LibExeObjStep, name: []const u8, pkg_index_path: []const u8) void {\n    self.packages.append(Pkg{\n        .name = self.builder.dupe(name),\n        .path = self.builder.dupe(pkg_index_path),\n    }) catch unreachable;\n}","src":2048,"more_decls":null}{"doc_comment":"If Vcpkg was found on the system, it will be added to include and lib\npaths for the specified target.","pl":"fn addVcpkgPaths(self: *LibExeObjStep, linkage: VcpkgLinkage) !void","src":2057,"more_decls":null}{"pl":"fn setExecCmd(self: *LibExeObjStep, args: []const ?[]const u8) void","src":2092,"more_decls":null}}{"pl":"pub const InstallArtifactStep = struct ","src":2647,"more_decls":{"pl":"step: Step","src":2648,"more_decls":null}{"pl":"builder: *Builder","src":2649,"more_decls":null}{"pl":"artifact: *LibExeObjStep","src":2650,"more_decls":null}{"pl":"dest_dir: InstallDir","src":2651,"more_decls":null}{"pl":"pdb_dir: ?InstallDir","src":2652,"more_decls":null}{"pl":"h_dir: ?InstallDir","src":2653,"more_decls":null}{"pl":"fn create(builder: *Builder, artifact: *LibExeObjStep) *Self","src":2657,"more_decls":null}}{"pl":"pub const InstallFileStep = struct ","src":2723,"more_decls":{"pl":"step: Step","src":2724,"more_decls":null}{"pl":"builder: *Builder","src":2725,"more_decls":null}{"pl":"src_path: []const u8","src":2726,"more_decls":null}{"pl":"dir: InstallDir","src":2727,"more_decls":null}{"pl":"dest_rel_path: []const u8","src":2728,"more_decls":null}{"pl":"fn init(\n    builder: *Builder,\n    src_path: []const u8,\n    dir: InstallDir,\n    dest_rel_path: []const u8,\n) InstallFileStep","src":2730,"more_decls":null}}{"pl":"pub const InstallDirectoryOptions = struct ","src":2754,"more_decls":{"pl":"source_dir: []const u8","src":2755,"more_decls":null}{"pl":"install_dir: InstallDir","src":2756,"more_decls":null}{"pl":"install_subdir: []const u8","src":2757,"more_decls":null}{"pl":"exclude_extensions: ?[]const []const u8 = null","src":2758,"more_decls":null}}{"pl":"pub const InstallDirStep = struct ","src":2773,"more_decls":{"pl":"step: Step","src":2774,"more_decls":null}{"pl":"builder: *Builder","src":2775,"more_decls":null}{"pl":"options: InstallDirectoryOptions","src":2776,"more_decls":null}{"pl":"fn init(\n    builder: *Builder,\n    options: InstallDirectoryOptions,\n) InstallDirStep","src":2778,"more_decls":null}}{"pl":"pub const LogStep = struct ","src":2813,"more_decls":{"pl":"step: Step","src":2814,"more_decls":null}{"pl":"builder: *Builder","src":2815,"more_decls":null}{"pl":"data: []const u8","src":2816,"more_decls":null}{"pl":"fn init(builder: *Builder, data: []const u8) LogStep","src":2818,"more_decls":null}}{"pl":"pub const RemoveDirStep = struct ","src":2832,"more_decls":{"pl":"step: Step","src":2833,"more_decls":null}{"pl":"builder: *Builder","src":2834,"more_decls":null}{"pl":"dir_path: []const u8","src":2835,"more_decls":null}{"pl":"fn init(builder: *Builder, dir_path: []const u8) RemoveDirStep","src":2837,"more_decls":null}}{"pl":"pub const Step = struct ","src":2857,"more_decls":{"pl":"id: Id","src":2858,"more_decls":null}{"pl":"name: []const u8","src":2859,"more_decls":null}{"pl":"makeFn: fn (self: *Step) anyerror!void","src":2860,"more_decls":null}{"pl":"dependencies: ArrayList(*Step)","src":2861,"more_decls":null}{"pl":"loop_flag: bool","src":2862,"more_decls":null}{"pl":"done_flag: bool","src":2863,"more_decls":null}{"pl":"pub const Id = enum ","src":2865,"more_decls":{"pl":"TopLevel","src":2866,"more_decls":null}{"pl":"LibExeObj","src":2867,"more_decls":null}{"pl":"InstallArtifact","src":2868,"more_decls":null}{"pl":"InstallFile","src":2869,"more_decls":null}{"pl":"InstallDir","src":2870,"more_decls":null}{"pl":"Log","src":2871,"more_decls":null}{"pl":"RemoveDir","src":2872,"more_decls":null}{"pl":"Fmt","src":2873,"more_decls":null}{"pl":"TranslateC","src":2874,"more_decls":null}{"pl":"WriteFile","src":2875,"more_decls":null}{"pl":"Run","src":2876,"more_decls":null}{"pl":"CheckFile","src":2877,"more_decls":null}{"pl":"InstallRaw","src":2878,"more_decls":null}{"pl":"Custom","src":2879,"more_decls":null}}{"pl":"fn init(id: Id, name: []const u8, allocator: *Allocator, makeFn: fn (*Step) anyerror!void) Step","src":2882,"more_decls":null}{"pl":"pub fn initNoOp(id: Id, name: []const u8, allocator: *Allocator) Step {\n    return init(id, name, allocator, makeNoOp);\n}","src":2892,"more_decls":null}{"pl":"pub fn make(self: *Step) !void {\n    if (self.done_flag) return;\n\n    try self.makeFn(self);\n    self.done_flag = true;\n}","src":2896,"more_decls":null}{"pl":"pub fn dependOn(self: *Step, other: *Step) void {\n    self.dependencies.append(other) catch unreachable;\n}","src":2903,"more_decls":null}{"pl":"pub fn cast(step: *Step, comptime T: type) ?*T {\n    if (step.id == comptime typeToId(T)) {\n        return @fieldParentPtr(T, \"step\", step);\n    }\n    return null;\n}","src":2909,"more_decls":null}}{"pl":"pub const InstallDir = union(enum) ","src":2985,"more_decls":{"pl":"Prefix: void","src":2986,"more_decls":null}{"pl":"Lib: void","src":2987,"more_decls":null}{"pl":"Bin: void","src":2988,"more_decls":null}{"pl":"Header: void","src":2989,"more_decls":null}{"doc_comment":"A path relative to the prefix","pl":"Custom: []const u8","src":2991,"more_decls":null}}{"pl":"pub const InstalledFile = struct ","src":3004,"more_decls":{"pl":"dir: InstallDir","src":3005,"more_decls":null}{"pl":"path: []const u8","src":3006,"more_decls":null}{"pl":"pub fn dupe(self: InstalledFile, builder: *Builder) InstalledFile {\n    return .{\n        .dir = self.dir.dupe(builder),\n        .path = builder.dupe(self.path),\n    };\n}","src":3008,"more_decls":null}}{"pl":"const FmtStep = @import(\"build/fmt.zig\").FmtStep","src":24,"more_decls":null}{"pl":"const TranslateCStep = @import(\"build/translate_c.zig\").TranslateCStep","src":25,"more_decls":null}{"pl":"const WriteFileStep = @import(\"build/write_file.zig\").WriteFileStep","src":26,"more_decls":null}{"pl":"const RunStep = @import(\"build/run.zig\").RunStep","src":27,"more_decls":null}{"pl":"const CheckFileStep = @import(\"build/check_file.zig\").CheckFileStep","src":28,"more_decls":null}{"pl":"const InstallRawStep = @import(\"build/emit_raw.zig\").InstallRawStep","src":29,"more_decls":null}{"doc_comment":"Deprecated. Use `std.builtin.Version`.","pl":"const Version = builtin.Version","src":1221,"more_decls":null}{"doc_comment":"Deprecated. Use `std.zig.CrossTarget`.","pl":"const Target = std.zig.CrossTarget","src":1224,"more_decls":null}{"pl":"const VcpkgLinkage = std.builtin.LinkMode","src":2983,"more_decls":null}]