[{"pl":"pub const MemCheckClientRequest = extern enum ","src":9,"more_decls":{"pl":"MakeMemNoAccess = valgrind.ToolBase(\"MC\".*)","src":10,"more_decls":null}{"pl":"MakeMemUndefined","src":11,"more_decls":null}{"pl":"MakeMemDefined","src":12,"more_decls":null}{"pl":"Discard","src":13,"more_decls":null}{"pl":"CheckMemIsAddressable","src":14,"more_decls":null}{"pl":"CheckMemIsDefined","src":15,"more_decls":null}{"pl":"DoLeakCheck","src":16,"more_decls":null}{"pl":"CountLeaks","src":17,"more_decls":null}{"pl":"GetVbits","src":18,"more_decls":null}{"pl":"SetVbits","src":19,"more_decls":null}{"pl":"CreateBlock","src":20,"more_decls":null}{"pl":"MakeMemDefinedIfAddressable","src":21,"more_decls":null}{"pl":"CountLeakBlocks","src":22,"more_decls":null}{"pl":"EnableAddrErrorReportingInRange","src":23,"more_decls":null}{"pl":"DisableAddrErrorReportingInRange","src":24,"more_decls":null}}{"doc_comment":"Mark memory at qzz.ptr as unaddressable for qzz.len bytes.\nThis returns -1 when run on Valgrind and 0 otherwise.","pl":"pub fn makeMemNoAccess(qzz: []u8) i1 {\n    return @intCast(i1, doMemCheckClientRequestExpr(0, // default return\n        .MakeMemNoAccess, @ptrToInt(qzz.ptr), qzz.len, 0, 0, 0));\n}","src":37,"more_decls":null}{"doc_comment":"Similarly, mark memory at qzz.ptr as addressable but undefined\nfor qzz.len bytes.\nThis returns -1 when run on Valgrind and 0 otherwise.","pl":"pub fn makeMemUndefined(qzz: []u8) i1 {\n    return @intCast(i1, doMemCheckClientRequestExpr(0, // default return\n        .MakeMemUndefined, @ptrToInt(qzz.ptr), qzz.len, 0, 0, 0));\n}","src":45,"more_decls":null}{"doc_comment":"Similarly, mark memory at qzz.ptr as addressable and defined\nfor qzz.len bytes.","pl":"pub fn makeMemDefined(qzz: []u8) i1 {\n    // This returns -1 when run on Valgrind and 0 otherwise.\n    return @intCast(i1, doMemCheckClientRequestExpr(0, // default return\n        .MakeMemDefined, @ptrToInt(qzz.ptr), qzz.len, 0, 0, 0));\n}","src":52,"more_decls":null}{"doc_comment":"Similar to makeMemDefined except that addressability is\nnot altered: bytes which are addressable are marked as defined,\nbut those which are not addressable are left unchanged.\nThis returns -1 when run on Valgrind and 0 otherwise.","pl":"pub fn makeMemDefinedIfAddressable(qzz: []u8) i1 {\n    return @intCast(i1, doMemCheckClientRequestExpr(0, // default return\n        .MakeMemDefinedIfAddressable, @ptrToInt(qzz.ptr), qzz.len, 0, 0, 0));\n}","src":62,"more_decls":null}{"doc_comment":"Create a block-description handle.  The description is an ascii\nstring which is included in any messages pertaining to addresses\nwithin the specified memory range.  Has no other effect on the\nproperties of the memory range.","pl":"pub fn createBlock(qzz: []u8, desc: [*]u8) usize {\n    return doMemCheckClientRequestExpr(0, // default return\n        .CreateBlock, @ptrToInt(qzz.ptr), qzz.len, @ptrToInt(desc), 0, 0);\n}","src":71,"more_decls":null}{"doc_comment":"Discard a block-description-handle. Returns 1 for an\ninvalid handle, 0 for a valid handle.","pl":"pub fn discard(blkindex) bool {\n    return doMemCheckClientRequestExpr(0, // default return\n        .Discard, 0, blkindex, 0, 0, 0) != 0;\n}","src":78,"more_decls":null}{"doc_comment":"Check that memory at qzz.ptr is addressable for qzz.len bytes.\nIf suitable addressibility is not established, Valgrind prints an\nerror message and returns the address of the first offending byte.\nOtherwise it returns zero.","pl":"pub fn checkMemIsAddressable(qzz: []u8) usize {\n    return doMemCheckClientRequestExpr(0, .CheckMemIsAddressable, @ptrToInt(qzz.ptr), qzz.len, 0, 0, 0);\n}","src":87,"more_decls":null}{"doc_comment":"Check that memory at qzz.ptr is addressable and defined for\nqzz.len bytes.  If suitable addressibility and definedness are not\nestablished, Valgrind prints an error message and returns the\naddress of the first offending byte.  Otherwise it returns zero.","pl":"pub fn checkMemIsDefined(qzz: []u8) usize {\n    return doMemCheckClientRequestExpr(0, .CheckMemIsDefined, @ptrToInt(qzz.ptr), qzz.len, 0, 0, 0);\n}","src":95,"more_decls":null}{"doc_comment":"Do a full memory leak check (like --leak-check=full) mid-execution.","pl":"pub fn doLeakCheck() void {\n    doMemCheckClientRequestStmt(.DO_LEAK_CHECK, 0, 0, 0, 0, 0);\n}","src":100,"more_decls":null}{"doc_comment":"Same as doLeakCheck() but only showing the entries for\nwhich there was an increase in leaked bytes or leaked nr of blocks\nsince the previous leak search.","pl":"pub fn doAddedLeakCheck() void {\n    doMemCheckClientRequestStmt(.DO_LEAK_CHECK, 0, 1, 0, 0, 0);\n}","src":107,"more_decls":null}{"doc_comment":"Same as doAddedLeakCheck() but showing entries with\nincreased or decreased leaked bytes/blocks since previous leak\nsearch.","pl":"pub fn doChangedLeakCheck() void {\n    doMemCheckClientRequestStmt(.DO_LEAK_CHECK, 0, 2, 0, 0, 0);\n}","src":114,"more_decls":null}{"doc_comment":"Do a summary memory leak check (like --leak-check=summary) mid-execution.","pl":"pub fn doQuickLeakCheck() void {\n    doMemCheckClientRequestStmt(.DO_LEAK_CHECK, 1, 0, 0, 0, 0);\n}","src":119,"more_decls":null}{"pl":"fn countLeaks() CountResult","src":132,"more_decls":null}{"pl":"fn countLeakBlocks() CountResult","src":162,"more_decls":null}{"doc_comment":"Get the validity data for addresses zza and copy it\ninto the provided zzvbits array.  Return values:\n0   if not running on valgrind\n1   success\n2   [previously indicated unaligned arrays;  these are now allowed]\n3   if any parts of zzsrc/zzvbits are not addressable.\nThe metadata is not copied in cases 0, 2 or 3 so it should be\nimpossible to segfault your system by using this call.","pl":"pub fn getVbits(zza: []u8, zzvbits: []u8) u2 {\n    std.debug.assert(zzvbits.len >= zza.len / 8);\n    return @intCast(u2, doMemCheckClientRequestExpr(0, .GetVbits, @ptrToInt(zza.ptr), @ptrToInt(zzvbits), zza.len, 0, 0));\n}","src":200,"more_decls":null}{"doc_comment":"Set the validity data for addresses zza, copying it\nfrom the provided zzvbits array.  Return values:\n0   if not running on valgrind\n1   success\n2   [previously indicated unaligned arrays;  these are now allowed]\n3   if any parts of zza/zzvbits are not addressable.\nThe metadata is not copied in cases 0, 2 or 3 so it should be\nimpossible to segfault your system by using this call.","pl":"pub fn setVbits(zzvbits: []u8, zza: []u8) u2 {\n    std.debug.assert(zzvbits.len >= zza.len / 8);\n    return @intCast(u2, doMemCheckClientRequestExpr(0, .SetVbits, @ptrToInt(zza.ptr), @ptrToInt(zzvbits), zza.len, 0, 0));\n}","src":213,"more_decls":null}{"doc_comment":"Disable and re-enable reporting of addressing errors in the\nspecified address range.","pl":"pub fn disableAddrErrorReportingInRange(qzz: []u8) usize {\n    return doMemCheckClientRequestExpr(0, // default return\n        .DisableAddrErrorReportingInRange, @ptrToInt(qzz.ptr), qzz.len, 0, 0, 0);\n}","src":220,"more_decls":null}{"pl":"pub fn enableAddrErrorReportingInRange(qzz: []u8) usize {\n    return doMemCheckClientRequestExpr(0, // default return\n        .EnableAddrErrorReportingInRange, @ptrToInt(qzz.ptr), qzz.len, 0, 0, 0);\n}","src":225,"more_decls":null}]