[{"doc_comment":"An arbitrary-precision rational number.\n\nMemory is allocated as needed for operations to ensure full precision is kept. The precision\nof a Rational is only bounded by memory.\n\nRational's are always normalized. That is, for a Rational r = p/q where p and q are integers,\ngcd(p, q) = 1 always.\n\nTODO rework this to store its own allocator and use a non-managed big int, to avoid double\nallocator storage.","pl":"pub const Rational = struct ","src":27,"more_decls":{"doc_comment":"Numerator. Determines the sign of the Rational.","pl":"p: Int","src":29,"more_decls":null}{"doc_comment":"Denominator. Sign is ignored.","pl":"q: Int","src":32,"more_decls":null}{"doc_comment":"Create a new Rational. A small amount of memory will be allocated on initialization.\nThis will be 2 * Int.default_capacity.","pl":"pub fn init(a: *Allocator) !Rational {\n    return Rational{\n        .p = try Int.init(a),\n        .q = try Int.initSet(a, 1),\n    };\n}","src":36,"more_decls":null}{"doc_comment":"Frees all memory associated with a Rational.","pl":"pub fn deinit(self: *Rational) void {\n    self.p.deinit();\n    self.q.deinit();\n}","src":44,"more_decls":null}{"doc_comment":"Set a Rational from a primitive integer type.","pl":"pub fn setInt(self: *Rational, a: anytype) !void {\n    try self.p.set(a);\n    try self.q.set(1);\n}","src":50,"more_decls":null}{"doc_comment":"Set a Rational from a string of the form `A/B` where A and B are base-10 integers.","pl":"fn setFloatString(self: *Rational, str: []const u8) !void","src":56,"more_decls":null}{"doc_comment":"Set a Rational from a floating-point value. The rational will have enough precision to\ncompletely represent the provided float.","pl":"fn setFloat(self: *Rational, comptime T: type, f: T) !void","src":134,"more_decls":null}{"doc_comment":"Return a floating-point value that is the closest value to a Rational.\n\nThe result may not be exact if the Rational is too precise or too large for the\ntarget type.","pl":"fn toFloat(self: Rational, comptime T: type) !T","src":191,"more_decls":null}{"doc_comment":"Set a rational from an integer ratio.","pl":"fn setRatio(self: *Rational, p: anytype, q: anytype) !void","src":288,"more_decls":null}{"doc_comment":"Set a Rational directly from an Int.","pl":"pub fn copyInt(self: *Rational, a: Int) !void {\n    try self.p.copy(a.toConst());\n    try self.q.set(1);\n}","src":303,"more_decls":null}{"doc_comment":"Set a Rational directly from a ratio of two Int's.","pl":"fn copyRatio(self: *Rational, a: Int, b: Int) !void","src":309,"more_decls":null}{"doc_comment":"Make a Rational positive.","pl":"pub fn abs(r: *Rational) void {\n    r.p.abs();\n}","src":320,"more_decls":null}{"doc_comment":"Negate the sign of a Rational.","pl":"pub fn negate(r: *Rational) void {\n    r.p.negate();\n}","src":325,"more_decls":null}{"doc_comment":"Efficiently swap a Rational with another. This swaps the limb pointers and a full copy is not\nperformed. The address of the limbs field will not be the same after this function.","pl":"pub fn swap(r: *Rational, other: *Rational) void {\n    r.p.swap(&other.p);\n    r.q.swap(&other.q);\n}","src":331,"more_decls":null}{"doc_comment":"Returns math.Order.lt, math.Order.eq, math.Order.gt if a < b, a == b or a\n> b respectively.","pl":"pub fn order(a: Rational, b: Rational) !math.Order {\n    return cmpInternal(a, b, true);\n}","src":338,"more_decls":null}{"doc_comment":"Returns math.Order.lt, math.Order.eq, math.Order.gt if |a| < |b|, |a| ==\n|b| or |a| > |b| respectively.","pl":"pub fn orderAbs(a: Rational, b: Rational) !math.Order {\n    return cmpInternal(a, b, false);\n}","src":344,"more_decls":null}{"doc_comment":"rma = a + b.\n\nrma, a and b may be aliases. However, it is more efficient if rma does not alias a or b.\n\nReturns an error if memory could not be allocated.","pl":"fn add(rma: *Rational, a: Rational, b: Rational) !void","src":369,"more_decls":null}{"doc_comment":"rma = a - b.\n\nrma, a and b may be aliases. However, it is more efficient if rma does not alias a or b.\n\nReturns an error if memory could not be allocated.","pl":"fn sub(rma: *Rational, a: Rational, b: Rational) !void","src":397,"more_decls":null}{"doc_comment":"rma = a * b.\n\nrma, a and b may be aliases. However, it is more efficient if rma does not alias a or b.\n\nReturns an error if memory could not be allocated.","pl":"pub fn mul(r: *Rational, a: Rational, b: Rational) !void {\n    try r.p.mul(a.p.toConst(), b.p.toConst());\n    try r.q.mul(a.q.toConst(), b.q.toConst());\n    try r.reduce();\n}","src":425,"more_decls":null}{"doc_comment":"rma = a / b.\n\nrma, a and b may be aliases. However, it is more efficient if rma does not alias a or b.\n\nReturns an error if memory could not be allocated.","pl":"fn div(r: *Rational, a: Rational, b: Rational) !void","src":436,"more_decls":null}{"doc_comment":"Invert the numerator and denominator fields of a Rational. p/q => q/p.","pl":"pub fn invert(r: *Rational) void {\n    Int.swap(&r.p, &r.q);\n}","src":447,"more_decls":null}}]