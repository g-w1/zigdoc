[{"doc_comment":"A arbitrary-precision big integer, with a fixed set of mutable limbs.","pl":"pub const Mutable = struct ","src":89,"more_decls":{"doc_comment":"Raw digits. These are:\n\n* Little-endian ordered\n* limbs.len >= 1\n* Zero is represented as limbs.len == 1 with limbs[0] == 0.\n\nAccessing limbs directly should be avoided.\nThese are allocated limbs; the `len` field tells the valid range.","pl":"limbs: []Limb","src":98,"more_decls":null}{"pl":"len: usize","src":99,"more_decls":null}{"pl":"positive: bool","src":100,"more_decls":null}{"pl":"pub fn toConst(self: Mutable) Const {\n    return .{\n        .limbs = self.limbs[0..self.len],\n        .positive = self.positive,\n    };\n}","src":102,"more_decls":null}{"doc_comment":"Asserts that the allocator owns the limbs memory. If this is not the case,\nuse `toConst().toManaged()`.","pl":"fn toManaged(self: Mutable, allocator: *Allocator) Managed","src":111,"more_decls":null}{"doc_comment":"`value` is a primitive integer type.\nAsserts the value fits within the provided `limbs_buffer`.\nNote: `calcLimbLen` can be used to figure out how big an array to allocate for `limbs_buffer`.","pl":"fn init(limbs_buffer: []Limb, value: anytype) Mutable","src":125,"more_decls":null}{"doc_comment":"Copies the value of a Const to an existing Mutable so that they both have the same value.\nAsserts the value fits in the limbs buffer.","pl":"fn copy(self: *Mutable, other: Const) void","src":138,"more_decls":null}{"doc_comment":"Efficiently swap an Mutable with another. This swaps the limb pointers and a full copy is not\nperformed. The address of the limbs field will not be the same after this function.","pl":"pub fn swap(self: *Mutable, other: *Mutable) void {\n    mem.swap(Mutable, self, other);\n}","src":148,"more_decls":null}{"pl":"pub fn dump(self: Mutable) void {\n    for (self.limbs[0..self.len]) |limb| {\n        std.debug.warn(\"{x} \", .{limb});\n    }\n    std.debug.warn(\"capacity={} positive={}\\n\", .{ self.limbs.len, self.positive });\n}","src":152,"more_decls":null}{"doc_comment":"Clones an Mutable and returns a new Mutable with the same value. The new Mutable is a deep copy and\ncan be modified separately from the original.\nAsserts that limbs is big enough to store the value.","pl":"fn clone(other: Mutable, limbs: []Limb) Mutable","src":162,"more_decls":null}{"pl":"pub fn negate(self: *Mutable) void {\n    self.positive = !self.positive;\n}","src":171,"more_decls":null}{"doc_comment":"Modify to become the absolute value","pl":"pub fn abs(self: *Mutable) void {\n    self.positive = true;\n}","src":176,"more_decls":null}{"doc_comment":"Sets the Mutable to value. Value must be an primitive integer type.\nAsserts the value fits within the limbs buffer.\nNote: `calcLimbLen` can be used to figure out how big the limbs buffer\nneeds to be to store a specific value.","pl":"fn set(self: *Mutable, value: anytype) void","src":184,"more_decls":null}{"doc_comment":"Set self from the string representation `value`.\n\n`value` must contain only digits <= `base` and is case insensitive.  Base prefixes are\nnot allowed (e.g. 0x43 should simply be 43).  Underscores in the input string are\nignored and can be used as digit separators.\n\nAsserts there is enough memory for the value in `self.limbs`. An upper bound on number of limbs can\nbe determined with `calcSetStringLimbCount`.\nAsserts the base is in the range [2, 16].\n\nReturns an error if the value has invalid digits for the requested base.\n\n`limbs_buffer` is used for temporary storage. The size required can be found with\n`calcSetStringLimbsBufferLen`.\n\nIf `allocator` is provided, it will be used for temporary storage to improve\nmultiplication performance. `error.OutOfMemory` is handled with a fallback algorithm.","pl":"fn setString(\n    self: *Mutable,\n    base: u8,\n    value: []const u8,\n    limbs_buffer: []Limb,\n    allocator: ?*Allocator,\n) error{InvalidCharacter}!void","src":257,"more_decls":null}{"doc_comment":"r = a + scalar\n\nr and a may be aliases.\nscalar is a primitive integer type.\n\nAsserts the result fits in `r`. An upper bound on the number of limbs needed by\nr is `math.max(a.limbs.len, calcLimbLen(scalar)) + 1`.","pl":"pub fn addScalar(r: *Mutable, a: Const, scalar: anytype) void {\n    var limbs: [calcLimbLen(scalar)]Limb = undefined;\n    const operand = init(&limbs, scalar).toConst();\n    return add(r, a, operand);\n}","src":296,"more_decls":null}{"doc_comment":"r = a + b\n\nr, a and b may be aliases.\n\nAsserts the result fits in `r`. An upper bound on the number of limbs needed by\nr is `math.max(a.limbs.len, b.limbs.len) + 1`.","pl":"fn add(r: *Mutable, a: Const, b: Const) void","src":308,"more_decls":null}{"doc_comment":"r = a - b\n\nr, a and b may be aliases.\n\nAsserts the result fits in `r`. An upper bound on the number of limbs needed by\nr is `math.max(a.limbs.len, b.limbs.len) + 1`. The +1 is not needed if both operands are positive.","pl":"fn sub(r: *Mutable, a: Const, b: Const) void","src":352,"more_decls":null}{"doc_comment":"rma = a * b\n\n`rma` may alias with `a` or `b`.\n`a` and `b` may alias with each other.\n\nAsserts the result fits in `rma`. An upper bound on the number of limbs needed by\nrma is given by `a.limbs.len + b.limbs.len + 1`.\n\n`limbs_buffer` is used for temporary storage. The amount required is given by `calcMulLimbsBufferLen`.","pl":"fn mul(rma: *Mutable, a: Const, b: Const, limbs_buffer: []Limb, allocator: ?*Allocator) void","src":398,"more_decls":null}{"doc_comment":"rma = a * b\n\n`rma` may not alias with `a` or `b`.\n`a` and `b` may alias with each other.\n\nAsserts the result fits in `rma`. An upper bound on the number of limbs needed by\nrma is given by `a.limbs.len + b.limbs.len + 1`.\n\nIf `allocator` is provided, it will be used for temporary storage to improve\nmultiplication performance. `error.OutOfMemory` is handled with a fallback algorithm.","pl":"fn mulNoAlias(rma: *Mutable, a: Const, b: Const, allocator: ?*Allocator) void","src":428,"more_decls":null}{"doc_comment":"rma = a * a\n\n`rma` may not alias with `a`.\n\nAsserts the result fits in `rma`. An upper bound on the number of limbs needed by\nrma is given by `2 * a.limbs.len + 1`.\n\nIf `allocator` is provided, it will be used for temporary storage to improve\nmultiplication performance. `error.OutOfMemory` is handled with a fallback algorithm.","pl":"fn sqrNoAlias(rma: *Mutable, a: Const, opt_allocator: ?*Allocator) void","src":457,"more_decls":null}{"doc_comment":"q = a / b (rem r)\n\na / b are floored (rounded towards 0).\nq may alias with a or b.\n\nAsserts there is enough memory to store q and r.\nThe upper bound for r limb count is a.limbs.len.\nThe upper bound for q limb count is given by `a.limbs.len + b.limbs.len + 1`.\n\nIf `allocator` is provided, it will be used for temporary storage to improve\nmultiplication performance. `error.OutOfMemory` is handled with a fallback algorithm.\n\n`limbs_buffer` is used for temporary storage. The amount required is given by `calcDivLimbsBufferLen`.","pl":"fn divFloor(\n    q: *Mutable,\n    r: *Mutable,\n    a: Const,\n    b: Const,\n    limbs_buffer: []Limb,\n    allocator: ?*Allocator,\n) void","src":481,"more_decls":null}{"doc_comment":"q = a / b (rem r)\n\na / b are truncated (rounded towards -inf).\nq may alias with a or b.\n\nAsserts there is enough memory to store q and r.\nThe upper bound for r limb count is a.limbs.len.\nThe upper bound for q limb count is given by `calcQuotientLimbLen`. This accounts\nfor temporary space used by the division algorithm.\n\nIf `allocator` is provided, it will be used for temporary storage to improve\nmultiplication performance. `error.OutOfMemory` is handled with a fallback algorithm.\n\n`limbs_buffer` is used for temporary storage. The amount required is given by `calcDivLimbsBufferLen`.","pl":"fn divTrunc(\n    q: *Mutable,\n    r: *Mutable,\n    a: Const,\n    b: Const,\n    limbs_buffer: []Limb,\n    allocator: ?*Allocator,\n) void","src":514,"more_decls":null}{"doc_comment":"r = a << shift, in other words, r = a * 2^shift\n\nr and a may alias.\n\nAsserts there is enough memory to fit the result. The upper bound Limb count is\n`a.limbs.len + (shift / (@sizeOf(Limb) * 8))`.","pl":"pub fn shiftLeft(r: *Mutable, a: Const, shift: usize) void {\n    llshl(r.limbs[0..], a.limbs[0..a.limbs.len], shift);\n    r.normalize(a.limbs.len + (shift / limb_bits) + 1);\n    r.positive = a.positive;\n}","src":532,"more_decls":null}{"doc_comment":"r = a >> shift\nr and a may alias.\n\nAsserts there is enough memory to fit the result. The upper bound Limb count is\n`a.limbs.len - (shift / (@sizeOf(Limb) * 8))`.","pl":"fn shiftRight(r: *Mutable, a: Const, shift: usize) void","src":543,"more_decls":null}{"doc_comment":"r = a | b\nr may alias with a or b.\n\na and b are zero-extended to the longer of a or b.\n\nAsserts that r has enough limbs to store the result. Upper bound is `math.max(a.limbs.len, b.limbs.len)`.","pl":"fn bitOr(r: *Mutable, a: Const, b: Const) void","src":562,"more_decls":null}{"doc_comment":"r = a & b\nr may alias with a or b.\n\nAsserts that r has enough limbs to store the result. Upper bound is `math.min(a.limbs.len, b.limbs.len)`.","pl":"fn bitAnd(r: *Mutable, a: Const, b: Const) void","src":576,"more_decls":null}{"doc_comment":"r = a ^ b\nr may alias with a or b.\n\nAsserts that r has enough limbs to store the result. Upper bound is `math.max(a.limbs.len, b.limbs.len)`.","pl":"fn bitXor(r: *Mutable, a: Const, b: Const) void","src":590,"more_decls":null}{"doc_comment":"rma may alias x or y.\nx and y may alias each other.\nAsserts that `rma` has enough limbs to store the result. Upper bound is\n`math.min(x.limbs.len, y.limbs.len)`.\n\n`limbs_buffer` is used for temporary storage during the operation. When this function returns,\nit will have the same length as it had when the function was called.","pl":"fn gcd(rma: *Mutable, x: Const, y: Const, limbs_buffer: *std.ArrayList(Limb)) !void","src":607,"more_decls":null}{"doc_comment":"q = a ^ b\n\nr may not alias a.\n\nAsserts that `r` has enough limbs to store the result. Upper bound is\n`calcPowLimbsBufferLen(a.bitCountAbs(), b)`.\n\n`limbs_buffer` is used for temporary storage.\nThe amount required is given by `calcPowLimbsBufferLen`.","pl":"fn pow(r: *Mutable, a: Const, b: u32, limbs_buffer: []Limb) !void","src":633,"more_decls":null}{"doc_comment":"rma may not alias x or y.\nx and y may alias each other.\nAsserts that `rma` has enough limbs to store the result. Upper bound is given by `calcGcdNoAliasLimbLen`.\n\n`limbs_buffer` is used for temporary storage during the operation.","pl":"pub fn gcdNoAlias(rma: *Mutable, x: Const, y: Const, limbs_buffer: *std.ArrayList(Limb)) !void {\n    assert(rma.limbs.ptr != x.limbs.ptr); // illegal aliasing\n    assert(rma.limbs.ptr != y.limbs.ptr); // illegal aliasing\n    return gcdLehmer(rma, x, y, allocator);\n}","src":675,"more_decls":null}}{"doc_comment":"A arbitrary-precision big integer, with a fixed set of immutable limbs.","pl":"pub const Const = struct ","src":964,"more_decls":{"doc_comment":"Raw digits. These are:\n\n* Little-endian ordered\n* limbs.len >= 1\n* Zero is represented as limbs.len == 1 with limbs[0] == 0.\n\nAccessing limbs directly should be avoided.","pl":"limbs: []const Limb","src":972,"more_decls":null}{"pl":"positive: bool","src":973,"more_decls":null}{"doc_comment":"The result is an independent resource which is managed by the caller.","pl":"fn toManaged(self: Const, allocator: *Allocator) Allocator.Error!Managed","src":976,"more_decls":null}{"doc_comment":"Asserts `limbs` is big enough to store the value.","pl":"fn toMutable(self: Const, limbs: []Limb) Mutable","src":990,"more_decls":null}{"pl":"pub fn dump(self: Const) void {\n    for (self.limbs[0..self.limbs.len]) |limb| {\n        std.debug.warn(\"{x} \", .{limb});\n    }\n    std.debug.warn(\"positive={}\\n\", .{self.positive});\n}","src":999,"more_decls":null}{"pl":"pub fn abs(self: Const) Const {\n    return .{\n        .limbs = self.limbs,\n        .positive = true,\n    };\n}","src":1006,"more_decls":null}{"pl":"pub fn isOdd(self: Const) bool {\n    return self.limbs[0] & 1 != 0;\n}","src":1013,"more_decls":null}{"pl":"pub fn isEven(self: Const) bool {\n    return !self.isOdd();\n}","src":1017,"more_decls":null}{"doc_comment":"Returns the number of bits required to represent the absolute value of an integer.","pl":"pub fn bitCountAbs(self: Const) usize {\n    return (self.limbs.len - 1) * limb_bits + (limb_bits - @clz(Limb, self.limbs[self.limbs.len - 1]));\n}","src":1022,"more_decls":null}{"doc_comment":"Returns the number of bits required to represent the integer in twos-complement form.\n\nIf the integer is negative the value returned is the number of bits needed by a signed\ninteger to represent the value. If positive the value is the number of bits for an\nunsigned integer. Any unsigned integer will fit in the signed integer with bitcount\none greater than the returned value.\n\ne.g. -127 returns 8 as it will fit in an i8. 127 returns 7 since it fits in a u7.","pl":"fn bitCountTwosComp(self: Const) usize","src":1034,"more_decls":null}{"pl":"fn fitsInTwosComp(self: Const, signedness: std.builtin.Signedness, bit_count: usize) bool","src":1056,"more_decls":null}{"doc_comment":"Returns whether self can fit into an integer of the requested type.","pl":"pub fn fits(self: Const, comptime T: type) bool {\n    const info = @typeInfo(T).Int;\n    return self.fitsInTwosComp(info.signedness, info.bits);\n}","src":1069,"more_decls":null}{"doc_comment":"Returns the approximate size of the integer in the given base. Negative values accommodate for\nthe minus sign. This is used for determining the number of characters needed to print the\nvalue. It is inexact and may exceed the given value by ~1-2 bytes.\nTODO See if we can make this exact.","pl":"pub fn sizeInBaseUpperBound(self: Const, base: usize) usize {\n    const bit_count = @as(usize, @boolToInt(!self.positive)) + self.bitCountAbs();\n    return (bit_count / math.log2(base)) + 2;\n}","src":1078,"more_decls":null}{"doc_comment":"Convert self to type T.\n\nReturns an error if self cannot be narrowed into the requested type without truncation.","pl":"fn to(self: Const, comptime T: type) ConvertError!T","src":1091,"more_decls":null}{"doc_comment":"To allow `std.fmt.format` to work with this type.\nIf the integer is larger than `pow(2, 64 * @sizeOf(usize) * 8), this function will fail\nto print the string, printing \"(BigInt)\" instead of a number.\nThis is because the rendering algorithm requires reversing a string, which requires O(N) memory.\nSee `toString` and `toStringAlloc` for a way to print big integers without failure.","pl":"fn format(\n    self: Const,\n    comptime fmt: []const u8,\n    options: std.fmt.FormatOptions,\n    out_stream: anytype,\n) !void","src":1135,"more_decls":null}{"doc_comment":"Converts self to a string in the requested base.\nCaller owns returned memory.\nAsserts that `base` is in the range [2, 16].\nSee also `toString`, a lower level function than this.","pl":"fn toStringAlloc(self: Const, allocator: *Allocator, base: u8, uppercase: bool) Allocator.Error![]u8","src":1181,"more_decls":null}{"doc_comment":"Converts self to a string in the requested base.\nAsserts that `base` is in the range [2, 16].\n`string` is a caller-provided slice of at least `sizeInBaseUpperBound` bytes,\nwhere the result is written to.\nReturns the length of the string.\n`limbs_buffer` is caller-provided memory for `toString` to use as a working area. It must have\nlength of at least `calcToStringLimbsBufferLen`.\nIn the case of power-of-two base, `limbs_buffer` is ignored.\nSee also `toStringAlloc`, a higher level function than this.","pl":"fn toString(self: Const, string: []u8, base: u8, uppercase: bool, limbs_buffer: []Limb) usize","src":1206,"more_decls":null}{"doc_comment":"Returns `math.Order.lt`, `math.Order.eq`, `math.Order.gt` if\n`|a| < |b|`, `|a| == |b|`, or `|a| > |b|` respectively.","pl":"fn orderAbs(a: Const, b: Const) math.Order","src":1303,"more_decls":null}{"doc_comment":"Returns `math.Order.lt`, `math.Order.eq`, `math.Order.gt` if `a < b`, `a == b` or `a > b` respectively.","pl":"fn order(a: Const, b: Const) math.Order","src":1328,"more_decls":null}{"doc_comment":"Same as `order` but the right-hand operand is a primitive integer.","pl":"pub fn orderAgainstScalar(lhs: Const, scalar: anytype) math.Order {\n    var limbs: [calcLimbLen(scalar)]Limb = undefined;\n    const rhs = Mutable.init(&limbs, scalar);\n    return order(lhs, rhs.toConst());\n}","src":1342,"more_decls":null}{"doc_comment":"Returns true if `a == 0`.","pl":"pub fn eqZero(a: Const) bool {\n    var d: Limb = 0;\n    for (a.limbs) |limb| d |= limb;\n    return d == 0;\n}","src":1349,"more_decls":null}{"doc_comment":"Returns true if `|a| == |b|`.","pl":"pub fn eqAbs(a: Const, b: Const) bool {\n    return orderAbs(a, b) == .eq;\n}","src":1356,"more_decls":null}{"doc_comment":"Returns true if `a == b`.","pl":"pub fn eq(a: Const, b: Const) bool {\n    return order(a, b) == .eq;\n}","src":1361,"more_decls":null}{"pl":"const ConvertError = error{\n        NegativeIntoUnsigned,\n        TargetTooSmall,\n    }","src":1083,"more_decls":null}}{"doc_comment":"An arbitrary-precision big integer along with an allocator which manages the memory.\n\nMemory is allocated as needed to ensure operations never overflow. The range\nis bounded only by available memory.","pl":"pub const Managed = struct ","src":1370,"more_decls":{"doc_comment":"Allocator used by the Managed when requesting memory.","pl":"allocator: *Allocator","src":1377,"more_decls":null}{"doc_comment":"Raw digits. These are:\n\n* Little-endian ordered\n* limbs.len >= 1\n* Zero is represent as Managed.len() == 1 with limbs[0] == 0.\n\nAccessing limbs directly should be avoided.","pl":"limbs: []Limb","src":1386,"more_decls":null}{"doc_comment":"High bit is the sign bit. If set, Managed is negative, else Managed is positive.\nThe remaining bits represent the number of limbs used by Managed.","pl":"metadata: usize","src":1390,"more_decls":null}{"doc_comment":"Creates a new `Managed`. `default_capacity` limbs will be allocated immediately.\nThe integer value after initializing is `0`.","pl":"pub fn init(allocator: *Allocator) !Managed {\n    return initCapacity(allocator, default_capacity);\n}","src":1394,"more_decls":null}{"pl":"fn toMutable(self: Managed) Mutable","src":1398,"more_decls":null}{"pl":"pub fn toConst(self: Managed) Const {\n    return .{\n        .limbs = self.limbs[0..self.len()],\n        .positive = self.isPositive(),\n    };\n}","src":1406,"more_decls":null}{"doc_comment":"Creates a new `Managed` with value `value`.\n\nThis is identical to an `init`, followed by a `set`.","pl":"pub fn initSet(allocator: *Allocator, value: anytype) !Managed {\n    var s = try Managed.init(allocator);\n    try s.set(value);\n    return s;\n}","src":1416,"more_decls":null}{"doc_comment":"Creates a new Managed with a specific capacity. If capacity < default_capacity then the\ndefault capacity will be used instead.\nThe integer value after initializing is `0`.","pl":"fn initCapacity(allocator: *Allocator, capacity: usize) !Managed","src":1425,"more_decls":null}{"doc_comment":"Returns the number of limbs currently in use.","pl":"pub fn len(self: Managed) usize {\n    return self.metadata & ~sign_bit;\n}","src":1438,"more_decls":null}{"doc_comment":"Returns whether an Managed is positive.","pl":"pub fn isPositive(self: Managed) bool {\n    return self.metadata & sign_bit == 0;\n}","src":1443,"more_decls":null}{"doc_comment":"Sets the sign of an Managed.","pl":"fn setSign(self: *Managed, positive: bool) void","src":1448,"more_decls":null}{"doc_comment":"Sets the length of an Managed.\n\nIf setLen is used, then the Managed must be normalized to suit.","pl":"pub fn setLen(self: *Managed, new_len: usize) void {\n    self.metadata &= sign_bit;\n    self.metadata |= new_len;\n}","src":1459,"more_decls":null}{"pl":"pub fn setMetadata(self: *Managed, positive: bool, length: usize) void {\n    self.metadata = if (positive) length & ~sign_bit else length | sign_bit;\n}","src":1464,"more_decls":null}{"doc_comment":"Ensures an Managed has enough space allocated for capacity limbs. If the Managed does not have\nsufficient capacity, the exact amount will be allocated. This occurs even if the requested\ncapacity is only greater than the current capacity by one limb.","pl":"pub fn ensureCapacity(self: *Managed, capacity: usize) !void {\n    if (capacity <= self.limbs.len) {\n        return;\n    }\n    self.limbs = try self.allocator.realloc(self.limbs, capacity);\n}","src":1471,"more_decls":null}{"doc_comment":"Frees all associated memory.","pl":"pub fn deinit(self: *Managed) void {\n    self.allocator.free(self.limbs);\n    self.* = undefined;\n}","src":1479,"more_decls":null}{"doc_comment":"Returns a `Managed` with the same value. The returned `Managed` is a deep copy and\ncan be modified separately from the original, and its resources are managed\nseparately from the original.","pl":"pub fn clone(other: Managed) !Managed {\n    return other.cloneWithDifferentAllocator(other.allocator);\n}","src":1487,"more_decls":null}{"pl":"fn cloneWithDifferentAllocator(other: Managed, allocator: *Allocator) !Managed","src":1491,"more_decls":null}{"doc_comment":"Copies the value of the integer to an existing `Managed` so that they both have the same value.\nExtra memory will be allocated if the receiver does not have enough capacity.","pl":"fn copy(self: *Managed, other: Const) !void","src":1505,"more_decls":null}{"doc_comment":"Efficiently swap a `Managed` with another. This swaps the limb pointers and a full copy is not\nperformed. The address of the limbs field will not be the same after this function.","pl":"pub fn swap(self: *Managed, other: *Managed) void {\n    mem.swap(Managed, self, other);\n}","src":1515,"more_decls":null}{"doc_comment":"Debugging tool: prints the state to stderr.","pl":"pub fn dump(self: Managed) void {\n    for (self.limbs[0..self.len()]) |limb| {\n        std.debug.warn(\"{x} \", .{limb});\n    }\n    std.debug.warn(\"capacity={} positive={}\\n\", .{ self.limbs.len, self.isPositive() });\n}","src":1520,"more_decls":null}{"doc_comment":"Negate the sign.","pl":"pub fn negate(self: *Managed) void {\n    self.metadata ^= sign_bit;\n}","src":1528,"more_decls":null}{"doc_comment":"Make positive.","pl":"pub fn abs(self: *Managed) void {\n    self.metadata &= ~sign_bit;\n}","src":1533,"more_decls":null}{"pl":"pub fn isOdd(self: Managed) bool {\n    return self.limbs[0] & 1 != 0;\n}","src":1537,"more_decls":null}{"pl":"pub fn isEven(self: Managed) bool {\n    return !self.isOdd();\n}","src":1541,"more_decls":null}{"doc_comment":"Returns the number of bits required to represent the absolute value of an integer.","pl":"pub fn bitCountAbs(self: Managed) usize {\n    return self.toConst().bitCountAbs();\n}","src":1546,"more_decls":null}{"doc_comment":"Returns the number of bits required to represent the integer in twos-complement form.\n\nIf the integer is negative the value returned is the number of bits needed by a signed\ninteger to represent the value. If positive the value is the number of bits for an\nunsigned integer. Any unsigned integer will fit in the signed integer with bitcount\none greater than the returned value.\n\ne.g. -127 returns 8 as it will fit in an i8. 127 returns 7 since it fits in a u7.","pl":"pub fn bitCountTwosComp(self: Managed) usize {\n    return self.toConst().bitCountTwosComp();\n}","src":1558,"more_decls":null}{"pl":"pub fn fitsInTwosComp(self: Managed, signedness: std.builtin.Signedness, bit_count: usize) bool {\n    return self.toConst().fitsInTwosComp(signedness, bit_count);\n}","src":1562,"more_decls":null}{"doc_comment":"Returns whether self can fit into an integer of the requested type.","pl":"pub fn fits(self: Managed, comptime T: type) bool {\n    return self.toConst().fits(T);\n}","src":1567,"more_decls":null}{"doc_comment":"Returns the approximate size of the integer in the given base. Negative values accommodate for\nthe minus sign. This is used for determining the number of characters needed to print the\nvalue. It is inexact and may exceed the given value by ~1-2 bytes.","pl":"pub fn sizeInBaseUpperBound(self: Managed, base: usize) usize {\n    return self.toConst().sizeInBaseUpperBound(base);\n}","src":1574,"more_decls":null}{"doc_comment":"Sets an Managed to value. Value must be an primitive integer type.","pl":"pub fn set(self: *Managed, value: anytype) Allocator.Error!void {\n    try self.ensureCapacity(calcLimbLen(value));\n    var m = self.toMutable();\n    m.set(value);\n    self.setMetadata(m.positive, m.len);\n}","src":1579,"more_decls":null}{"doc_comment":"Convert self to type T.\n\nReturns an error if self cannot be narrowed into the requested type without truncation.","pl":"pub fn to(self: Managed, comptime T: type) ConvertError!T {\n    return self.toConst().to(T);\n}","src":1591,"more_decls":null}{"doc_comment":"Set self from the string representation `value`.\n\n`value` must contain only digits <= `base` and is case insensitive.  Base prefixes are\nnot allowed (e.g. 0x43 should simply be 43).  Underscores in the input string are\nignored and can be used as digit separators.\n\nReturns an error if memory could not be allocated or `value` has invalid digits for the\nrequested base.\n\nself's allocator is used for temporary storage to boost multiplication performance.","pl":"fn setString(self: *Managed, base: u8, value: []const u8) !void","src":1605,"more_decls":null}{"doc_comment":"Converts self to a string in the requested base. Memory is allocated from the provided\nallocator and not the one present in self.","pl":"pub fn toString(self: Managed, allocator: *Allocator, base: u8, uppercase: bool) ![]u8 {\n    if (base < 2 or base > 16) return error.InvalidBase;\n    return self.toConst().toStringAlloc(self.allocator, base, uppercase);\n}","src":1617,"more_decls":null}{"doc_comment":"To allow `std.fmt.format` to work with `Managed`.\nIf the integer is larger than `pow(2, 64 * @sizeOf(usize) * 8), this function will fail\nto print the string, printing \"(BigInt)\" instead of a number.\nThis is because the rendering algorithm requires reversing a string, which requires O(N) memory.\nSee `toString` and `toStringAlloc` for a way to print big integers without failure.","pl":"fn format(\n    self: Managed,\n    comptime fmt: []const u8,\n    options: std.fmt.FormatOptions,\n    out_stream: anytype,\n) !void","src":1627,"more_decls":null}{"doc_comment":"Returns math.Order.lt, math.Order.eq, math.Order.gt if |a| < |b|, |a| ==\n|b| or |a| > |b| respectively.","pl":"pub fn orderAbs(a: Managed, b: Managed) math.Order {\n    return a.toConst().orderAbs(b.toConst());\n}","src":1638,"more_decls":null}{"doc_comment":"Returns math.Order.lt, math.Order.eq, math.Order.gt if a < b, a == b or a\n> b respectively.","pl":"pub fn order(a: Managed, b: Managed) math.Order {\n    return a.toConst().order(b.toConst());\n}","src":1644,"more_decls":null}{"doc_comment":"Returns true if a == 0.","pl":"pub fn eqZero(a: Managed) bool {\n    return a.toConst().eqZero();\n}","src":1649,"more_decls":null}{"doc_comment":"Returns true if |a| == |b|.","pl":"pub fn eqAbs(a: Managed, b: Managed) bool {\n    return a.toConst().eqAbs(b.toConst());\n}","src":1654,"more_decls":null}{"doc_comment":"Returns true if a == b.","pl":"pub fn eq(a: Managed, b: Managed) bool {\n    return a.toConst().eq(b.toConst());\n}","src":1659,"more_decls":null}{"doc_comment":"Normalize a possible sequence of leading zeros.\n\n[1, 2, 3, 4, 0] -> [1, 2, 3, 4]\n[1, 2, 0, 0, 0] -> [1, 2]\n[0, 0, 0, 0, 0] -> [0]","pl":"fn normalize(r: *Managed, length: usize) void","src":1668,"more_decls":null}{"doc_comment":"r = a + scalar\n\nr and a may be aliases.\nscalar is a primitive integer type.\n\nReturns an error if memory could not be allocated.","pl":"pub fn addScalar(r: *Managed, a: Const, scalar: anytype) Allocator.Error!void {\n    try r.ensureCapacity(math.max(a.limbs.len, calcLimbLen(scalar)) + 1);\n    var m = r.toMutable();\n    m.addScalar(a, scalar);\n    r.setMetadata(m.positive, m.len);\n}","src":1689,"more_decls":null}{"doc_comment":"r = a + b\n\nr, a and b may be aliases.\n\nReturns an error if memory could not be allocated.","pl":"pub fn add(r: *Managed, a: Const, b: Const) Allocator.Error!void {\n    try r.ensureCapacity(math.max(a.limbs.len, b.limbs.len) + 1);\n    var m = r.toMutable();\n    m.add(a, b);\n    r.setMetadata(m.positive, m.len);\n}","src":1701,"more_decls":null}{"doc_comment":"r = a - b\n\nr, a and b may be aliases.\n\nReturns an error if memory could not be allocated.","pl":"pub fn sub(r: *Managed, a: Const, b: Const) !void {\n    try r.ensureCapacity(math.max(a.limbs.len, b.limbs.len) + 1);\n    var m = r.toMutable();\n    m.sub(a, b);\n    r.setMetadata(m.positive, m.len);\n}","src":1713,"more_decls":null}{"doc_comment":"rma = a * b\n\nrma, a and b may be aliases. However, it is more efficient if rma does not alias a or b.\nIf rma aliases a or b, then caller must call `rma.ensureMulCapacity` prior to calling `mul`.\n\nReturns an error if memory could not be allocated.\n\nrma's allocator is used for temporary storage to speed up the multiplication.","pl":"fn mul(rma: *Managed, a: Const, b: Const) !void","src":1728,"more_decls":null}{"pl":"pub fn ensureMulCapacity(rma: *Managed, a: Const, b: Const) !void {\n    try rma.ensureCapacity(a.limbs.len + b.limbs.len + 1);\n}","src":1748,"more_decls":null}{"doc_comment":"q = a / b (rem r)\n\na / b are floored (rounded towards 0).\n\nReturns an error if memory could not be allocated.\n\nq's allocator is used for temporary storage to speed up the multiplication.","pl":"fn divFloor(q: *Managed, r: *Managed, a: Const, b: Const) !void","src":1759,"more_decls":null}{"doc_comment":"q = a / b (rem r)\n\na / b are truncated (rounded towards -inf).\n\nReturns an error if memory could not be allocated.\n\nq's allocator is used for temporary storage to speed up the multiplication.","pl":"fn divTrunc(q: *Managed, r: *Managed, a: Const, b: Const) !void","src":1778,"more_decls":null}{"doc_comment":"r = a << shift, in other words, r = a * 2^shift","pl":"pub fn shiftLeft(r: *Managed, a: Managed, shift: usize) !void {\n    try r.ensureCapacity(a.len() + (shift / limb_bits) + 1);\n    var m = r.toMutable();\n    m.shiftLeft(a.toConst(), shift);\n    r.setMetadata(m.positive, m.len);\n}","src":1791,"more_decls":null}{"doc_comment":"r = a >> shift","pl":"fn shiftRight(r: *Managed, a: Managed, shift: usize) !void","src":1799,"more_decls":null}{"doc_comment":"r = a | b\n\na and b are zero-extended to the longer of a or b.","pl":"pub fn bitOr(r: *Managed, a: Managed, b: Managed) !void {\n    try r.ensureCapacity(math.max(a.len(), b.len()));\n    var m = r.toMutable();\n    m.bitOr(a.toConst(), b.toConst());\n    r.setMetadata(m.positive, m.len);\n}","src":1815,"more_decls":null}{"doc_comment":"r = a & b","pl":"pub fn bitAnd(r: *Managed, a: Managed, b: Managed) !void {\n    try r.ensureCapacity(math.min(a.len(), b.len()));\n    var m = r.toMutable();\n    m.bitAnd(a.toConst(), b.toConst());\n    r.setMetadata(m.positive, m.len);\n}","src":1823,"more_decls":null}{"doc_comment":"r = a ^ b","pl":"pub fn bitXor(r: *Managed, a: Managed, b: Managed) !void {\n    try r.ensureCapacity(math.max(a.len(), b.len()));\n    var m = r.toMutable();\n    m.bitXor(a.toConst(), b.toConst());\n    r.setMetadata(m.positive, m.len);\n}","src":1831,"more_decls":null}{"doc_comment":"rma may alias x or y.\nx and y may alias each other.\n\nrma's allocator is used for temporary storage to boost multiplication performance.","pl":"fn gcd(rma: *Managed, x: Managed, y: Managed) !void","src":1842,"more_decls":null}{"doc_comment":"r = a * a","pl":"fn sqr(rma: *Managed, a: Const) !void","src":1852,"more_decls":null}{"pl":"fn pow(rma: *Managed, a: Const, b: u32) !void","src":1872,"more_decls":null}{"pl":"const sign_bit: usize = 1 << (@typeInfo(usize).Int.bits - 1)","src":1371,"more_decls":null}{"doc_comment":"Default number of limbs to allocate on creation of a `Managed`.","pl":"const default_capacity = 4","src":1374,"more_decls":null}{"pl":"const ConvertError = Const.ConvertError","src":1586,"more_decls":null}}{"doc_comment":"Returns the number of limbs needed to store `scalar`, which must be a\nprimitive integer value.","pl":"fn calcLimbLen(scalar: anytype) usize","src":22,"more_decls":null}{"pl":"pub fn calcToStringLimbsBufferLen(a_len: usize, base: u8) usize {\n    if (math.isPowerOfTwo(base))\n        return 0;\n    return a_len + 2 + a_len + calcDivLimbsBufferLen(a_len, 1);\n}","src":37,"more_decls":null}{"pl":"pub fn calcDivLimbsBufferLen(a_len: usize, b_len: usize) usize {\n    return calcMulLimbsBufferLen(a_len, b_len, 2) * 4;\n}","src":43,"more_decls":null}{"pl":"pub fn calcMulLimbsBufferLen(a_len: usize, b_len: usize, aliases: usize) usize {\n    return aliases * math.max(a_len, b_len);\n}","src":47,"more_decls":null}{"pl":"pub fn calcSetStringLimbsBufferLen(base: u8, string_len: usize) usize {\n    const limb_count = calcSetStringLimbCount(base, string_len);\n    return calcMulLimbsBufferLen(limb_count, limb_count, 2);\n}","src":51,"more_decls":null}{"pl":"pub fn calcSetStringLimbCount(base: u8, string_len: usize) usize {\n    return (string_len + (limb_bits / base - 1)) / (limb_bits / base);\n}","src":56,"more_decls":null}{"pl":"pub fn calcPowLimbsBufferLen(a_bit_count: usize, y: usize) usize {\n    // The 2 accounts for the minimum space requirement for llmulacc\n    return 2 + (a_bit_count * y + (limb_bits - 1)) / limb_bits;\n}","src":60,"more_decls":null}{"doc_comment":"a + b * c + *carry, sets carry to the overflow bits","pl":"fn addMulLimbWithCarry(a: Limb, b: Limb, c: Limb, carry: *Limb) Limb","src":66,"more_decls":null}{"doc_comment":"Returns -1, 0, 1 if |a| < |b|, |a| == |b| or |a| > |b| respectively for limbs.","pl":"fn llcmp(a: []const Limb, b: []const Limb) i8","src":2025,"more_decls":null}]