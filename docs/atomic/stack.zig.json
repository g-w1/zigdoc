[{"doc_comment":"Many reader, many writer, non-allocating, thread-safe\nUses a spinlock to protect push() and pop()\nWhen building in single threaded mode, this is a simple linked list.","pl":"fn Stack(comptime T: type) type","sub_container_type":"struct ","src":12,"more_decls":{"pl":"root: ?*Node","src":14,"more_decls":null}{"pl":"lock: @TypeOf(lock_init)","src":15,"more_decls":null}{"pl":"pub const Node = struct ","src":21,"more_decls":{"pl":"next: ?*Node","src":22,"more_decls":null}{"pl":"data: T","src":23,"more_decls":null}}{"pl":"pub fn init() Self {\n    return Self{\n        .root = null,\n        .lock = lock_init,\n    };\n}","src":26,"more_decls":null}{"doc_comment":"push operation, but only if you are the first item in the stack. if you did not succeed in\nbeing the first item in the stack, returns the other item that was there.","pl":"pub fn pushFirst(self: *Self, node: *Node) ?*Node {\n    node.next = null;\n    return @cmpxchgStrong(?*Node, &self.root, null, node, .SeqCst, .SeqCst);\n}","src":35,"more_decls":null}{"pl":"fn push(self: *Self, node: *Node) void","src":40,"more_decls":null}{"pl":"fn pop(self: *Self) ?*Node","src":53,"more_decls":null}{"pl":"pub fn isEmpty(self: *Self) bool {\n    return @atomicLoad(?*Node, &self.root, .SeqCst) == null;\n}","src":68,"more_decls":null}{"pl":"const Self = @This()","src":19,"more_decls":null}}]