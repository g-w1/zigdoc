[{"pl":"pub const CIntLiteralRadix = enum ","src":1129,"more_decls":{"pl":"decimal","src":1129,"more_decls":null}{"pl":"octal","src":1129,"more_decls":null}{"pl":"hexadecimal ","src":1129,"more_decls":null}}{"pl":"fn tagName(v: anytype) []const u8","src":18,"more_decls":null}{"pl":"fn stringToEnum(comptime T: type, str: []const u8) ?T","src":61,"more_decls":null}{"pl":"fn bitCount(comptime T: type) comptime_int","src":105,"more_decls":null}{"pl":"pub fn alignment(comptime T: type) comptime_int {\n    //@alignOf works on non-pointer types\n    const P = if (comptime trait.is(.Pointer)(T)) T else *T;\n    return @typeInfo(P).Pointer.alignment;\n}","src":119,"more_decls":null}{"pl":"fn Child(comptime T: type) type","src":133,"more_decls":null}{"doc_comment":"Given a \"memory span\" type, returns the \"element type\".","pl":"fn Elem(comptime T: type) type","src":152,"more_decls":null}{"doc_comment":"Given a type which can have a sentinel e.g. `[:0]u8`, returns the sentinel value,\nor `null` if there is not one.\nTypes which cannot possibly have a sentinel will be a compile error.","pl":"fn sentinel(comptime T: type) ?Elem(T)","src":189,"more_decls":null}{"doc_comment":"Given a \"memory span\" type, returns the same type except with the given sentinel value.","pl":"fn Sentinel(comptime T: type, comptime sentinel_val: Elem(T)) type","src":225,"more_decls":null}{"doc_comment":"Takes a Slice or Many Pointer and returns it with the Type modified to have the given sentinel value.\nThis function assumes the caller has verified the memory contains the sentinel value.","pl":"fn assumeSentinel(p: anytype, comptime sentinel_val: Elem(@TypeOf(p))) Sentinel(@TypeOf(p), sentinel_val)","src":289,"more_decls":null}{"pl":"fn containerLayout(comptime T: type) TypeInfo.ContainerLayout","src":324,"more_decls":null}{"pl":"fn declarations(comptime T: type) []const TypeInfo.Declaration","src":367,"more_decls":null}{"pl":"fn declarationInfo(comptime T: type, comptime decl_name: []const u8) TypeInfo.Declaration","src":408,"more_decls":null}{"pl":"fn fields(comptime T: type) switch (@typeInfo(T)) {\n    .Struct => []const TypeInfo.StructField,\n    .Union => []const TypeInfo.UnionField,\n    .ErrorSet => []const TypeInfo.Error,\n    .Enum => []const TypeInfo.EnumField,\n    else => @compileError(\"Expected struct, union, error set or enum type, found '\" ++ @typeName(T) ++ \"'\"),\n}","src":444,"more_decls":null}{"pl":"fn fieldInfo(comptime T: type, comptime field: FieldEnum(T)) switch (@typeInfo(T)) {\n    .Struct => TypeInfo.StructField,\n    .Union => TypeInfo.UnionField,\n    .ErrorSet => TypeInfo.Error,\n    .Enum => TypeInfo.EnumField,\n    else => @compileError(\"Expected struct, union, error set or enum type, found '\" ++ @typeName(T) ++ \"'\"),\n}","src":489,"more_decls":null}{"pl":"fn fieldNames(comptime T: type) *const [fields(T).len][]const u8","src":524,"more_decls":null}{"pl":"fn FieldEnum(comptime T: type) type","src":563,"more_decls":null}{"pl":"fn Tag(comptime T: type) type","src":603,"more_decls":null}{"doc_comment":"Returns the active tag of a tagged union","pl":"pub fn activeTag(u: anytype) Tag(@TypeOf(u)) {\n    const T = @TypeOf(u);\n    return @as(Tag(T), u);\n}","src":626,"more_decls":null}{"doc_comment":"Given a tagged union type, and an enum, return the type of the union\nfield corresponding to the enum tag.","pl":"fn TagPayload(comptime U: type, tag: Tag(U)) type","src":653,"more_decls":null}{"doc_comment":"Compares two of any type for equality. Containers are compared on a field-by-field basis,\nwhere possible. Pointers are not followed.","pl":"fn eql(a: anytype, b: @TypeOf(a)) bool","src":681,"more_decls":null}{"pl":"fn intToEnum(comptime EnumTag: type, tag_int: anytype) IntToEnumError!EnumTag","src":827,"more_decls":null}{"doc_comment":"Given a type and a name, return the field index according to source order.\nReturns `null` if the field is not found.","pl":"fn fieldIndex(comptime T: type, comptime name: []const u8) ?comptime_int","src":839,"more_decls":null}{"doc_comment":"Returns a slice of pointers to public declarations of a namespace.","pl":"fn declList(comptime Namespace: type, comptime Decl: type) []const *const Decl","src":850,"more_decls":null}{"pl":"fn Int(comptime signedness: builtin.Signedness, comptime bit_count: u16) type","src":869,"more_decls":null}{"pl":"fn Vector(comptime len: u32, comptime child: type) type","src":878,"more_decls":null}{"doc_comment":"Given a type and value, cast the value to the type as c would.\nThis is for translate-c and is not intended for general use.","pl":"fn cast(comptime DestType: type, target: anytype) DestType","src":889,"more_decls":null}{"doc_comment":"Given a value returns its size as C's sizeof operator would.\nThis is for translate-c and is not intended for general use.","pl":"fn sizeof(target: anytype) usize","src":1016,"more_decls":null}{"doc_comment":"Promote the type of an integer literal until it fits as C would.\nThis is for translate-c and is not intended for general use.","pl":"fn promoteIntLiteral(\n    comptime SuffixType: type,\n    comptime number: comptime_int,\n    comptime radix: CIntLiteralRadix,\n) PromoteIntLiteralReturnType(SuffixType, number, radix)","src":1155,"more_decls":null}{"doc_comment":"For a given function type, returns a tuple type which fields will\ncorrespond to the argument types.\n\nExamples:\n- `ArgsTuple(fn() void)` ⇒ `tuple { }`\n- `ArgsTuple(fn(a: u32) u32)` ⇒ `tuple { u32 }`\n- `ArgsTuple(fn(a: u32, b: f16) noreturn)` ⇒ `tuple { u32, f16 }`","pl":"fn ArgsTuple(comptime Function: type) type","src":1188,"more_decls":null}{"doc_comment":"For a given anonymous list of types, returns a new tuple type\nwith those types as fields.\n\nExamples:\n- `Tuple(&[_]type {})` ⇒ `tuple { }`\n- `Tuple(&[_]type {f32})` ⇒ `tuple { f32 }`\n- `Tuple(&[_]type {f32,u32})` ⇒ `tuple { f32, u32 }`","pl":"fn Tuple(comptime types: []const type) type","src":1230,"more_decls":null}{"doc_comment":"TODO: https://github.com/ziglang/zig/issues/425","pl":"pub fn globalOption(comptime name: []const u8, comptime T: type) ?T {\n    if (!@hasDecl(root, name))\n        return null;\n    return @as(T, @field(root, name));\n}","src":1294,"more_decls":null}{"pl":"const trait = @import(\"meta/trait.zig\")","src":13,"more_decls":null}{"pl":"const TrailerFlags = @import(\"meta/trailer_flags.zig\").TrailerFlags","src":14,"more_decls":null}{"pl":"const TagType = Tag","src":601,"more_decls":null}{"pl":"const IntToEnumError = error{InvalidEnumTag}","src":825,"more_decls":null}{"pl":"const refAllDecls = @compileError(\"refAllDecls has been moved from std.meta to std.testing\")","src":847,"more_decls":null}{"pl":"const IntType = @compileError(\"replaced by std.meta.Int\")","src":867,"more_decls":null}]