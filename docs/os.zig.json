[{"pl":"pub const Arg0Expand = enum ","src":1305,"more_decls":{"pl":"expand","src":1306,"more_decls":null}{"pl":"no_expand","src":1307,"more_decls":null}}{"pl":"pub const ShutdownHow = enum ","src":2749,"more_decls":{"pl":"recv","src":2749,"more_decls":null}{"pl":"send","src":2749,"more_decls":null}{"pl":"both ","src":2749,"more_decls":null}}{"pl":"pub const WaitPidResult = struct ","src":3348,"more_decls":{"pl":"pid: pid_t","src":3349,"more_decls":null}{"pl":"status: u32","src":3350,"more_decls":null}}{"doc_comment":"Closes the file descriptor.\nThis function is not capable of returning any indication of failure. An\napplication which wants to ensure writes have succeeded before closing\nmust call `fsync` before `close`.\nNote: The Zig standard library does not support POSIX thread cancellation.","pl":"fn close(fd: fd_t) void","src":107,"more_decls":null}{"doc_comment":"Obtain a series of random bytes. These bytes can be used to seed user-space\nrandom number generators or for cryptographic purposes.\nWhen linking against libc, this calls the\nappropriate OS-specific library call. Otherwise it uses the zig standard\nlibrary implementation.","pl":"fn getrandom(buffer: []u8) GetRandomError!void","src":136,"more_decls":null}{"doc_comment":"Causes abnormal process termination.\nIf linking against libc, this calls the abort() libc function. Otherwise\nit raises SIGABRT followed by SIGKILL and finally lo","pl":"fn abort() noreturn","src":205,"more_decls":null}{"pl":"fn raise(sig: u8) RaiseError!void","src":237,"more_decls":null}{"pl":"fn kill(pid: pid_t, sig: u8) KillError!void","src":267,"more_decls":null}{"doc_comment":"Exits the program cleanly with the specified status code.","pl":"fn exit(status: u8) noreturn","src":278,"more_decls":null}{"doc_comment":"Returns the number of bytes that were read, which can be less than\nbuf.len. If 0 bytes were read, that means EOF.\nIf `fd` is opened in non blocking mode, the function will return error.WouldBlock\nwhen EAGAIN is received.\n\nLinux has a limit on how many bytes may be transferred in one `read` call, which is `0x7ffff000`\non both 64-bit and 32-bit systems. This is due to using a signed C int as the return value, as\nwell as stuffing the errno codes into the last `4096` values. This is noted on the `read` man page.\nThe limit on Darwin is `0x7fffffff`, trying to read more than that returns EINVAL.\nThe corresponding POSIX limit is `math.maxInt(isize)`.","pl":"fn read(fd: fd_t, buf: []u8) ReadError!usize","src":332,"more_decls":null}{"doc_comment":"Number of bytes read is returned. Upon reading end-of-file, zero is returned.\n\nFor POSIX systems, if `fd` is opened in non blocking mode, the function will\nreturn error.WouldBlock when EAGAIN is received.\nOn Windows, if the application has a global event loop enabled, I/O Completion Ports are\nused to perform the I/O. `error.WouldBlock` is not possible on Windows.\n\nThis operation is non-atomic on the following systems:\n* Windows\nOn these systems, the read races with concurrent writes to the same file descriptor.","pl":"fn readv(fd: fd_t, iov: []const iovec) ReadError!usize","src":400,"more_decls":null}{"doc_comment":"Number of bytes read is returned. Upon reading end-of-file, zero is returned.\n\nRetries when interrupted by a signal.\n\nFor POSIX systems, if `fd` is opened in non blocking mode, the function will\nreturn error.WouldBlock when EAGAIN is received.\nOn Windows, if the application has a global event loop enabled, I/O Completion Ports are\nused to perform the I/O. `error.WouldBlock` is not possible on Windows.\n\nLinux has a limit on how many bytes may be transferred in one `pread` call, which is `0x7ffff000`\non both 64-bit and 32-bit systems. This is due to using a signed C int as the return value, as\nwell as stuffing the errno codes into the last `4096` values. This is noted on the `read` man page.\nThe limit on Darwin is `0x7fffffff`, trying to read more than that returns EINVAL.\nThe corresponding POSIX limit is `math.maxInt(isize)`.","pl":"fn pread(fd: fd_t, buf: []u8, offset: u64) PReadError!usize","src":460,"more_decls":null}{"pl":"fn ftruncate(fd: fd_t, length: u64) TruncateError!void","src":531,"more_decls":null}{"doc_comment":"Number of bytes read is returned. Upon reading end-of-file, zero is returned.\n\nRetries when interrupted by a signal.\n\nFor POSIX systems, if `fd` is opened in non blocking mode, the function will\nreturn error.WouldBlock when EAGAIN is received.\nOn Windows, if the application has a global event loop enabled, I/O Completion Ports are\nused to perform the I/O. `error.WouldBlock` is not possible on Windows.\n\nThis operation is non-atomic on the following systems:\n* Darwin\n* Windows\nOn these systems, the read races with concurrent writes to the same file descriptor.","pl":"fn preadv(fd: fd_t, iov: []const iovec, offset: u64) PReadError!usize","src":604,"more_decls":null}{"doc_comment":"Write to a file descriptor.\nRetries when interrupted by a signal.\nReturns the number of bytes written. If nonzero bytes were supplied, this will be nonzero.\n\nNote that a successful write() may transfer fewer than count bytes.  Such partial  writes  can\noccur  for  various reasons; for example, because there was insufficient space on the disk\ndevice to write all of the requested bytes, or because a blocked write() to a socket,  pipe,  or\nsimilar  was  interrupted by a signal handler after it had transferred some, but before it had\ntransferred all of the requested bytes.  In the event of a partial write, the caller can  make\nanother  write() call to transfer the remaining bytes.  The subsequent call will either\ntransfer further bytes or may result in an error (e.g., if the disk is now full).\n\nFor POSIX systems, if `fd` is opened in non blocking mode, the function will\nreturn error.WouldBlock when EAGAIN is received.\nOn Windows, if the application has a global event loop enabled, I/O Completion Ports are\nused to perform the I/O. `error.WouldBlock` is not possible on Windows.\n\nLinux has a limit on how many bytes may be transferred in one `write` call, which is `0x7ffff000`\non both 64-bit and 32-bit systems. This is due to using a signed C int as the return value, as\nwell as stuffing the errno codes into the last `4096` values. This is noted on the `write` man page.\nThe limit on Darwin is `0x7fffffff`, trying to read more than that returns EINVAL.\nThe corresponding POSIX limit is `math.maxInt(isize)`.","pl":"fn write(fd: fd_t, bytes: []const u8) WriteError!usize","src":701,"more_decls":null}{"doc_comment":"Write multiple buffers to a file descriptor.\nRetries when interrupted by a signal.\nReturns the number of bytes written. If nonzero bytes were supplied, this will be nonzero.\n\nNote that a successful write() may transfer fewer bytes than supplied.  Such partial  writes  can\noccur  for  various reasons; for example, because there was insufficient space on the disk\ndevice to write all of the requested bytes, or because a blocked write() to a socket,  pipe,  or\nsimilar  was  interrupted by a signal handler after it had transferred some, but before it had\ntransferred all of the requested bytes.  In the event of a partial write, the caller can  make\nanother  write() call to transfer the remaining bytes.  The subsequent call will either\ntransfer further bytes or may result in an error (e.g., if the disk is now full).\n\nFor POSIX systems, if `fd` is opened in non blocking mode, the function will\nreturn error.WouldBlock when EAGAIN is received.k`.\nOn Windows, if the application has a global event loop enabled, I/O Completion Ports are\nused to perform the I/O. `error.WouldBlock` is not possible on Windows.\n\nIf `iov.len` is larger than will fit in a `u31`, a partial write will occur.","pl":"fn writev(fd: fd_t, iov: []const iovec_const) WriteError!usize","src":777,"more_decls":null}{"doc_comment":"Write to a file descriptor, with a position offset.\nRetries when interrupted by a signal.\nReturns the number of bytes written. If nonzero bytes were supplied, this will be nonzero.\n\nNote that a successful write() may transfer fewer bytes than supplied.  Such partial  writes  can\noccur  for  various reasons; for example, because there was insufficient space on the disk\ndevice to write all of the requested bytes, or because a blocked write() to a socket,  pipe,  or\nsimilar  was  interrupted by a signal handler after it had transferred some, but before it had\ntransferred all of the requested bytes.  In the event of a partial write, the caller can  make\nanother  write() call to transfer the remaining bytes.  The subsequent call will either\ntransfer further bytes or may result in an error (e.g., if the disk is now full).\n\nFor POSIX systems, if `fd` is opened in non blocking mode, the function will\nreturn error.WouldBlock when EAGAIN is received.\nOn Windows, if the application has a global event loop enabled, I/O Completion Ports are\nused to perform the I/O. `error.WouldBlock` is not possible on Windows.\n\nLinux has a limit on how many bytes may be transferred in one `pwrite` call, which is `0x7ffff000`\non both 64-bit and 32-bit systems. This is due to using a signed C int as the return value, as\nwell as stuffing the errno codes into the last `4096` values. This is noted on the `write` man page.\nThe limit on Darwin is `0x7fffffff`, trying to write more than that returns EINVAL.\nThe corresponding POSIX limit is `math.maxInt(isize)`.","pl":"fn pwrite(fd: fd_t, bytes: []const u8, offset: u64) PWriteError!usize","src":851,"more_decls":null}{"doc_comment":"Write multiple buffers to a file descriptor, with a position offset.\nRetries when interrupted by a signal.\nReturns the number of bytes written. If nonzero bytes were supplied, this will be nonzero.\n\nNote that a successful write() may transfer fewer than count bytes.  Such partial  writes  can\noccur  for  various reasons; for example, because there was insufficient space on the disk\ndevice to write all of the requested bytes, or because a blocked write() to a socket,  pipe,  or\nsimilar  was  interrupted by a signal handler after it had transferred some, but before it had\ntransferred all of the requested bytes.  In the event of a partial write, the caller can  make\nanother  write() call to transfer the remaining bytes.  The subsequent call will either\ntransfer further bytes or may result in an error (e.g., if the disk is now full).\n\nIf `fd` is opened in non blocking mode, the function will\nreturn error.WouldBlock when EAGAIN is received.\n\nThe following systems do not have this syscall, and will return partial writes if more than one\nvector is provided:\n* Darwin\n* Windows\n\nIf `iov.len` is larger than will fit in a `u31`, a partial write will occur.","pl":"fn pwritev(fd: fd_t, iov: []const iovec_const, offset: u64) PWriteError!usize","src":937,"more_decls":null}{"doc_comment":"Open and possibly create a file. Keeps trying if it gets interrupted.\nSee also `openC`.","pl":"fn open(file_path: []const u8, flags: u32, perm: mode_t) OpenError!fd_t","src":1047,"more_decls":null}{"doc_comment":"Open and possibly create a file. Keeps trying if it gets interrupted.\nSee also `open`.","pl":"fn openZ(file_path: [*:0]const u8, flags: u32, perm: mode_t) OpenError!fd_t","src":1060,"more_decls":null}{"doc_comment":"Windows-only. The path parameter is\n[WTF-16](https://simonsapin.github.io/wtf-8/#potentially-ill-formed-utf-16) encoded.\nTranslates the POSIX open API call to a Windows API call.\nTODO currently, this function does not handle all flag combinations\nor makes use of perm argument.","pl":"fn openW(file_path_w: []const u16, flags: u32, perm: mode_t) OpenError!fd_t","src":1132,"more_decls":null}{"doc_comment":"Open and possibly create a file. Keeps trying if it gets interrupted.\n`file_path` is relative to the open directory handle `dir_fd`.\nSee also `openatC`.","pl":"fn openat(dir_fd: fd_t, file_path: []const u8, flags: u32, mode: mode_t) OpenError!fd_t","src":1145,"more_decls":null}{"doc_comment":"Open and possibly create a file in WASI.","pl":"fn openatWasi(dir_fd: fd_t, file_path: []const u8, lookup_flags: lookupflags_t, oflags: oflags_t, fdflags: fdflags_t, base: rights_t, inheriting: rights_t) OpenError!fd_t","src":1158,"more_decls":null}{"doc_comment":"Open and possibly create a file. Keeps trying if it gets interrupted.\n`file_path` is relative to the open directory handle `dir_fd`.\nSee also `openat`.","pl":"fn openatZ(dir_fd: fd_t, file_path: [*:0]const u8, flags: u32, mode: mode_t) OpenError!fd_t","src":1194,"more_decls":null}{"doc_comment":"Windows-only. Similar to `openat` but with pathname argument null-terminated\nWTF16 encoded.\nTODO currently, this function does not handle all flag combinations\nor makes use of perm argument.","pl":"fn openatW(dir_fd: fd_t, file_path_w: []const u16, flags: u32, mode: mode_t) OpenError!fd_t","src":1234,"more_decls":null}{"pl":"fn dup2(old_fd: fd_t, new_fd: fd_t) !void","src":1244,"more_decls":null}{"doc_comment":"Like `execve` except the parameters are null-terminated,\nmatching the syscall API on all targets. This removes the need for an allocator.\nThis function ignores PATH environment variable. See `execvpeZ` for that.","pl":"fn execveZ(\n    path: [*:0]const u8,\n    child_argv: [*:null]const ?[*:0]const u8,\n    envp: [*:null]const ?[*:0]const u8,\n) ExecveError","src":1276,"more_decls":null}{"doc_comment":"Like `execvpeZ` except if `arg0_expand` is `.expand`, then `argv` is mutable,\nand `argv[0]` is expanded to be the same absolute path that is passed to the execve syscall.\nIf this function returns with an error, `argv[0]` will be restored to the value it was when it was passed in.","pl":"fn execvpeZ_expandArg0(\n    comptime arg0_expand: Arg0Expand,\n    file: [*:0]const u8,\n    child_argv: switch (arg0_expand) {\n        .expand => [*:null]?[*:0]const u8,\n        .no_expand => [*:null]const ?[*:0]const u8,\n    },\n    envp: [*:null]const ?[*:0]const u8,\n) ExecveError","src":1313,"more_decls":null}{"doc_comment":"Like `execvpe` except the parameters are null-terminated,\nmatching the syscall API on all targets. This removes the need for an allocator.\nThis function also uses the PATH environment variable to get the full path to the executable.\nIf `file` is an absolute path, this is the same as `execveZ`.","pl":"fn execvpeZ(\n    file: [*:0]const u8,\n    argv_ptr: [*:null]const ?[*:0]const u8,\n    envp: [*:null]const ?[*:0]const u8,\n) ExecveError","src":1367,"more_decls":null}{"doc_comment":"Get an environment variable.\nSee also `getenvZ`.","pl":"fn getenv(key: []const u8) ?[]const u8","src":1377,"more_decls":null}{"doc_comment":"Get an environment variable with a null-terminated name.\nSee also `getenv`.","pl":"fn getenvZ(key: [*:0]const u8) ?[]const u8","src":1426,"more_decls":null}{"doc_comment":"Windows-only. Get an environment variable with a null-terminated, WTF-16 encoded name.\nSee also `getenv`.\nThis function first attempts a case-sensitive lookup. If no match is found, and `key`\nis ASCII, then it attempts a second case-insensitive lookup.","pl":"fn getenvW(key: [*:0]const u16) ?[:0]const u16","src":1441,"more_decls":null}{"doc_comment":"The result is a slice of out_buffer, indexed from 0.","pl":"fn getcwd(out_buffer: []u8) GetCwdError![]u8","src":1485,"more_decls":null}{"doc_comment":"Creates a symbolic link named `sym_link_path` which contains the string `target_path`.\nA symbolic link (also known as a soft link) may point to an existing file or to a nonexistent\none; the latter case is known as a dangling link.\nIf `sym_link_path` exists, it will not be overwritten.\nSee also `symlinkZ.","pl":"fn symlink(target_path: []const u8, sym_link_path: []const u8) SymLinkError!void","src":1531,"more_decls":null}{"doc_comment":"This is the same as `symlink` except the parameters are null-terminated pointers.\nSee also `symlink`.","pl":"fn symlinkZ(target_path: [*:0]const u8, sym_link_path: [*:0]const u8) SymLinkError!void","src":1547,"more_decls":null}{"doc_comment":"Similar to `symlink`, however, creates a symbolic link named `sym_link_path` which contains the string\n`target_path` **relative** to `newdirfd` directory handle.\nA symbolic link (also known as a soft link) may point to an existing file or to a nonexistent\none; the latter case is known as a dangling link.\nIf `sym_link_path` exists, it will not be overwritten.\nSee also `symlinkatWasi`, `symlinkatZ` and `symlinkatW`.","pl":"fn symlinkat(target_path: []const u8, newdirfd: fd_t, sym_link_path: []const u8) SymLinkError!void","src":1577,"more_decls":null}{"doc_comment":"WASI-only. The same as `symlinkat` but targeting WASI.\nSee also `symlinkat`.","pl":"fn symlinkatWasi(target_path: []const u8, newdirfd: fd_t, sym_link_path: []const u8) SymLinkError!void","src":1593,"more_decls":null}{"doc_comment":"The same as `symlinkat` except the parameters are null-terminated pointers.\nSee also `symlinkat`.","pl":"fn symlinkatZ(target_path: [*:0]const u8, newdirfd: fd_t, sym_link_path: [*:0]const u8) SymLinkError!void","src":1617,"more_decls":null}{"pl":"fn linkZ(oldpath: [*:0]const u8, newpath: [*:0]const u8, flags: i32) LinkError!void","src":1656,"more_decls":null}{"pl":"pub fn link(oldpath: []const u8, newpath: []const u8, flags: i32) LinkError!void {\n    const old = try toPosixPath(oldpath);\n    const new = try toPosixPath(newpath);\n    return try linkZ(&old, &new, flags);\n}","src":1678,"more_decls":null}{"pl":"fn linkatZ(\n    olddir: fd_t,\n    oldpath: [*:0]const u8,\n    newdir: fd_t,\n    newpath: [*:0]const u8,\n    flags: i32,\n) LinkatError!void","src":1686,"more_decls":null}{"pl":"fn linkat(\n    olddir: fd_t,\n    oldpath: []const u8,\n    newdir: fd_t,\n    newpath: []const u8,\n    flags: i32,\n) LinkatError!void","src":1715,"more_decls":null}{"doc_comment":"Delete a name and possibly the file it refers to.\nSee also `unlinkC`.","pl":"fn unlink(file_path: []const u8) UnlinkError!void","src":1752,"more_decls":null}{"doc_comment":"Same as `unlink` except the parameter is a null terminated UTF8-encoded string.","pl":"fn unlinkZ(file_path: [*:0]const u8) UnlinkError!void","src":1767,"more_decls":null}{"doc_comment":"Windows-only. Same as `unlink` except the parameter is null-terminated, WTF16 encoded.","pl":"pub fn unlinkW(file_path_w: []const u16) UnlinkError!void {\n    return windows.DeleteFile(file_path_w, .{ .dir = std.fs.cwd().fd });\n}","src":1792,"more_decls":null}{"doc_comment":"Delete a file name and possibly the file it refers to, based on an open directory handle.\nAsserts that the path parameter has no null bytes.","pl":"fn unlinkat(dirfd: fd_t, file_path: []const u8, flags: u32) UnlinkatError!void","src":1803,"more_decls":null}{"doc_comment":"WASI-only. Same as `unlinkat` but targeting WASI.\nSee also `unlinkat`.","pl":"fn unlinkatWasi(dirfd: fd_t, file_path: []const u8, flags: u32) UnlinkatError!void","src":1819,"more_decls":null}{"doc_comment":"Same as `unlinkat` but `file_path` is a null-terminated string.","pl":"fn unlinkatZ(dirfd: fd_t, file_path_c: [*:0]const u8, flags: u32) UnlinkatError!void","src":1850,"more_decls":null}{"doc_comment":"Same as `unlinkat` but `sub_path_w` is UTF16LE, NT prefixed. Windows only.","pl":"pub fn unlinkatW(dirfd: fd_t, sub_path_w: []const u16, flags: u32) UnlinkatError!void {\n    const remove_dir = (flags & AT_REMOVEDIR) != 0;\n    return windows.DeleteFile(sub_path_w, .{ .dir = dirfd, .remove_dir = remove_dir });\n}","src":1879,"more_decls":null}{"doc_comment":"Change the name or location of a file.","pl":"fn rename(old_path: []const u8, new_path: []const u8) RenameError!void","src":1909,"more_decls":null}{"doc_comment":"Same as `rename` except the parameters are null-terminated byte arrays.","pl":"fn renameZ(old_path: [*:0]const u8, new_path: [*:0]const u8) RenameError!void","src":1926,"more_decls":null}{"doc_comment":"Same as `rename` except the parameters are null-terminated UTF16LE encoded byte arrays.\nAssumes target is Windows.","pl":"pub fn renameW(old_path: [*:0]const u16, new_path: [*:0]const u16) RenameError!void {\n    const flags = windows.MOVEFILE_REPLACE_EXISTING | windows.MOVEFILE_WRITE_THROUGH;\n    return windows.MoveFileExW(old_path, new_path, flags);\n}","src":1958,"more_decls":null}{"doc_comment":"Change the name or location of a file based on an open directory handle.","pl":"fn renameat(\n    old_dir_fd: fd_t,\n    old_path: []const u8,\n    new_dir_fd: fd_t,\n    new_path: []const u8,\n) RenameError!void","src":1964,"more_decls":null}{"doc_comment":"WASI-only. Same as `renameat` expect targeting WASI.\nSee also `renameat`.","pl":"fn renameatWasi(old_dir_fd: fd_t, old_path: []const u8, new_dir_fd: fd_t, new_path: []const u8) RenameError!void","src":1985,"more_decls":null}{"doc_comment":"Same as `renameat` except the parameters are null-terminated byte arrays.","pl":"fn renameatZ(\n    old_dir_fd: fd_t,\n    old_path: [*:0]const u8,\n    new_dir_fd: fd_t,\n    new_path: [*:0]const u8,\n) RenameError!void","src":2012,"more_decls":null}{"doc_comment":"Same as `renameat` but Windows-only and the path parameters are\n[WTF-16](https://simonsapin.github.io/wtf-8/#potentially-ill-formed-utf-16) encoded.","pl":"fn renameatW(\n    old_dir_fd: fd_t,\n    old_path_w: []const u16,\n    new_dir_fd: fd_t,\n    new_path_w: []const u16,\n    ReplaceIfExists: windows.BOOLEAN,\n) RenameError!void","src":2050,"more_decls":null}{"pl":"fn mkdirat(dir_fd: fd_t, sub_dir_path: []const u8, mode: u32) MakeDirError!void","src":2106,"more_decls":null}{"pl":"fn mkdiratWasi(dir_fd: fd_t, sub_dir_path: []const u8, mode: u32) MakeDirError!void","src":2120,"more_decls":null}{"pl":"fn mkdiratZ(dir_fd: fd_t, sub_dir_path: [*:0]const u8, mode: u32) MakeDirError!void","src":2142,"more_decls":null}{"pl":"fn mkdiratW(dir_fd: fd_t, sub_path_w: []const u16, mode: u32) MakeDirError!void","src":2167,"more_decls":null}{"doc_comment":"Create a directory.\n`mode` is ignored on Windows.","pl":"fn mkdir(dir_path: []const u8, mode: u32) MakeDirError!void","src":2204,"more_decls":null}{"doc_comment":"Same as `mkdir` but the parameter is a null-terminated UTF8-encoded string.","pl":"fn mkdirZ(dir_path: [*:0]const u8, mode: u32) MakeDirError!void","src":2217,"more_decls":null}{"doc_comment":"Windows-only. Same as `mkdir` but the parameters is  WTF16 encoded.","pl":"fn mkdirW(dir_path_w: []const u16, mode: u32) MakeDirError!void","src":2242,"more_decls":null}{"doc_comment":"Deletes an empty directory.","pl":"fn rmdir(dir_path: []const u8) DeleteDirError!void","src":2273,"more_decls":null}{"doc_comment":"Same as `rmdir` except the parameter is null-terminated.","pl":"fn rmdirZ(dir_path: [*:0]const u8) DeleteDirError!void","src":2288,"more_decls":null}{"doc_comment":"Windows-only. Same as `rmdir` except the parameter is WTF16 encoded.","pl":"pub fn rmdirW(dir_path_w: []const u16) DeleteDirError!void {\n    return windows.DeleteFile(dir_path_w, .{ .dir = std.fs.cwd().fd, .remove_dir = true }) catch |err| switch (err) {\n        error.IsDir => unreachable,\n        else => |e| return e,\n    };\n}","src":2313,"more_decls":null}{"doc_comment":"Changes the current working directory of the calling process.\n`dir_path` is recommended to be a UTF-8 encoded string.","pl":"fn chdir(dir_path: []const u8) ChangeCurDirError!void","src":2336,"more_decls":null}{"doc_comment":"Same as `chdir` except the parameter is null-terminated.","pl":"fn chdirZ(dir_path: [*:0]const u8) ChangeCurDirError!void","src":2353,"more_decls":null}{"doc_comment":"Windows-only. Same as `chdir` except the paramter is WTF16 encoded.","pl":"pub fn chdirW(dir_path: []const u16) ChangeCurDirError!void {\n    windows.SetCurrentDirectory(dir_path) catch |err| switch (err) {\n        error.NoDevice => return error.FileSystem,\n        else => |e| return e,\n    };\n}","src":2375,"more_decls":null}{"pl":"fn fchdir(dirfd: fd_t) FchdirError!void","src":2388,"more_decls":null}{"doc_comment":"Read value of a symbolic link.\nThe return value is a slice of `out_buffer` from index 0.","pl":"fn readlink(file_path: []const u8, out_buffer: []u8) ReadLinkError![]u8","src":2421,"more_decls":null}{"doc_comment":"Windows-only. Same as `readlink` except `file_path` is WTF16 encoded.\nSee also `readlinkZ`.","pl":"pub fn readlinkW(file_path: []const u16, out_buffer: []u8) ReadLinkError![]u8 {\n    return windows.ReadLink(std.fs.cwd().fd, file_path, out_buffer);\n}","src":2437,"more_decls":null}{"doc_comment":"Same as `readlink` except `file_path` is null-terminated.","pl":"fn readlinkZ(file_path: [*:0]const u8, out_buffer: []u8) ReadLinkError![]u8","src":2442,"more_decls":null}{"doc_comment":"Similar to `readlink` except reads value of a symbolink link **relative** to `dirfd` directory handle.\nThe return value is a slice of `out_buffer` from index 0.\nSee also `readlinkatWasi`, `realinkatZ` and `realinkatW`.","pl":"fn readlinkat(dirfd: fd_t, file_path: []const u8, out_buffer: []u8) ReadLinkError![]u8","src":2466,"more_decls":null}{"doc_comment":"WASI-only. Same as `readlinkat` but targets WASI.\nSee also `readlinkat`.","pl":"fn readlinkatWasi(dirfd: fd_t, file_path: []const u8, out_buffer: []u8) ReadLinkError![]u8","src":2482,"more_decls":null}{"doc_comment":"Windows-only. Same as `readlinkat` except `file_path` is null-terminated, WTF16 encoded.\nSee also `readlinkat`.","pl":"pub fn readlinkatW(dirfd: fd_t, file_path: []const u16, out_buffer: []u8) ReadLinkError![]u8 {\n    return windows.ReadLink(dirfd, file_path, out_buffer);\n}","src":2502,"more_decls":null}{"doc_comment":"Same as `readlinkat` except `file_path` is null-terminated.\nSee also `readlinkat`.","pl":"fn readlinkatZ(dirfd: fd_t, file_path: [*:0]const u8, out_buffer: []u8) ReadLinkError![]u8","src":2508,"more_decls":null}{"pl":"fn setuid(uid: uid_t) SetIdError!void","src":2536,"more_decls":null}{"pl":"fn seteuid(uid: uid_t) SetEidError!void","src":2546,"more_decls":null}{"pl":"fn setreuid(ruid: uid_t, euid: uid_t) SetIdError!void","src":2555,"more_decls":null}{"pl":"fn setgid(gid: gid_t) SetIdError!void","src":2565,"more_decls":null}{"pl":"fn setegid(uid: uid_t) SetEidError!void","src":2575,"more_decls":null}{"pl":"fn setregid(rgid: gid_t, egid: gid_t) SetIdError!void","src":2584,"more_decls":null}{"doc_comment":"Test whether a file descriptor refers to a terminal.","pl":"fn isatty(handle: fd_t) bool","src":2595,"more_decls":null}{"pl":"fn isCygwinPty(handle: fd_t) bool","src":2638,"more_decls":null}{"pl":"fn socket(domain: u32, socket_type: u32, protocol: u32) SocketError!socket_t","src":2688,"more_decls":null}{"doc_comment":"Shutdown socket send/receive operations","pl":"fn shutdown(sock: socket_t, how: ShutdownHow) ShutdownError!void","src":2752,"more_decls":null}{"pl":"fn closeSocket(sock: socket_t) void","src":2788,"more_decls":null}{"doc_comment":"addr is `*const T` where T is one of the sockaddr","pl":"fn bind(sock: socket_t, addr: *const sockaddr, len: socklen_t) BindError!void","src":2839,"more_decls":null}{"pl":"fn listen(sock: socket_t, backlog: u31) ListenError!void","src":2909,"more_decls":null}{"doc_comment":"Accept a connection on a socket.\nIf `sockfd` is opened in non blocking mode, the function will\nreturn error.WouldBlock when EAGAIN is received.","pl":"fn accept(\n    /// This argument is a socket that has been created with `socket`, bound to a local address\n    /// with `bind`, and is listening for connections after a `listen`.\n    sock: socket_t,\n    /// This argument is a pointer to a sockaddr structure.  This structure is filled in with  the\n    /// address  of  the  peer  socket, as known to the communications layer.  The exact format of the\n    /// address returned addr is determined by the socket's address  family  (see  `socket`  and  the\n    /// respective  protocol  man  pages).\n    addr: ?*sockaddr,\n    /// This argument is a value-result argument: the caller must initialize it to contain  the\n    /// size (in bytes) of the structure pointed to by addr; on return it will contain the actual size\n    /// of the peer address.\n    ///\n    /// The returned address is truncated if the buffer provided is too small; in this  case,  `addr_size`\n    /// will return a value greater than was supplied to the call.\n    addr_size: ?*socklen_t,\n    /// The following values can be bitwise ORed in flags to obtain different behavior:\n    /// * `SOCK_NONBLOCK` - Set the `O_NONBLOCK` file status flag on the open file description (see `open`)\n    ///   referred  to by the new file descriptor.  Using this flag saves extra calls to `fcntl` to achieve\n    ///   the same result.\n    /// * `SOCK_CLOEXEC`  - Set the close-on-exec (`FD_CLOEXEC`) flag on the new file descriptor.   See  the\n    ///   description  of the `O_CLOEXEC` flag in `open` for reasons why this may be useful.\n    flags: u32,\n) AcceptError!socket_t","src":2982,"more_decls":null}{"pl":"fn epoll_create1(flags: u32) EpollCreateError!i32","src":3078,"more_decls":null}{"pl":"fn epoll_ctl(epfd: i32, op: u32, fd: i32, event: ?*epoll_event) EpollCtlError!void","src":3117,"more_decls":null}{"doc_comment":"Waits for an I/O event on an epoll file descriptor.\nReturns the number of file descriptors ready for the requested I/O,\nor zero if no file descriptor became ready during the requested timeout milliseconds.","pl":"fn epoll_wait(epfd: i32, events: []epoll_event, timeout: i32) usize","src":3137,"more_decls":null}{"pl":"fn eventfd(initval: u32, flags: u32) EventFdError!i32","src":3158,"more_decls":null}{"pl":"fn getsockname(sock: socket_t, addr: *sockaddr, addrlen: *socklen_t) GetSockNameError!void","src":3185,"more_decls":null}{"doc_comment":"Initiate a connection on a socket.\nIf `sockfd` is opened in non blocking mode, the function will\nreturn error.WouldBlock when EAGAIN or EINPROGRESS is received.","pl":"fn connect(sock: socket_t, sock_addr: *const sockaddr, len: socklen_t) ConnectError!void","src":3261,"more_decls":null}{"pl":"fn getsockoptError(sockfd: fd_t) ConnectError!void","src":3313,"more_decls":null}{"pl":"fn waitpid(pid: pid_t, flags: u32) WaitPidResult","src":3353,"more_decls":null}{"doc_comment":"Return information about a file descriptor.","pl":"fn fstat(fd: fd_t) FStatError!Stat","src":3385,"more_decls":null}{"doc_comment":"Similar to `fstat`, but returns stat of a resource pointed to by `pathname`\nwhich is relative to `dirfd` handle.\nSee also `fstatatZ` and `fstatatWasi`.","pl":"fn fstatat(dirfd: fd_t, pathname: []const u8, flags: u32) FStatAtError!Stat","src":3418,"more_decls":null}{"doc_comment":"WASI-only. Same as `fstatat` but targeting WASI.\nSee also `fstatat`.","pl":"fn fstatatWasi(dirfd: fd_t, pathname: []const u8, flags: u32) FStatAtError!Stat","src":3433,"more_decls":null}{"doc_comment":"Same as `fstatat` but `pathname` is null-terminated.\nSee also `fstatat`.","pl":"fn fstatatZ(dirfd: fd_t, pathname: [*:0]const u8, flags: u32) FStatAtError!Stat","src":3452,"more_decls":null}{"pl":"fn kqueue() KQueueError!i32","src":3476,"more_decls":null}{"pl":"fn kevent(\n    kq: i32,\n    changelist: []const Kevent,\n    eventlist: []Kevent,\n    timeout: ?*const timespec,\n) KEventError!usize","src":3504,"more_decls":null}{"doc_comment":"initialize an inotify instance","pl":"fn inotify_init1(flags: u32) INotifyInitError!i32","src":3541,"more_decls":null}{"doc_comment":"add a watch to an initialized inotify instance","pl":"pub fn inotify_add_watch(inotify_fd: i32, pathname: []const u8, mask: u32) INotifyAddWatchError!i32 {\n    const pathname_c = try toPosixPath(pathname);\n    return inotify_add_watchZ(inotify_fd, &pathname_c, mask);\n}","src":3562,"more_decls":null}{"doc_comment":"Same as `inotify_add_watch` except pathname is null-terminated.","pl":"fn inotify_add_watchZ(inotify_fd: i32, pathname: [*:0]const u8, mask: u32) INotifyAddWatchError!i32","src":3570,"more_decls":null}{"doc_comment":"remove an existing watch from an inotify instance","pl":"fn inotify_rm_watch(inotify_fd: i32, wd: i32) void","src":3587,"more_decls":null}{"doc_comment":"`memory.len` must be page-aligned.","pl":"fn mprotect(memory: []align(mem.page_size) u8, protection: u32) MProtectError!void","src":3611,"more_decls":null}{"pl":"fn fork() ForkError!pid_t","src":3624,"more_decls":null}{"doc_comment":"Map files or devices into memory.\n`length` does not need to be aligned.\nUse of a mapped region can result in these signals:\n* SIGSEGV - Attempted write into a region mapped as read-only.\n* SIGBUS - Attempted  access to a portion of the buffer that does not correspond to the file","pl":"fn mmap(\n    ptr: ?[*]align(mem.page_size) u8,\n    length: usize,\n    prot: u32,\n    flags: u32,\n    fd: fd_t,\n    offset: u64,\n) MMapError![]align(mem.page_size) u8","src":3656,"more_decls":null}{"doc_comment":"Deletes the mappings for the specified address range, causing\nfurther references to addresses within the range to generate invalid memory references.\nNote that while POSIX allows unmapping a region in the middle of an existing mapping,\nZig's munmap function does not, for two reasons:\n* It violates the Zig principle that resource deallocation must succeed.\n* The Windows function, VirtualFree, has this restriction.","pl":"fn munmap(memory: []align(mem.page_size) u8) void","src":3694,"more_decls":null}{"doc_comment":"check user's permissions for a file\nTODO currently this assumes `mode` is `F_OK` on Windows.","pl":"fn access(path: []const u8, mode: u32) AccessError!void","src":3720,"more_decls":null}{"doc_comment":"Same as `access` except `path` is null-terminated.","pl":"fn accessZ(path: [*:0]const u8, mode: u32) AccessError!void","src":3733,"more_decls":null}{"doc_comment":"Call from Windows-specific code if you already have a UTF-16LE encoded, null terminated string.\nOtherwise use `access` or `accessC`.\nTODO currently this ignores `mode`.","pl":"fn accessW(path: [*:0]const u16, mode: u32) windows.GetFileAttributesError!void","src":3759,"more_decls":null}{"doc_comment":"Check user's permissions for a file, based on an open directory handle.\nTODO currently this ignores `mode` and `flags` on Windows.","pl":"fn faccessat(dirfd: fd_t, path: []const u8, mode: u32, flags: u32) AccessError!void","src":3774,"more_decls":null}{"doc_comment":"Same as `faccessat` except the path parameter is null-terminated.","pl":"fn faccessatZ(dirfd: fd_t, path: [*:0]const u8, mode: u32, flags: u32) AccessError!void","src":3784,"more_decls":null}{"doc_comment":"Same as `faccessat` except asserts the target is Windows and the path parameter\nis NtDll-prefixed, null-terminated, WTF-16 encoded.\nTODO currently this ignores `mode` and `flags`","pl":"fn faccessatW(dirfd: fd_t, sub_path_w: [*:0]const u16, mode: u32, flags: u32) AccessError!void","src":3809,"more_decls":null}{"doc_comment":"Creates a unidirectional data channel that can be used for interprocess communication.","pl":"fn pipe() PipeError![2]fd_t","src":3852,"more_decls":null}{"pl":"fn pipe2(flags: u32) PipeError![2]fd_t","src":3864,"more_decls":null}{"pl":"fn sysctl(\n    name: []const c_int,\n    oldp: ?*c_void,\n    oldlenp: ?*usize,\n    newp: ?*c_void,\n    newlen: usize,\n) SysCtlError!void","src":3922,"more_decls":null}{"pl":"fn sysctlbynameZ(\n    name: [*:0]const u8,\n    oldp: ?*c_void,\n    oldlenp: ?*usize,\n    newp: ?*c_void,\n    newlen: usize,\n) SysCtlError!void","src":3949,"more_decls":null}{"pl":"fn gettimeofday(tv: ?*timeval, tz: ?*timezone) void","src":3973,"more_decls":null}{"doc_comment":"Repositions read/write file offset relative to the beginning.","pl":"fn lseek_SET(fd: fd_t, offset: u64) SeekError!void","src":3990,"more_decls":null}{"doc_comment":"Repositions read/write file offset relative to the current offset.","pl":"fn lseek_CUR(fd: fd_t, offset: i64) SeekError!void","src":4032,"more_decls":null}{"doc_comment":"Repositions read/write file offset relative to the end.","pl":"fn lseek_END(fd: fd_t, offset: i64) SeekError!void","src":4073,"more_decls":null}{"doc_comment":"Returns the read/write file offset relative to the beginning.","pl":"fn lseek_CUR_get(fd: fd_t) SeekError!u64","src":4114,"more_decls":null}{"pl":"fn fcntl(fd: fd_t, cmd: i32, arg: usize) FcntlError!usize","src":4162,"more_decls":null}{"pl":"fn flock(fd: fd_t, operation: i32) FlockError!void","src":4237,"more_decls":null}{"doc_comment":"Return the canonicalized absolute pathname.\nExpands all symbolic links and resolves references to `.`, `..`, and\nextra `/` characters in `pathname`.\nThe return value is a slice of `out_buffer`, but not necessarily from the beginning.\nSee also `realpathZ` and `realpathW`.","pl":"fn realpath(pathname: []const u8, out_buffer: *[MAX_PATH_BYTES]u8) RealPathError![]u8","src":4285,"more_decls":null}{"doc_comment":"Same as `realpath` except `pathname` is null-terminated.","pl":"fn realpathZ(pathname: [*:0]const u8, out_buffer: *[MAX_PATH_BYTES]u8) RealPathError![]u8","src":4300,"more_decls":null}{"doc_comment":"Same as `realpath` except `pathname` is UTF16LE-encoded.","pl":"fn realpathW(pathname: []const u16, out_buffer: *[MAX_PATH_BYTES]u8) RealPathError![]u8","src":4333,"more_decls":null}{"doc_comment":"Return canonical path of handle `fd`.\nThis function is very host-specific and is not universally supported by all hosts.\nFor example, while it generally works on Linux, macOS or Windows, it is unsupported\non FreeBSD, or WASI.","pl":"fn getFdPath(fd: fd_t, out_buffer: *[MAX_PATH_BYTES]u8) RealPathError![]u8","src":4373,"more_decls":null}{"doc_comment":"Spurious wakeups are possible and no precision of timing is guaranteed.","pl":"fn nanosleep(seconds: u64, nanoseconds: u64) void","src":4414,"more_decls":null}{"pl":"fn dl_iterate_phdr(\n    context: anytype,\n    comptime Error: type,\n    comptime callback: fn (info: *dl_phdr_info, size: usize, context: @TypeOf(context)) Error!void,\n) Error!void","src":4438,"more_decls":null}{"doc_comment":"TODO: change this to return the timespec as a return value\nTODO: look into making clk_id an enum","pl":"fn clock_gettime(clk_id: i32, tp: *timespec) ClockGetTimeError!void","src":4524,"more_decls":null}{"pl":"fn clock_getres(clk_id: i32, res: *timespec) ClockGetTimeError!void","src":4565,"more_decls":null}{"pl":"fn sched_getaffinity(pid: pid_t) SchedGetAffinityError!cpu_set_t","src":4589,"more_decls":null}{"doc_comment":"Used to convert a slice to a null terminated slice on the stack.\nTODO https://github.com/ziglang/zig/issues/287","pl":"fn toPosixPath(file_path: []const u8) ![MAX_PATH_BYTES - 1:0]u8","src":4603,"more_decls":null}{"doc_comment":"Call this when you made a syscall or something that sets errno\nand you get an unexpected error.","pl":"fn unexpectedErrno(err: anytype) UnexpectedError","src":4628,"more_decls":null}{"pl":"fn sigaltstack(ss: ?*stack_t, old_ss: ?*stack_t) SigaltstackError!void","src":4648,"more_decls":null}{"doc_comment":"Examine and change a signal action.","pl":"fn sigaction(sig: u6, act: ?*const Sigaction, oact: ?*Sigaction) void","src":4660,"more_decls":null}{"pl":"fn futimens(fd: fd_t, times: *const [2]timespec) FutimensError!void","src":4693,"more_decls":null}{"pl":"fn gethostname(name_buffer: *[HOST_NAME_MAX]u8) GetHostNameError![]u8","src":4726,"more_decls":null}{"pl":"fn uname() utsname","src":4746,"more_decls":null}{"pl":"fn res_mkquery(\n    op: u4,\n    dname: []const u8,\n    class: u8,\n    ty: u8,\n    data: []const u8,\n    newrr: ?[*]const u8,\n    buf: []u8,\n) usize","src":4755,"more_decls":null}{"pl":"fn sendmsg(\n    /// The file descriptor of the sending socket.\n    sockfd: socket_t,\n    /// Message header and iovecs\n    msg: msghdr_const,\n    flags: u32,\n) SendMsgError!usize","src":4869,"more_decls":null}{"doc_comment":"Transmit a message to another socket.\n\nThe `sendto` call may be used only when the socket is in a connected state (so that the intended\nrecipient  is  known). The  following call\n\nsend(sockfd, buf, len, flags);\n\nis equivalent to\n\nsendto(sockfd, buf, len, flags, NULL, 0);\n\nIf  sendto()  is used on a connection-mode (`SOCK_STREAM`, `SOCK_SEQPACKET`) socket, the arguments\n`dest_addr` and `addrlen` are asserted to be `null` and `0` respectively, and asserted\nthat the socket was actually connected.\nOtherwise, the address of the target is given by `dest_addr` with `addrlen` specifying  its  size.\n\nIf the message is too long to pass atomically through the underlying protocol,\n`SendError.MessageTooBig` is returned, and the message is not transmitted.\n\nThere is no  indication  of  failure  to  deliver.\n\nWhen the message does not fit into the send buffer of  the  socket,  `sendto`  normally  blocks,\nunless  the socket has been placed in nonblocking I/O mode.  In nonblocking mode it would fail\nwith `SendError.WouldBlock`.  The `select` call may be used  to  determine when it is\npossible to send more data.","pl":"fn sendto(\n    /// The file descriptor of the sending socket.\n    sockfd: socket_t,\n    /// Message to send.\n    buf: []const u8,\n    flags: u32,\n    dest_addr: ?*const sockaddr,\n    addrlen: socklen_t,\n) SendToError!usize","src":4967,"more_decls":null}{"doc_comment":"Transmit a message to another socket.\n\nThe `send` call may be used only when the socket is in a connected state (so that the intended\nrecipient  is  known).   The  only  difference  between `send` and `write` is the presence of\nflags.  With a zero flags argument, `send` is equivalent to  `write`.   Also,  the  following\ncall\n\nsend(sockfd, buf, len, flags);\n\nis equivalent to\n\nsendto(sockfd, buf, len, flags, NULL, 0);\n\nThere is no  indication  of  failure  to  deliver.\n\nWhen the message does not fit into the send buffer of  the  socket,  `send`  normally  blocks,\nunless  the socket has been placed in nonblocking I/O mode.  In nonblocking mode it would fail\nwith `SendError.WouldBlock`.  The `select` call may be used  to  determine when it is\npossible to send more data.","pl":"fn send(\n    /// The file descriptor of the sending socket.\n    sockfd: socket_t,\n    buf: []const u8,\n    flags: u32,\n) SendError!usize","src":5059,"more_decls":null}{"doc_comment":"Transfer data between file descriptors, with optional headers and trailers.\nReturns the number of bytes written, which can be zero.\n\nThe `sendfile` call copies `in_len` bytes from one file descriptor to another. When possible,\nthis is done within the operating system kernel, which can provide better performance\ncharacteristics than transferring data from kernel to user space and back, such as with\n`read` and `write` calls. When `in_len` is `0`, it means to copy until the end of the input file has been\nreached. Note, however, that partial writes are still possible in this case.\n\n`in_fd` must be a file descriptor opened for reading, and `out_fd` must be a file descriptor\nopened for writing. They may be any kind of file descriptor; however, if `in_fd` is not a regular\nfile system file, it may cause this function to fall back to calling `read` and `write`, in which case\natomicity guarantees no longer apply.\n\nCopying begins reading at `in_offset`. The input file descriptor seek position is ignored and not updated.\nIf the output file descriptor has a seek position, it is updated as bytes are written. When\n`in_offset` is past the end of the input file, it successfully reads 0 bytes.\n\n`flags` has different meanings per operating system; refer to the respective man pages.\n\nThese systems support atomically sending everything, including headers and trailers:\n* macOS\n* FreeBSD\n\nThese systems support in-kernel data copying, but headers and trailers are not sent atomically:\n* Linux\n\nOther systems fall back to calling `read` / `write`.\n\nLinux has a limit on how many bytes may be transferred in one `sendfile` call, which is `0x7ffff000`\non both 64-bit and 32-bit systems. This is due to using a signed C int as the return value, as\nwell as stuffing the errno codes into the last `4096` values. This is noted on the `sendfile` man page.\nThe limit on Darwin is `0x7fffffff`, trying to write more than that returns EINVAL.\nThe corresponding POSIX limit on this is `math.maxInt(isize)`.","pl":"fn sendfile(\n    out_fd: fd_t,\n    in_fd: fd_t,\n    in_offset: u64,\n    in_len: u64,\n    headers: []const iovec_const,\n    trailers: []const iovec_const,\n    flags: u32,\n) SendFileError!usize","src":5122,"more_decls":null}{"doc_comment":"Transfer data between file descriptors at specified offsets.\nReturns the number of bytes written, which can less than requested.\n\nThe `copy_file_range` call copies `len` bytes from one file descriptor to another. When possible,\nthis is done within the operating system kernel, which can provide better performance\ncharacteristics than transferring data from kernel to user space and back, such as with\n`pread` and `pwrite` calls.\n\n`fd_in` must be a file descriptor opened for reading, and `fd_out` must be a file descriptor\nopened for writing. They may be any kind of file descriptor; however, if `fd_in` is not a regular\nfile system file, it may cause this function to fall back to calling `pread` and `pwrite`, in which case\natomicity guarantees no longer apply.\n\nIf `fd_in` and `fd_out` are the same, source and target ranges must not overlap.\nThe file descriptor seek positions are ignored and not updated.\nWhen `off_in` is past the end of the input file, it successfully reads 0 bytes.\n\n`flags` has different meanings per operating system; refer to the respective man pages.\n\nThese systems support in-kernel data copying:\n* Linux 4.5 (cross-filesystem 5.3)\n\nOther systems fall back to calling `pread` / `pwrite`.\n\nMaximum offsets on Linux are `math.maxInt(i64)`.","pl":"fn copy_file_range(fd_in: fd_t, off_in: u64, fd_out: fd_t, off_out: u64, len: usize, flags: u32) CopyFileRangeError!usize","src":5436,"more_decls":null}{"pl":"fn poll(fds: []pollfd, timeout: i32) PollError!usize","src":5488,"more_decls":null}{"pl":"fn ppoll(fds: []pollfd, timeout: ?*const timespec, mask: ?*const sigset_t) PPollError!usize","src":5526,"more_decls":null}{"pl":"pub fn recv(sock: socket_t, buf: []u8, flags: u32) RecvFromError!usize {\n    return recvfrom(sock, buf, flags, null, null);\n}","src":5571,"more_decls":null}{"doc_comment":"If `sockfd` is opened in non blocking mode, the function will\nreturn error.WouldBlock when EAGAIN is received.","pl":"fn recvfrom(\n    sockfd: socket_t,\n    buf: []u8,\n    flags: u32,\n    src_addr: ?*sockaddr,\n    addrlen: ?*socklen_t,\n) RecvFromError!usize","src":5577,"more_decls":null}{"pl":"fn dn_expand(\n    msg: []const u8,\n    comp_dn: []const u8,\n    exp_dn: []u8,\n) DnExpandError!usize","src":5623,"more_decls":null}{"pl":"fn sched_yield() SchedYieldError!void","src":5676,"more_decls":null}{"doc_comment":"Set a socket's options.","pl":"fn setsockopt(fd: socket_t, level: u32, optname: u32, opt: []const u8) SetSockOptError!void","src":5712,"more_decls":null}{"pl":"fn memfd_createZ(name: [*:0]const u8, flags: u32) MemFdCreateError!fd_t","src":5756,"more_decls":null}{"pl":"pub fn memfd_create(name: []const u8, flags: u32) !fd_t {\n    const name_t = try toMemFdPath(name);\n    return memfd_createZ(&name_t, flags);\n}","src":5785,"more_decls":null}{"pl":"fn getrusage(who: i32) rusage","src":5790,"more_decls":null}{"pl":"fn tcgetattr(handle: fd_t) TermiosGetError!termios","src":5803,"more_decls":null}{"pl":"fn tcsetattr(handle: fd_t, optional_action: TCSA, termios_p: termios) TermiosSetError!void","src":5818,"more_decls":null}{"pl":"fn ioctl_SIOCGIFINDEX(fd: fd_t, ifr: *ifreq) IoCtl_SIOCGIFINDEX_Error!void","src":5837,"more_decls":null}{"pl":"fn signalfd(fd: fd_t, mask: *const sigset_t, flags: u32) !fd_t","src":5854,"more_decls":null}{"doc_comment":"Write all pending file contents and metadata modifications to all filesystems.","pl":"pub fn sync() void {\n    system.sync();\n}","src":5876,"more_decls":null}{"doc_comment":"Write all pending file contents and metadata modifications to the filesystem which contains the specified file.","pl":"fn syncfs(fd: fd_t) SyncError!void","src":5881,"more_decls":null}{"doc_comment":"Write all pending file contents and metadata modifications for the specified file descriptor to the underlying filesystem.","pl":"fn fsync(fd: fd_t) SyncError!void","src":5894,"more_decls":null}{"doc_comment":"Write all pending file contents for the specified file descriptor to the underlying filesystem, but not necessarily the metadata.","pl":"fn fdatasync(fd: fd_t) SyncError!void","src":5918,"more_decls":null}{"pl":"fn prctl(option: PR, args: anytype) PrctlError!u31","src":5951,"more_decls":null}{"pl":"fn getrlimit(resource: rlimit_resource) GetrlimitError!rlimit","src":5980,"more_decls":null}{"pl":"fn setrlimit(resource: rlimit_resource, limits: rlimit) SetrlimitError!void","src":5993,"more_decls":null}{"doc_comment":"Give advice about use of memory.\nThis syscall is optional and is sometimes configured to be disabled.","pl":"fn madvise(ptr: [*]align(mem.page_size) u8, length: usize, advice: u32) MadviseError!void","src":6038,"more_decls":null}{"pl":"const darwin = @import(\"os/darwin.zig\")","src":31,"more_decls":null}{"pl":"const dragonfly = @import(\"os/dragonfly.zig\")","src":32,"more_decls":null}{"pl":"const freebsd = @import(\"os/freebsd.zig\")","src":33,"more_decls":null}{"pl":"const haiku = @import(\"os/haiku.zig\")","src":34,"more_decls":null}{"pl":"const netbsd = @import(\"os/netbsd.zig\")","src":35,"more_decls":null}{"pl":"const openbsd = @import(\"os/openbsd.zig\")","src":36,"more_decls":null}{"pl":"const linux = @import(\"os/linux.zig\")","src":37,"more_decls":null}{"pl":"const uefi = @import(\"os/uefi.zig\")","src":38,"more_decls":null}{"pl":"const wasi = @import(\"os/wasi.zig\")","src":39,"more_decls":null}{"pl":"const windows = @import(\"os/windows.zig\")","src":40,"more_decls":null}{"doc_comment":"Applications can override the `system` API layer in their root source file.\nOtherwise, when linking libc, this is the C API.\nWhen not linking libc, it is the OS-specific system interface.","pl":"const system = if (@hasDecl(root, \"os\") and root.os != @This())\n    root.os.system\nelse if (builtin.link_libc)\n    std.c\nelse switch (builtin.os.tag) {\n    .macos, .ios, .watchos, .tvos => darwin,\n    .freebsd => freebsd,\n    .haiku => haiku,\n    .linux => linux,\n    .netbsd => netbsd,\n    .openbsd => openbsd,\n    .dragonfly => dragonfly,\n    .wasi => wasi,\n    .windows => windows,\n    else => struct {},\n}","src":63,"more_decls":null}{"pl":"const socket_t = if (builtin.os.tag == .windows) windows.ws2_32.SOCKET else fd_t","src":82,"more_decls":null}{"doc_comment":"See also `getenv`. Populated by startup code before main().\nTODO this is a footgun because the value will be undefined when using `zig build-lib`.\nhttps://github.com/ziglang/zig/issues/4524","pl":"var environ: [][*:0]u8 = undefined","src":87,"more_decls":null}{"doc_comment":"Populated by startup code before main().\nNot available on Windows. See `std.process.args`\nfor obtaining the process arguments.","pl":"var argv: [][*:0]u8 = undefined","src":92,"more_decls":null}{"doc_comment":"To obtain errno, call this function with the return value of the\nsystem function call. For some systems this will obtain the value directly\nfrom the return code; for others it will use a thread-local errno variable.\nTherefore, this function only returns a well-defined value when it is called\ndirectly after the system function call which one wants to learn the errno\nvalue of.","pl":"const errno = system.getErrno","src":100,"more_decls":null}{"pl":"const GetRandomError = OpenError","src":129,"more_decls":null}{"pl":"const RaiseError = UnexpectedError","src":235,"more_decls":null}{"pl":"const KillError = error{PermissionDenied} || UnexpectedError","src":265,"more_decls":null}{"pl":"const ReadError = error{\n    InputOutput,\n    SystemResources,\n    IsDir,\n    OperationAborted,\n    BrokenPipe,\n    ConnectionResetByPeer,\n    ConnectionTimedOut,\n    NotOpenForReading,\n\n    /// This error occurs when no global event loop is configured,\n    /// and reading from the file descriptor would block.\n    WouldBlock,\n\n    /// In WASI, this error occurs when the file descriptor does\n    /// not hold the required rights to read from it.\n    AccessDenied,\n} || UnexpectedError","src":303,"more_decls":null}{"pl":"const PReadError = ReadError || error{Unseekable}","src":444,"more_decls":null}{"pl":"const TruncateError = error{\n    FileTooBig,\n    InputOutput,\n    FileBusy,\n\n    /// In WASI, this error occurs when the file descriptor does\n    /// not hold the required rights to call `ftruncate` on it.\n    AccessDenied,\n} || UnexpectedError","src":521,"more_decls":null}{"pl":"const WriteError = error{\n    DiskQuota,\n    FileTooBig,\n    InputOutput,\n    NoSpaceLeft,\n\n    /// In WASI, this error may occur when the file descriptor does\n    /// not hold the required rights to write to it.\n    AccessDenied,\n    BrokenPipe,\n    SystemResources,\n    OperationAborted,\n    NotOpenForWriting,\n\n    /// This error occurs when no global event loop is configured,\n    /// and reading from the file descriptor would block.\n    WouldBlock,\n} || UnexpectedError","src":660,"more_decls":null}{"pl":"const PWriteError = WriteError || error{Unseekable}","src":827,"more_decls":null}{"pl":"const OpenError = error{\n    /// In WASI, this error may occur when the file descriptor does\n    /// not hold the required rights to open a new resource relative to it.\n    AccessDenied,\n    SymLinkLoop,\n    ProcessFdQuotaExceeded,\n    SystemFdQuotaExceeded,\n    NoDevice,\n    FileNotFound,\n\n    /// The path exceeded `MAX_PATH_BYTES` bytes.\n    NameTooLong,\n\n    /// Insufficient kernel memory was available, or\n    /// the named file is a FIFO and per-user hard limit on\n    /// memory allocation for pipes has been reached.\n    SystemResources,\n\n    /// The file is too large to be opened. This error is unreachable\n    /// for 64-bit targets, as well as when opening directories.\n    FileTooBig,\n\n    /// The path refers to directory but the `O_DIRECTORY` flag was not provided.\n    IsDir,\n\n    /// A new path cannot be created because the device has no room for the new file.\n    /// This error is only reachable when the `O_CREAT` flag is provided.\n    NoSpaceLeft,\n\n    /// A component used as a directory in the path was not, in fact, a directory, or\n    /// `O_DIRECTORY` was specified and the path was not a directory.\n    NotDir,\n\n    /// The path already exists and the `O_CREAT` and `O_EXCL` flags were provided.\n    PathAlreadyExists,\n    DeviceBusy,\n\n    /// The underlying filesystem does not support file locks\n    FileLocksNotSupported,\n\n    BadPathName,\n    InvalidUtf8,\n\n    WouldBlock,\n} || UnexpectedError","src":999,"more_decls":null}{"pl":"const openC = @compileError(\"deprecated: renamed to openZ\")","src":1056,"more_decls":null}{"pl":"const openatC = @compileError(\"deprecated: renamed to openatZ\")","src":1189,"more_decls":null}{"pl":"const ExecveError = error{\n    SystemResources,\n    AccessDenied,\n    InvalidExe,\n    FileSystem,\n    IsDir,\n    FileNotFound,\n    NotDir,\n    FileBusy,\n    ProcessFdQuotaExceeded,\n    SystemFdQuotaExceeded,\n    NameTooLong,\n} || UnexpectedError","src":1257,"more_decls":null}{"pl":"const execveC = @compileError(\"deprecated: use execveZ\")","src":1271,"more_decls":null}{"pl":"const execvpeC = @compileError(\"deprecated in favor of execvpeZ\")","src":1303,"more_decls":null}{"pl":"const getenvC = @compileError(\"Deprecated in favor of `getenvZ`\")","src":1422,"more_decls":null}{"pl":"const GetCwdError = error{\n    NameTooLong,\n    CurrentWorkingDirectoryUnlinked,\n} || UnexpectedError","src":1479,"more_decls":null}{"pl":"const SymLinkError = error{\n    /// In WASI, this error may occur when the file descriptor does\n    /// not hold the required rights to create a new symbolic link relative to it.\n    AccessDenied,\n    DiskQuota,\n    PathAlreadyExists,\n    FileSystem,\n    SymLinkLoop,\n    FileNotFound,\n    SystemResources,\n    NoSpaceLeft,\n    ReadOnlyFileSystem,\n    NotDir,\n    NameTooLong,\n    InvalidUtf8,\n    BadPathName,\n} || UnexpectedError","src":1508,"more_decls":null}{"pl":"const symlinkC = @compileError(\"deprecated: renamed to symlinkZ\")","src":1543,"more_decls":null}{"pl":"const symlinkatC = @compileError(\"deprecated: renamed to symlinkatZ\")","src":1589,"more_decls":null}{"pl":"const LinkError = UnexpectedError || error{\n    AccessDenied,\n    DiskQuota,\n    PathAlreadyExists,\n    FileSystem,\n    SymLinkLoop,\n    LinkQuotaExceeded,\n    NameTooLong,\n    FileNotFound,\n    SystemResources,\n    NoSpaceLeft,\n    ReadOnlyFileSystem,\n    NotSameFileSystem,\n}","src":1641,"more_decls":null}{"pl":"const LinkatError = LinkError || error{NotDir}","src":1684,"more_decls":null}{"pl":"const UnlinkError = error{\n    FileNotFound,\n\n    /// In WASI, this error may occur when the file descriptor does\n    /// not hold the required rights to unlink a resource by path relative to it.\n    AccessDenied,\n    FileBusy,\n    FileSystem,\n    IsDir,\n    SymLinkLoop,\n    NameTooLong,\n    NotDir,\n    SystemResources,\n    ReadOnlyFileSystem,\n\n    /// On Windows, file paths must be valid Unicode.\n    InvalidUtf8,\n\n    /// On Windows, file paths cannot contain these characters:\n    /// '/', '*', '?', '\"', '<', '>', '|'\n    BadPathName,\n} || UnexpectedError","src":1727,"more_decls":null}{"pl":"const unlinkC = @compileError(\"deprecated: renamed to unlinkZ\")","src":1764,"more_decls":null}{"pl":"const UnlinkatError = UnlinkError || error{\n    /// When passing `AT_REMOVEDIR`, this error occurs when the named directory is not empty.\n    DirNotEmpty,\n}","src":1796,"more_decls":null}{"pl":"const unlinkatC = @compileError(\"deprecated: renamed to unlinkatZ\")","src":1815,"more_decls":null}{"pl":"const RenameError = error{\n    /// In WASI, this error may occur when the file descriptor does\n    /// not hold the required rights to rename a resource by path relative to it.\n    AccessDenied,\n    FileBusy,\n    DiskQuota,\n    IsDir,\n    SymLinkLoop,\n    LinkQuotaExceeded,\n    NameTooLong,\n    FileNotFound,\n    NotDir,\n    SystemResources,\n    NoSpaceLeft,\n    PathAlreadyExists,\n    ReadOnlyFileSystem,\n    RenameAcrossMountPoints,\n    InvalidUtf8,\n    BadPathName,\n    NoDevice,\n    SharingViolation,\n    PipeBusy,\n} || UnexpectedError","src":1884,"more_decls":null}{"pl":"const renameC = @compileError(\"deprecated: renamed to renameZ\")","src":1923,"more_decls":null}{"pl":"const mkdiratC = @compileError(\"deprecated: renamed to mkdiratZ\")","src":2118,"more_decls":null}{"pl":"const MakeDirError = error{\n    /// In WASI, this error may occur when the file descriptor does\n    /// not hold the required rights to create a new directory relative to it.\n    AccessDenied,\n    DiskQuota,\n    PathAlreadyExists,\n    SymLinkLoop,\n    LinkQuotaExceeded,\n    NameTooLong,\n    FileNotFound,\n    SystemResources,\n    NoSpaceLeft,\n    NotDir,\n    ReadOnlyFileSystem,\n    InvalidUtf8,\n    BadPathName,\n    NoDevice,\n} || UnexpectedError","src":2183,"more_decls":null}{"pl":"const DeleteDirError = error{\n    AccessDenied,\n    FileBusy,\n    SymLinkLoop,\n    NameTooLong,\n    FileNotFound,\n    SystemResources,\n    NotDir,\n    DirNotEmpty,\n    ReadOnlyFileSystem,\n    InvalidUtf8,\n    BadPathName,\n} || UnexpectedError","src":2258,"more_decls":null}{"pl":"const rmdirC = @compileError(\"deprecated: renamed to rmdirZ\")","src":2285,"more_decls":null}{"pl":"const ChangeCurDirError = error{\n    AccessDenied,\n    FileSystem,\n    SymLinkLoop,\n    NameTooLong,\n    FileNotFound,\n    SystemResources,\n    NotDir,\n    BadPathName,\n\n    /// On Windows, file paths must be valid Unicode.\n    InvalidUtf8,\n} || UnexpectedError","src":2320,"more_decls":null}{"pl":"const chdirC = @compileError(\"deprecated: renamed to chdirZ\")","src":2350,"more_decls":null}{"pl":"const FchdirError = error{\n    AccessDenied,\n    NotDir,\n    FileSystem,\n} || UnexpectedError","src":2382,"more_decls":null}{"pl":"const ReadLinkError = error{\n    /// In WASI, this error may occur when the file descriptor does\n    /// not hold the required rights to read value of a symbolic link relative to it.\n    AccessDenied,\n    FileSystem,\n    SymLinkLoop,\n    NameTooLong,\n    FileNotFound,\n    SystemResources,\n    NotDir,\n    InvalidUtf8,\n    BadPathName,\n    /// Windows-only. This error may occur if the opened reparse point is\n    /// of unsupported type.\n    UnsupportedReparsePointType,\n} || UnexpectedError","src":2402,"more_decls":null}{"pl":"const readlinkC = @compileError(\"deprecated: renamed to readlinkZ\")","src":2433,"more_decls":null}{"pl":"const readlinkatC = @compileError(\"deprecated: renamed to readlinkatZ\")","src":2478,"more_decls":null}{"pl":"const SetEidError = error{\n    InvalidUserId,\n    PermissionDenied,\n} || UnexpectedError","src":2529,"more_decls":null}{"pl":"const SetIdError = error{ResourceLimitReached} || SetEidError","src":2534,"more_decls":null}{"pl":"const SocketError = error{\n    /// Permission to create a socket of the specified type and/or\n    /// protocol is denied.\n    PermissionDenied,\n\n    /// The implementation does not support the specified address family.\n    AddressFamilyNotSupported,\n\n    /// Unknown protocol, or protocol family not available.\n    ProtocolFamilyNotAvailable,\n\n    /// The per-process limit on the number of open file descriptors has been reached.\n    ProcessFdQuotaExceeded,\n\n    /// The system-wide limit on the total number of open files has been reached.\n    SystemFdQuotaExceeded,\n\n    /// Insufficient memory is available. The socket cannot be created until sufficient\n    /// resources are freed.\n    SystemResources,\n\n    /// The protocol type or the specified protocol is not supported within this domain.\n    ProtocolNotSupported,\n\n    /// The socket type is not supported by the protocol.\n    SocketTypeNotSupported,\n} || UnexpectedError","src":2660,"more_decls":null}{"pl":"const ShutdownError = error{\n    ConnectionAborted,\n\n    /// Connection was reset by peer, application should close socket as it is no longer usable.\n    ConnectionResetByPeer,\n    BlockingOperationInProgress,\n\n    /// The network subsystem has failed.\n    NetworkSubsystemFailed,\n\n    /// The socket is not connected (connection-oriented sockets only).\n    SocketNotConnected,\n    SystemResources,\n} || UnexpectedError","src":2734,"more_decls":null}{"pl":"const BindError = error{\n    /// The address is protected, and the user is not the superuser.\n    /// For UNIX domain sockets: Search permission is denied on  a  component\n    /// of  the  path  prefix.\n    AccessDenied,\n\n    /// The given address is already in use, or in the case of Internet domain sockets,\n    /// The  port number was specified as zero in the socket\n    /// address structure, but, upon attempting to bind to  an  ephemeral  port,  it  was\n    /// determined  that  all  port  numbers in the ephemeral port range are currently in\n    /// use.  See the discussion of /proc/sys/net/ipv4/ip_local_port_range ip(7).\n    AddressInUse,\n\n    /// A nonexistent interface was requested or the requested address was not local.\n    AddressNotAvailable,\n\n    /// Too many symbolic links were encountered in resolving addr.\n    SymLinkLoop,\n\n    /// addr is too long.\n    NameTooLong,\n\n    /// A component in the directory prefix of the socket pathname does not exist.\n    FileNotFound,\n\n    /// Insufficient kernel memory was available.\n    SystemResources,\n\n    /// A component of the path prefix is not a directory.\n    NotDir,\n\n    /// The socket inode would reside on a read-only filesystem.\n    ReadOnlyFileSystem,\n\n    /// The network subsystem has failed.\n    NetworkSubsystemFailed,\n\n    FileDescriptorNotASocket,\n\n    AlreadyBound,\n} || UnexpectedError","src":2796,"more_decls":null}{"pl":"const ListenError = error{\n    /// Another socket is already listening on the same port.\n    /// For Internet domain sockets, the  socket referred to by sockfd had not previously\n    /// been bound to an address and, upon attempting to bind it to an ephemeral port, it\n    /// was determined that all port numbers in the ephemeral port range are currently in\n    /// use.  See the discussion of /proc/sys/net/ipv4/ip_local_port_range in ip(7).\n    AddressInUse,\n\n    /// The file descriptor sockfd does not refer to a socket.\n    FileDescriptorNotASocket,\n\n    /// The socket is not of a type that supports the listen() operation.\n    OperationNotSupported,\n\n    /// The network subsystem has failed.\n    NetworkSubsystemFailed,\n\n    /// Ran out of system resources\n    /// On Windows it can either run out of socket descriptors or buffer space\n    SystemResources,\n\n    /// Already connected\n    AlreadyConnected,\n\n    /// Socket has not been bound yet\n    SocketNotBound,\n} || UnexpectedError","src":2881,"more_decls":null}{"pl":"const AcceptError = error{\n    ConnectionAborted,\n\n    /// The file descriptor sockfd does not refer to a socket.\n    FileDescriptorNotASocket,\n\n    /// The per-process limit on the number of open file descriptors has been reached.\n    ProcessFdQuotaExceeded,\n\n    /// The system-wide limit on the total number of open files has been reached.\n    SystemFdQuotaExceeded,\n\n    /// Not enough free memory.  This often means that the memory allocation  is  limited\n    /// by the socket buffer limits, not by the system memory.\n    SystemResources,\n\n    /// Socket is not listening for new connections.\n    SocketNotListening,\n\n    ProtocolFailure,\n\n    /// Firewall rules forbid connection.\n    BlockedByFirewall,\n\n    /// This error occurs when no global event loop is configured,\n    /// and accepting from the socket would block.\n    WouldBlock,\n\n    /// An incoming connection was indicated, but was subsequently terminated by the\n    /// remote peer prior to accepting the call.\n    ConnectionResetByPeer,\n\n    /// The network subsystem has failed.\n    NetworkSubsystemFailed,\n\n    /// The referenced socket is not a type that supports connection-oriented service.\n    OperationNotSupported,\n} || UnexpectedError","src":2940,"more_decls":null}{"pl":"const EpollCreateError = error{\n    /// The  per-user   limit   on   the   number   of   epoll   instances   imposed   by\n    /// /proc/sys/fs/epoll/max_user_instances  was encountered.  See epoll(7) for further\n    /// details.\n    /// Or, The per-process limit on the number of open file descriptors has been reached.\n    ProcessFdQuotaExceeded,\n\n    /// The system-wide limit on the total number of open files has been reached.\n    SystemFdQuotaExceeded,\n\n    /// There was insufficient memory to create the kernel object.\n    SystemResources,\n} || UnexpectedError","src":3064,"more_decls":null}{"pl":"const EpollCtlError = error{\n    /// op was EPOLL_CTL_ADD, and the supplied file descriptor fd is  already  registered\n    /// with this epoll instance.\n    FileDescriptorAlreadyPresentInSet,\n\n    /// fd refers to an epoll instance and this EPOLL_CTL_ADD operation would result in a\n    /// circular loop of epoll instances monitoring one another.\n    OperationCausesCircularLoop,\n\n    /// op was EPOLL_CTL_MOD or EPOLL_CTL_DEL, and fd is not registered with  this  epoll\n    /// instance.\n    FileDescriptorNotRegistered,\n\n    /// There was insufficient memory to handle the requested op control operation.\n    SystemResources,\n\n    /// The  limit  imposed  by /proc/sys/fs/epoll/max_user_watches was encountered while\n    /// trying to register (EPOLL_CTL_ADD) a new file descriptor on  an  epoll  instance.\n    /// See epoll(7) for further details.\n    UserResourceLimitReached,\n\n    /// The target file fd does not support epoll.  This error can occur if fd refers to,\n    /// for example, a regular file or a directory.\n    FileDescriptorIncompatibleWithEpoll,\n} || UnexpectedError","src":3091,"more_decls":null}{"pl":"const EventFdError = error{\n    SystemResources,\n    ProcessFdQuotaExceeded,\n    SystemFdQuotaExceeded,\n} || UnexpectedError","src":3152,"more_decls":null}{"pl":"const GetSockNameError = error{\n    /// Insufficient resources were available in the system to perform the operation.\n    SystemResources,\n\n    /// The network subsystem has failed.\n    NetworkSubsystemFailed,\n\n    /// Socket hasn't been bound yet\n    SocketNotBound,\n\n    FileDescriptorNotASocket,\n} || UnexpectedError","src":3172,"more_decls":null}{"pl":"const ConnectError = error{\n    /// For UNIX domain sockets, which are identified by pathname: Write permission is denied on  the  socket\n    /// file,  or  search  permission  is  denied  for  one of the directories in the path prefix.\n    /// or\n    /// The user tried to connect to a broadcast address without having the socket broadcast flag enabled  or\n    /// the connection request failed because of a local firewall rule.\n    PermissionDenied,\n\n    /// Local address is already in use.\n    AddressInUse,\n\n    /// (Internet  domain  sockets)  The  socket  referred  to  by sockfd had not previously been bound to an\n    /// address and, upon attempting to bind it to an ephemeral port, it was determined that all port numbers\n    /// in    the    ephemeral    port    range    are   currently   in   use.    See   the   discussion   of\n    /// /proc/sys/net/ipv4/ip_local_port_range in ip(7).\n    AddressNotAvailable,\n\n    /// The passed address didn't have the correct address family in its sa_family field.\n    AddressFamilyNotSupported,\n\n    /// Insufficient entries in the routing cache.\n    SystemResources,\n\n    /// A connect() on a stream socket found no one listening on the remote address.\n    ConnectionRefused,\n\n    /// Network is unreachable.\n    NetworkUnreachable,\n\n    /// Timeout  while  attempting  connection.   The server may be too busy to accept new connections.  Note\n    /// that for IP sockets the timeout may be very long when syncookies are enabled on the server.\n    ConnectionTimedOut,\n\n    /// This error occurs when no global event loop is configured,\n    /// and connecting to the socket would block.\n    WouldBlock,\n\n    /// The given path for the unix socket does not exist.\n    FileNotFound,\n\n    /// Connection was reset by peer before connect could complete.\n    ConnectionResetByPeer,\n} || UnexpectedError","src":3214,"more_decls":null}{"pl":"const Stat = if (builtin.link_libc)\n    system.libc_stat\nelse\n    system.kernel_stat","src":3371,"more_decls":null}{"pl":"const FStatError = error{\n    SystemResources,\n\n    /// In WASI, this error may occur when the file descriptor does\n    /// not hold the required rights to get its filestat information.\n    AccessDenied,\n} || UnexpectedError","src":3376,"more_decls":null}{"pl":"const FStatAtError = FStatError || error{ NameTooLong, FileNotFound }","src":3413,"more_decls":null}{"pl":"const fstatatC = @compileError(\"deprecated: renamed to fstatatZ\")","src":3429,"more_decls":null}{"pl":"const KQueueError = error{\n    /// The per-process limit on the number of open file descriptors has been reached.\n    ProcessFdQuotaExceeded,\n\n    /// The system-wide limit on the total number of open files has been reached.\n    SystemFdQuotaExceeded,\n} || UnexpectedError","src":3468,"more_decls":null}{"pl":"const KEventError = error{\n    /// The process does not have permission to register a filter.\n    AccessDenied,\n\n    /// The event could not be found to be modified or deleted.\n    EventNotFound,\n\n    /// No memory was available to register the event.\n    SystemResources,\n\n    /// The specified process to attach to does not exist.\n    ProcessNotFound,\n\n    /// changelist or eventlist had too many items on it.\n    /// TODO remove this possibility\n    Overflow,\n}","src":3486,"more_decls":null}{"pl":"const INotifyInitError = error{\n    ProcessFdQuotaExceeded,\n    SystemFdQuotaExceeded,\n    SystemResources,\n} || UnexpectedError","src":3534,"more_decls":null}{"pl":"const INotifyAddWatchError = error{\n    AccessDenied,\n    NameTooLong,\n    FileNotFound,\n    SystemResources,\n    UserResourceLimitReached,\n} || UnexpectedError","src":3553,"more_decls":null}{"pl":"const inotify_add_watchC = @compileError(\"deprecated: renamed to inotify_add_watchZ\")","src":3567,"more_decls":null}{"pl":"const MProtectError = error{\n    /// The memory cannot be given the specified access.  This can happen, for example, if you\n    /// mmap(2)  a  file  to  which  you have read-only access, then ask mprotect() to mark it\n    /// PROT_WRITE.\n    AccessDenied,\n\n    /// Changing  the  protection  of a memory region would result in the total number of map\n    /// pings with distinct attributes (e.g., read versus read/write protection) exceeding the\n    /// allowed maximum.  (For example, making the protection of a range PROT_READ in the mid\n    /// dle of a region currently protected as PROT_READ|PROT_WRITE would result in three map\n    /// pings: two read/write mappings at each end and a read-only mapping in the middle.)\n    OutOfMemory,\n} || UnexpectedError","src":3596,"more_decls":null}{"pl":"const ForkError = error{SystemResources} || UnexpectedError","src":3622,"more_decls":null}{"pl":"const MMapError = error{\n    /// The underlying filesystem of the specified file does not support memory mapping.\n    MemoryMappingNotSupported,\n\n    /// A file descriptor refers to a non-regular file. Or a file mapping was requested,\n    /// but the file descriptor is not open for reading. Or `MAP_SHARED` was requested\n    /// and `PROT_WRITE` is set, but the file descriptor is not open in `O_RDWR` mode.\n    /// Or `PROT_WRITE` is set, but the file is append-only.\n    AccessDenied,\n\n    /// The `prot` argument asks for `PROT_EXEC` but the mapped area belongs to a file on\n    /// a filesystem that was mounted no-exec.\n    PermissionDenied,\n    LockedMemoryLimitExceeded,\n    OutOfMemory,\n} || UnexpectedError","src":3634,"more_decls":null}{"pl":"const AccessError = error{\n    PermissionDenied,\n    FileNotFound,\n    NameTooLong,\n    InputOutput,\n    SystemResources,\n    BadPathName,\n    FileBusy,\n    SymLinkLoop,\n    ReadOnlyFileSystem,\n\n    /// On Windows, file paths must be valid Unicode.\n    InvalidUtf8,\n} || UnexpectedError","src":3703,"more_decls":null}{"pl":"const accessC = @compileError(\"Deprecated in favor of `accessZ`\")","src":3730,"more_decls":null}{"pl":"const PipeError = error{\n    SystemFdQuotaExceeded,\n    ProcessFdQuotaExceeded,\n} || UnexpectedError","src":3846,"more_decls":null}{"pl":"const SysCtlError = error{\n    PermissionDenied,\n    SystemResources,\n    NameTooLong,\n    UnknownName,\n} || UnexpectedError","src":3915,"more_decls":null}{"pl":"const sysctlbynameC = @compileError(\"deprecated: renamed to sysctlbynameZ\")","src":3947,"more_decls":null}{"pl":"const SeekError = error{\n    Unseekable,\n\n    /// In WASI, this error may occur when the file descriptor does\n    /// not hold the required rights to seek on it.\n    AccessDenied,\n} || UnexpectedError","src":3981,"more_decls":null}{"pl":"const FcntlError = error{\n    PermissionDenied,\n    FileBusy,\n    ProcessFdQuotaExceeded,\n    Locked,\n} || UnexpectedError","src":4155,"more_decls":null}{"pl":"const FlockError = error{\n    WouldBlock,\n\n    /// The kernel ran out of memory for allocating file locks\n    SystemResources,\n} || UnexpectedError","src":4230,"more_decls":null}{"pl":"const RealPathError = error{\n    FileNotFound,\n    AccessDenied,\n    NameTooLong,\n    NotSupported,\n    NotDir,\n    SymLinkLoop,\n    InputOutput,\n    FileTooBig,\n    IsDir,\n    ProcessFdQuotaExceeded,\n    SystemFdQuotaExceeded,\n    NoDevice,\n    SystemResources,\n    NoSpaceLeft,\n    FileSystem,\n    BadPathName,\n    DeviceBusy,\n\n    SharingViolation,\n    PipeBusy,\n\n    /// On Windows, file paths must be valid Unicode.\n    InvalidUtf8,\n\n    PathAlreadyExists,\n} || UnexpectedError","src":4252,"more_decls":null}{"pl":"const realpathC = @compileError(\"deprecated: renamed realpathZ\")","src":4297,"more_decls":null}{"pl":"const ClockGetTimeError = error{UnsupportedClock} || UnexpectedError","src":4520,"more_decls":null}{"pl":"const SchedGetAffinityError = error{PermissionDenied} || UnexpectedError","src":4587,"more_decls":null}{"doc_comment":"Whether or not error.Unexpected will print its value and a stack trace.\nif this happens the fix is to add the error code to the corresponding\nswitch expression, possibly introduce a new error in the error set, and\nsend a patch to Zig.","pl":"const unexpected_error_tracing = builtin.mode == .Debug","src":4617,"more_decls":null}{"pl":"const UnexpectedError = error{\n    /// The Operating System returned an undocumented error code.\n    /// This error is in theory not possible, but it would be better\n    /// to handle this error than to invoke undefined behavior.\n    Unexpected,\n}","src":4619,"more_decls":null}{"pl":"const SigaltstackError = error{\n    /// The supplied stack size was less than MINSIGSTKSZ.\n    SizeTooSmall,\n\n    /// Attempted to change the signal stack while it was active.\n    PermissionDenied,\n} || UnexpectedError","src":4640,"more_decls":null}{"pl":"const FutimensError = error{\n    /// times is NULL, or both tv_nsec values are UTIME_NOW, and either:\n    /// *  the effective user ID of the caller does not match the  owner\n    ///    of  the  file,  the  caller does not have write access to the\n    ///    file, and the caller is not privileged (Linux: does not  have\n    ///    either  the  CAP_FOWNER  or the CAP_DAC_OVERRIDE capability);\n    ///    or,\n    /// *  the file is marked immutable (see chattr(1)).\n    AccessDenied,\n\n    /// The caller attempted to change one or both timestamps to a value\n    /// other than the current time, or to change one of the  timestamps\n    /// to the current time while leaving the other timestamp unchanged,\n    /// (i.e., times is not NULL, neither tv_nsec  field  is  UTIME_NOW,\n    /// and neither tv_nsec field is UTIME_OMIT) and either:\n    /// *  the  caller's  effective  user ID does not match the owner of\n    ///    file, and the caller is not privileged (Linux: does not  have\n    ///    the CAP_FOWNER capability); or,\n    /// *  the file is marked append-only or immutable (see chattr(1)).\n    PermissionDenied,\n\n    ReadOnlyFileSystem,\n} || UnexpectedError","src":4669,"more_decls":null}{"pl":"const GetHostNameError = error{PermissionDenied} || UnexpectedError","src":4724,"more_decls":null}{"pl":"const SendError = error{\n    /// (For UNIX domain sockets, which are identified by pathname) Write permission is  denied\n    /// on  the destination socket file, or search permission is denied for one of the\n    /// directories the path prefix.  (See path_resolution(7).)\n    /// (For UDP sockets) An attempt was made to send to a network/broadcast address as  though\n    /// it was a unicast address.\n    AccessDenied,\n\n    /// The socket is marked nonblocking and the requested operation would block, and\n    /// there is no global event loop configured.\n    /// It's also possible to get this error under the following condition:\n    /// (Internet  domain datagram sockets) The socket referred to by sockfd had not previously\n    /// been bound to an address and, upon attempting to bind it to an ephemeral port,  it  was\n    /// determined that all port numbers in the ephemeral port range are currently in use.  See\n    /// the discussion of /proc/sys/net/ipv4/ip_local_port_range in ip(7).\n    WouldBlock,\n\n    /// Another Fast Open is already in progress.\n    FastOpenAlreadyInProgress,\n\n    /// Connection reset by peer.\n    ConnectionResetByPeer,\n\n    /// The  socket  type requires that message be sent atomically, and the size of the message\n    /// to be sent made this impossible. The message is not transmitted.\n    MessageTooBig,\n\n    /// The output queue for a network interface was full.  This generally indicates  that  the\n    /// interface  has  stopped sending, but may be caused by transient congestion.  (Normally,\n    /// this does not occur in Linux.  Packets are just silently dropped when  a  device  queue\n    /// overflows.)\n    /// This is also caused when there is not enough kernel memory available.\n    SystemResources,\n\n    /// The  local  end  has been shut down on a connection oriented socket.  In this case, the\n    /// process will also receive a SIGPIPE unless MSG_NOSIGNAL is set.\n    BrokenPipe,\n\n    FileDescriptorNotASocket,\n\n    /// Network is unreachable.\n    NetworkUnreachable,\n\n    /// The local network interface used to reach the destination is down.\n    NetworkSubsystemFailed,\n} || UnexpectedError","src":4803,"more_decls":null}{"pl":"const SendMsgError = SendError || error{\n    /// The passed address didn't have the correct address family in its sa_family field.\n    AddressFamilyNotSupported,\n\n    /// Returned when socket is AF_UNIX and the given path has a symlink loop.\n    SymLinkLoop,\n\n    /// Returned when socket is AF_UNIX and the given path length exceeds `MAX_PATH_BYTES` bytes.\n    NameTooLong,\n\n    /// Returned when socket is AF_UNIX and the given path does not point to an existing file.\n    FileNotFound,\n    NotDir,\n\n    /// The socket is not connected (connection-oriented sockets only).\n    SocketNotConnected,\n    AddressNotAvailable,\n}","src":4850,"more_decls":null}{"pl":"const SendToError = SendMsgError","src":4940,"more_decls":null}{"pl":"const SendFileError = PReadError || WriteError || SendError","src":5078,"more_decls":null}{"pl":"const CopyFileRangeError = error{\n    FileTooBig,\n    InputOutput,\n    /// `fd_in` is not open for reading; or `fd_out` is not open  for  writing;\n    /// or the  `O_APPEND`  flag  is  set  for `fd_out`.\n    FilesOpenedWithWrongFlags,\n    IsDir,\n    OutOfMemory,\n    NoSpaceLeft,\n    Unseekable,\n    PermissionDenied,\n    FileBusy,\n} || PReadError || PWriteError || UnexpectedError","src":5392,"more_decls":null}{"pl":"const PollError = error{\n    /// The network subsystem has failed.\n    NetworkSubsystemFailed,\n\n    /// The kernel had no space to allocate file descriptor tables.\n    SystemResources,\n} || UnexpectedError","src":5480,"more_decls":null}{"pl":"const PPollError = error{\n    /// The operation was interrupted by a delivery of a signal before it could complete.\n    SignalInterrupt,\n\n    /// The kernel had no space to allocate file descriptor tables.\n    SystemResources,\n} || UnexpectedError","src":5518,"more_decls":null}{"pl":"const RecvFromError = error{\n    /// The socket is marked nonblocking and the requested operation would block, and\n    /// there is no global event loop configured.\n    WouldBlock,\n\n    /// A remote host refused to allow the network connection, typically because it is not\n    /// running the requested service.\n    ConnectionRefused,\n\n    /// Could not allocate kernel memory.\n    SystemResources,\n\n    ConnectionResetByPeer,\n\n    /// The socket has not been bound.\n    SocketNotBound,\n\n    /// The UDP message was too big for the buffer and part of it has been discarded\n    MessageTooBig,\n\n    /// The network subsystem has failed.\n    NetworkSubsystemFailed,\n\n    /// The socket is not connected (connection-oriented sockets only).\n    SocketNotConnected,\n} || UnexpectedError","src":5544,"more_decls":null}{"pl":"const DnExpandError = error{InvalidDnsPacket}","src":5621,"more_decls":null}{"pl":"const SchedYieldError = error{\n    /// The system is not configured to allow yielding\n    SystemCannotYield,\n}","src":5671,"more_decls":null}{"pl":"const SetSockOptError = error{\n    /// The socket is already connected, and a specified option cannot be set while the socket is connected.\n    AlreadyConnected,\n\n    /// The option is not supported by the protocol.\n    InvalidProtocolOption,\n\n    /// The send and receive timeout values are too big to fit into the timeout fields in the socket structure.\n    TimeoutTooBig,\n\n    /// Insufficient resources are available in the system to complete the call.\n    SystemResources,\n\n    // Setting the socket option requires more elevated permissions.\n    PermissionDenied,\n\n    NetworkSubsystemFailed,\n    FileDescriptorNotASocket,\n    SocketNotBound,\n} || UnexpectedError","src":5690,"more_decls":null}{"pl":"const MemFdCreateError = error{\n    SystemFdQuotaExceeded,\n    ProcessFdQuotaExceeded,\n    OutOfMemory,\n\n    /// memfd_create is available in Linux 3.17 and later. This error is returned\n    /// for older kernel versions.\n    SystemOutdated,\n} || UnexpectedError","src":5744,"more_decls":null}{"pl":"const memfd_createC = @compileError(\"deprecated: renamed to memfd_createZ\")","src":5754,"more_decls":null}{"pl":"const MFD_NAME_PREFIX = \"memfd:\"","src":5774,"more_decls":null}{"pl":"const MFD_MAX_NAME_LEN = NAME_MAX - MFD_NAME_PREFIX.len","src":5775,"more_decls":null}{"pl":"const TermiosGetError = error{NotATerminal} || UnexpectedError","src":5801,"more_decls":null}{"pl":"const TermiosSetError = TermiosGetError || error{ProcessOrphaned}","src":5816,"more_decls":null}{"pl":"const IoCtl_SIOCGIFINDEX_Error = error{\n    FileSystem,\n    InterfaceNotFound,\n} || UnexpectedError","src":5832,"more_decls":null}{"pl":"const SyncError = error{\n    InputOutput,\n    NoSpaceLeft,\n    DiskQuota,\n    AccessDenied,\n} || UnexpectedError","src":5868,"more_decls":null}{"pl":"const PrctlError = error{\n    /// Can only occur with PR_SET_SECCOMP/SECCOMP_MODE_FILTER or\n    /// PR_SET_MM/PR_SET_MM_EXE_FILE\n    AccessDenied,\n    /// Can only occur with PR_SET_MM/PR_SET_MM_EXE_FILE\n    InvalidFileDescriptor,\n    InvalidAddress,\n    /// Can only occur with PR_SET_SPECULATION_CTRL, PR_MPX_ENABLE_MANAGEMENT,\n    /// or PR_MPX_DISABLE_MANAGEMENT\n    UnsupportedFeature,\n    /// Can only occur wih PR_SET_FP_MODE\n    OperationNotSupported,\n    PermissionDenied,\n} || UnexpectedError","src":5936,"more_decls":null}{"pl":"const GetrlimitError = UnexpectedError","src":5978,"more_decls":null}{"pl":"const SetrlimitError = error{PermissionDenied} || UnexpectedError","src":5991,"more_decls":null}{"pl":"const MadviseError = error{\n    /// advice is MADV_REMOVE, but the specified address range is not a shared writable mapping.\n    AccessDenied,\n    /// advice is MADV_HWPOISON, but the caller does not have the CAP_SYS_ADMIN capability.\n    PermissionDenied,\n    /// A kernel resource was temporarily unavailable.\n    SystemResources,\n    /// One of the following:\n    /// * addr is not page-aligned or length is negative\n    /// * advice is not valid\n    /// * advice is MADV_DONTNEED or MADV_REMOVE and the specified address range\n    ///   includes locked, Huge TLB pages, or VM_PFNMAP pages.\n    /// * advice is MADV_MERGEABLE or MADV_UNMERGEABLE, but the kernel was not\n    ///   configured with CONFIG_KSM.\n    /// * advice is MADV_FREE or MADV_WIPEONFORK but the specified address range\n    ///   includes file, Huge TLB, MAP_SHARED, or VM_PFNMAP ranges.\n    InvalidSyscall,\n    /// (for MADV_WILLNEED) Paging in this area would exceed the process's\n    /// maximum resident set size.\n    WouldExceedMaximumResidentSetSize,\n    /// One of the following:\n    /// * (for MADV_WILLNEED) Not enough memory: paging in failed.\n    /// * Addresses in the specified range are not currently mapped, or\n    ///   are outside the address space of the process.\n    OutOfMemory,\n    /// The madvise syscall is not available on this version and configuration\n    /// of the Linux kernel.\n    MadviseUnavailable,\n    /// The operating system returned an undocumented error code.\n    Unexpected,\n}","src":6004,"more_decls":null}]