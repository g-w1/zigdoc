[{"pl":"pub const PrevStatus = enum ","src":96,"more_decls":{"pl":"stale","src":97,"more_decls":null}{"pl":"fresh","src":98,"more_decls":null}}{"pl":"pub const CopyFileOptions = struct ","src":101,"more_decls":{"doc_comment":"When this is `null` the mode is copied from the source file.","pl":"override_mode: ?File.Mode = null","src":103,"more_decls":null}}{"doc_comment":"TODO update this API to avoid a getrandom syscall for every operation.","pl":"pub const AtomicFile = struct ","src":131,"more_decls":{"pl":"file: File","src":132,"more_decls":null}{"pl":"tmp_path_buf: [TMP_PATH_LEN:0]u8","src":134,"more_decls":null}{"pl":"dest_basename: []const u8","src":135,"more_decls":null}{"pl":"file_open: bool","src":136,"more_decls":null}{"pl":"file_exists: bool","src":137,"more_decls":null}{"pl":"close_dir_on_deinit: bool","src":138,"more_decls":null}{"pl":"dir: Dir","src":139,"more_decls":null}{"doc_comment":"Note that the `Dir.atomicFile` API may be more handy than this lower-level function.","pl":"fn init(\n    dest_basename: []const u8,\n    mode: File.Mode,\n    dir: Dir,\n    close_dir_on_deinit: bool,\n) InitError!AtomicFile","src":147,"more_decls":null}{"doc_comment":"always call deinit, even after successful finish()","pl":"fn deinit(self: *AtomicFile) void","src":182,"more_decls":null}{"pl":"fn finish(self: *AtomicFile) !void","src":197,"more_decls":null}}{"pl":"pub const Dir = struct ","src":291,"more_decls":{"pl":"fd: os.fd_t","src":292,"more_decls":null}{"pl":"pub const Entry = struct ","src":294,"more_decls":{"pl":"name: []const u8","src":295,"more_decls":null}{"pl":"kind: Kind","src":296,"more_decls":null}{"pl":"const Kind = File.Kind","src":298,"more_decls":null}}{"pl":"pub const OpenDirOptions = struct ","src":1228,"more_decls":{"doc_comment":"`true` means the opened directory can be used as the `Dir` parameter\nfor functions which operate based on an open directory handle. When `false`,\nsuch operations are Illegal Behavior.","pl":"access_sub_paths: bool = true","src":1232,"more_decls":null}{"doc_comment":"`true` means the opened directory can be scanned for the files and sub-directories\nof the result. It means the `iterate` function can be called.","pl":"iterate: bool = false","src":1236,"more_decls":null}{"doc_comment":"`true` means it won't dereference the symlinks.","pl":"no_follow: bool = false","src":1239,"more_decls":null}}{"pl":"pub const AtomicFileOptions = struct ","src":1966,"more_decls":{"pl":"mode: File.Mode = File.default_mode","src":1967,"more_decls":null}}{"pl":"fn iterate(self: Dir) Iterator","src":693,"more_decls":null}{"pl":"fn close(self: *Dir) void","src":748,"more_decls":null}{"doc_comment":"Opens a file for reading or writing, without attempting to create a new file.\nTo create a new file, see `createFile`.\nCall `File.close` to release the resource.\nAsserts that the path parameter has no null bytes.","pl":"fn openFile(self: Dir, sub_path: []const u8, flags: File.OpenFlags) File.OpenError!File","src":761,"more_decls":null}{"doc_comment":"Same as `openFile` but WASI only.","pl":"fn openFileWasi(self: Dir, sub_path: []const u8, flags: File.OpenFlags) File.OpenError!File","src":774,"more_decls":null}{"doc_comment":"Same as `openFile` but the path parameter is null-terminated.","pl":"fn openFileZ(self: Dir, sub_path: [*:0]const u8, flags: File.OpenFlags) File.OpenError!File","src":801,"more_decls":null}{"doc_comment":"Same as `openFile` but Windows-only and the path parameter is\n[WTF-16](https://simonsapin.github.io/wtf-8/#potentially-ill-formed-utf-16) encoded.","pl":"fn openFileW(self: Dir, sub_path_w: []const u16, flags: File.OpenFlags) File.OpenError!File","src":877,"more_decls":null}{"doc_comment":"Creates, opens, or overwrites a file with write access.\nCall `File.close` on the result when done.\nAsserts that the path parameter has no null bytes.","pl":"fn createFile(self: Dir, sub_path: []const u8, flags: File.CreateFlags) File.OpenError!File","src":902,"more_decls":null}{"doc_comment":"Same as `createFile` but WASI only.","pl":"fn createFileWasi(self: Dir, sub_path: []const u8, flags: File.CreateFlags) File.OpenError!File","src":917,"more_decls":null}{"doc_comment":"Same as `createFile` but the path parameter is null-terminated.","pl":"fn createFileZ(self: Dir, sub_path_c: [*:0]const u8, flags: File.CreateFlags) File.OpenError!File","src":945,"more_decls":null}{"doc_comment":"Same as `createFile` but Windows-only and the path parameter is\n[WTF-16](https://simonsapin.github.io/wtf-8/#potentially-ill-formed-utf-16) encoded.","pl":"fn createFileW(self: Dir, sub_path_w: []const u16, flags: File.CreateFlags) File.OpenError!File","src":1012,"more_decls":null}{"pl":"pub fn makeDir(self: Dir, sub_path: []const u8) !void {\n    try os.mkdirat(self.fd, sub_path, default_new_dir_mode);\n}","src":1042,"more_decls":null}{"pl":"pub fn makeDirZ(self: Dir, sub_path: [*:0]const u8) !void {\n    try os.mkdiratZ(self.fd, sub_path, default_new_dir_mode);\n}","src":1046,"more_decls":null}{"pl":"pub fn makeDirW(self: Dir, sub_path: [*:0]const u16) !void {\n    try os.mkdiratW(self.fd, sub_path, default_new_dir_mode);\n}","src":1050,"more_decls":null}{"doc_comment":"Calls makeDir recursively to make an entire path. Returns success if the path\nalready exists and is a directory.\nThis function is not atomic, and if it returns an error, the file system may\nhave been modified regardless.","pl":"fn makePath(self: Dir, sub_path: []const u8) !void","src":1058,"more_decls":null}{"doc_comment":"This function performs `makePath`, followed by `openDir`.\nIf supported by the OS, this operation is atomic. It is not atomic on\nall operating systems.","pl":"pub fn makeOpenPath(self: Dir, sub_path: []const u8, open_dir_options: OpenDirOptions) !Dir {\n    // TODO improve this implementation on Windows; we can avoid 1 call to NtClose\n    try self.makePath(sub_path);\n    return self.openDir(sub_path, open_dir_options);\n}","src":1091,"more_decls":null}{"doc_comment":"This function returns the canonicalized absolute pathname of\n`pathname` relative to this `Dir`. If `pathname` is absolute, ignores this\n`Dir` handle and returns the canonicalized absolute pathname of `pathname`\nargument.\nThis function is not universally supported by all platforms.\nCurrently supported hosts are: Linux, macOS, and Windows.\nSee also `Dir.realpathZ`, `Dir.realpathW`, and `Dir.realpathAlloc`.","pl":"fn realpath(self: Dir, pathname: []const u8, out_buffer: []u8) ![]u8","src":1104,"more_decls":null}{"doc_comment":"Same as `Dir.realpath` except `pathname` is null-terminated.\nSee also `Dir.realpath`, `realpathZ`.","pl":"fn realpathZ(self: Dir, pathname: [*:0]const u8, out_buffer: []u8) ![]u8","src":1118,"more_decls":null}{"doc_comment":"Windows-only. Same as `Dir.realpath` except `pathname` is WTF16 encoded.\nSee also `Dir.realpath`, `realpathW`.","pl":"fn realpathW(self: Dir, pathname: []const u16, out_buffer: []u8) ![]u8","src":1151,"more_decls":null}{"doc_comment":"Same as `Dir.realpath` except caller must free the returned memory.\nSee also `Dir.realpath`.","pl":"fn realpathAlloc(self: Dir, allocator: *Allocator, pathname: []const u8) ![]u8","src":1203,"more_decls":null}{"doc_comment":"Changes the current working directory to the open directory handle.\nThis modifies global state and can have surprising effects in multi-\nthreaded applications. Most applications and especially libraries should\nnot call this function as a general rule, however it can have use cases\nin, for example, implementing a shell, or child process execution.\nNot all targets support this. For example, WASI does not have the concept\nof a current working directory.","pl":"pub fn setAsCwd(self: Dir) !void {\n    if (builtin.os.tag == .wasi) {\n        @compileError(\"changing cwd is not currently possible in WASI\");\n    }\n    try os.fchdir(self.fd);\n}","src":1221,"more_decls":null}{"doc_comment":"Opens a directory at the given path. The directory is a system resource that remains\nopen until `close` is called on the result.\n\nAsserts that the path parameter has no null bytes.","pl":"fn openDir(self: Dir, sub_path: []const u8, args: OpenDirOptions) OpenError!Dir","src":1246,"more_decls":null}{"doc_comment":"Same as `openDir` except only WASI.","pl":"fn openDirWasi(self: Dir, sub_path: []const u8, args: OpenDirOptions) OpenError!Dir","src":1261,"more_decls":null}{"doc_comment":"Same as `openDir` except the parameter is null-terminated.","pl":"fn openDirZ(self: Dir, sub_path_c: [*:0]const u8, args: OpenDirOptions) OpenError!Dir","src":1301,"more_decls":null}{"doc_comment":"Same as `openDir` except the path parameter is WTF-16 encoded, NT-prefixed.\nThis function asserts the target OS is Windows.","pl":"fn openDirW(self: Dir, sub_path_w: [*:0]const u16, args: OpenDirOptions) OpenError!Dir","src":1317,"more_decls":null}{"doc_comment":"Delete a file name and possibly the file it refers to, based on an open directory handle.\nAsserts that the path parameter has no null bytes.","pl":"fn deleteFile(self: Dir, sub_path: []const u8) DeleteFileError!void","src":1404,"more_decls":null}{"doc_comment":"Same as `deleteFile` except the parameter is null-terminated.","pl":"fn deleteFileZ(self: Dir, sub_path_c: [*:0]const u8) DeleteFileError!void","src":1422,"more_decls":null}{"doc_comment":"Same as `deleteFile` except the parameter is WTF-16 encoded.","pl":"pub fn deleteFileW(self: Dir, sub_path_w: []const u16) DeleteFileError!void {\n    os.unlinkatW(self.fd, sub_path_w, 0) catch |err| switch (err) {\n        error.DirNotEmpty => unreachable, // not passing AT_REMOVEDIR\n        else => |e| return e,\n    };\n}","src":1441,"more_decls":null}{"doc_comment":"Returns `error.DirNotEmpty` if the directory is not empty.\nTo delete a directory recursively, see `deleteTree`.\nAsserts that the path parameter has no null bytes.","pl":"fn deleteDir(self: Dir, sub_path: []const u8) DeleteDirError!void","src":1467,"more_decls":null}{"doc_comment":"Same as `deleteDir` except the parameter is null-terminated.","pl":"pub fn deleteDirZ(self: Dir, sub_path_c: [*:0]const u8) DeleteDirError!void {\n    os.unlinkatZ(self.fd, sub_path_c, os.AT_REMOVEDIR) catch |err| switch (err) {\n        error.IsDir => unreachable, // not possible since we pass AT_REMOVEDIR\n        else => |e| return e,\n    };\n}","src":1483,"more_decls":null}{"doc_comment":"Same as `deleteDir` except the parameter is UTF16LE, NT prefixed.\nThis function is Windows-only.","pl":"pub fn deleteDirW(self: Dir, sub_path_w: []const u16) DeleteDirError!void {\n    os.unlinkatW(self.fd, sub_path_w, os.AT_REMOVEDIR) catch |err| switch (err) {\n        error.IsDir => unreachable, // not possible since we pass AT_REMOVEDIR\n        else => |e| return e,\n    };\n}","src":1492,"more_decls":null}{"doc_comment":"Change the name or location of a file or directory.\nIf new_sub_path already exists, it will be replaced.\nRenaming a file over an existing directory or a directory\nover an existing file will fail with `error.IsDir` or `error.NotDir`","pl":"pub fn rename(self: Dir, old_sub_path: []const u8, new_sub_path: []const u8) RenameError!void {\n    return os.renameat(self.fd, old_sub_path, self.fd, new_sub_path);\n}","src":1505,"more_decls":null}{"doc_comment":"Same as `rename` except the parameters are null-terminated.","pl":"pub fn renameZ(self: Dir, old_sub_path_z: [*:0]const u8, new_sub_path_z: [*:0]const u8) RenameError!void {\n    return os.renameatZ(self.fd, old_sub_path_z, self.fd, new_sub_path_z);\n}","src":1510,"more_decls":null}{"doc_comment":"Same as `rename` except the parameters are UTF16LE, NT prefixed.\nThis function is Windows-only.","pl":"pub fn renameW(self: Dir, old_sub_path_w: []const u16, new_sub_path_w: []const u16) RenameError!void {\n    return os.renameatW(self.fd, old_sub_path_w, self.fd, new_sub_path_w);\n}","src":1516,"more_decls":null}{"doc_comment":"Creates a symbolic link named `sym_link_path` which contains the string `target_path`.\nA symbolic link (also known as a soft link) may point to an existing file or to a nonexistent\none; the latter case is known as a dangling link.\nIf `sym_link_path` exists, it will not be overwritten.","pl":"fn symLink(\n    self: Dir,\n    target_path: []const u8,\n    sym_link_path: []const u8,\n    flags: SymLinkFlags,\n) !void","src":1524,"more_decls":null}{"doc_comment":"WASI-only. Same as `symLink` except targeting WASI.","pl":"fn symLinkWasi(\n    self: Dir,\n    target_path: []const u8,\n    sym_link_path: []const u8,\n    flags: SymLinkFlags,\n) !void","src":1544,"more_decls":null}{"doc_comment":"Same as `symLink`, except the pathname parameters are null-terminated.","pl":"fn symLinkZ(\n    self: Dir,\n    target_path_c: [*:0]const u8,\n    sym_link_path_c: [*:0]const u8,\n    flags: SymLinkFlags,\n) !void","src":1554,"more_decls":null}{"doc_comment":"Windows-only. Same as `symLink` except the pathname parameters\nare null-terminated, WTF16 encoded.","pl":"fn symLinkW(\n    self: Dir,\n    target_path_w: []const u16,\n    sym_link_path_w: []const u16,\n    flags: SymLinkFlags,\n) !void","src":1570,"more_decls":null}{"doc_comment":"Read value of a symbolic link.\nThe return value is a slice of `buffer`, from index `0`.\nAsserts that the path parameter has no null bytes.","pl":"fn readLink(self: Dir, sub_path: []const u8, buffer: []u8) ![]u8","src":1582,"more_decls":null}{"doc_comment":"WASI-only. Same as `readLink` except targeting WASI.","pl":"pub fn readLinkWasi(self: Dir, sub_path: []const u8, buffer: []u8) ![]u8 {\n    return os.readlinkatWasi(self.fd, sub_path, buffer);\n}","src":1597,"more_decls":null}{"doc_comment":"Same as `readLink`, except the `pathname` parameter is null-terminated.","pl":"fn readLinkZ(self: Dir, sub_path_c: [*:0]const u8, buffer: []u8) ![]u8","src":1602,"more_decls":null}{"doc_comment":"Windows-only. Same as `readLink` except the pathname parameter\nis null-terminated, WTF16 encoded.","pl":"pub fn readLinkW(self: Dir, sub_path_w: []const u16, buffer: []u8) ![]u8 {\n    return os.windows.ReadLink(self.fd, sub_path_w, buffer);\n}","src":1612,"more_decls":null}{"doc_comment":"Read all of file contents using a preallocated buffer.\nThe returned slice has the same pointer as `buffer`. If the length matches `buffer.len`\nthe situation is ambiguous. It could either mean that the entire file was read, and\nit exactly fits the buffer, or it could mean the buffer was not big enough for the\nentire file.","pl":"fn readFile(self: Dir, file_path: []const u8, buffer: []u8) ![]u8","src":1621,"more_decls":null}{"doc_comment":"On success, caller owns returned buffer.\nIf the file is larger than `max_bytes`, returns `error.FileTooBig`.","pl":"pub fn readFileAlloc(self: Dir, allocator: *mem.Allocator, file_path: []const u8, max_bytes: usize) ![]u8 {\n    return self.readFileAllocOptions(allocator, file_path, max_bytes, null, @alignOf(u8), null);\n}","src":1631,"more_decls":null}{"doc_comment":"On success, caller owns returned buffer.\nIf the file is larger than `max_bytes`, returns `error.FileTooBig`.\nIf `size_hint` is specified the initial buffer size is calculated using\nthat value, otherwise the effective file size is used instead.\nAllows specifying alignment and a sentinel value.","pl":"fn readFileAllocOptions(\n    self: Dir,\n    allocator: *mem.Allocator,\n    file_path: []const u8,\n    max_bytes: usize,\n    size_hint: ?usize,\n    comptime alignment: u29,\n    comptime optional_sentinel: ?u8,\n) !(if (optional_sentinel) |s| [:s]align(alignment) u8 else []align(alignment) u8)","src":1640,"more_decls":null}{"doc_comment":"Whether `full_path` describes a symlink, file, or directory, this function\nremoves it. If it cannot be removed because it is a non-empty directory,\nthis function recursively removes its entries and then tries again.\nThis operation is not atomic on most file systems.","pl":"fn deleteTree(self: Dir, sub_path: []const u8) DeleteTreeError!void","src":1690,"more_decls":null}{"doc_comment":"Writes content to the file system, creating a new file if it does not exist, truncating\nif it already exists.","pl":"pub fn writeFile(self: Dir, sub_path: []const u8, data: []const u8) !void {\n    var file = try self.createFile(sub_path, .{});\n    defer file.close();\n    try file.writeAll(data);\n}","src":1839,"more_decls":null}{"doc_comment":"Test accessing `path`.\n`path` is UTF8-encoded.\nBe careful of Time-Of-Check-Time-Of-Use race conditions when using this function.\nFor example, instead of testing if a file exists and then opening it, just\nopen it and handle the error for file not found.","pl":"fn access(self: Dir, sub_path: []const u8, flags: File.OpenFlags) AccessError!void","src":1852,"more_decls":null}{"doc_comment":"Same as `access` except the path parameter is null-terminated.","pl":"fn accessZ(self: Dir, sub_path: [*:0]const u8, flags: File.OpenFlags) AccessError!void","src":1862,"more_decls":null}{"doc_comment":"Same as `access` except asserts the target OS is Windows and the path parameter is\n* WTF-16 encoded\n* null-terminated\n* NtDll prefixed\nTODO currently this ignores `flags`.","pl":"pub fn accessW(self: Dir, sub_path_w: [*:0]const u16, flags: File.OpenFlags) AccessError!void {\n    return os.faccessatW(self.fd, sub_path_w, 0, 0);\n}","src":1885,"more_decls":null}{"doc_comment":"Check the file size, mtime, and mode of `source_path` and `dest_path`. If they are equal, does nothing.\nOtherwise, atomically copies `source_path` to `dest_path`. The destination file gains the mtime,\natime, and mode of the source file so that the next call to `updateFile` will not need a copy.\nReturns the previous status of the file before updating.\nIf any of the directories do not exist for dest_path, they are created.","pl":"fn updateFile(\n    source_dir: Dir,\n    source_path: []const u8,\n    dest_dir: Dir,\n    dest_path: []const u8,\n    options: CopyFileOptions,\n) !PrevStatus","src":1894,"more_decls":null}{"doc_comment":"Guaranteed to be atomic.\nOn Linux, until https://patchwork.kernel.org/patch/9636735/ is merged and readily available,\nthere is a possibility of power loss or application termination leaving temporary files present\nin the same directory as dest_path.","pl":"fn copyFile(\n    source_dir: Dir,\n    source_path: []const u8,\n    dest_dir: Dir,\n    dest_path: []const u8,\n    options: CopyFileOptions,\n) !void","src":1942,"more_decls":null}{"doc_comment":"Directly access the `.file` field, and then call `AtomicFile.finish`\nto atomically replace `dest_path` with contents.\nAlways call `AtomicFile.deinit` to clean up, regardless of whether `AtomicFile.finish` succeeded.\n`dest_path` must remain valid until `AtomicFile.deinit` is called.","pl":"fn atomicFile(self: Dir, dest_path: []const u8, options: AtomicFileOptions) !AtomicFile","src":1974,"more_decls":null}{"pl":"fn stat(self: Dir) StatError!Stat","src":1986,"more_decls":null}{"pl":"const Iterator = switch (builtin.os.tag) {\n        .macos, .ios, .freebsd, .netbsd, .dragonfly, .openbsd => struct {\n            dir: Dir,\n            seek: i64,\n            buf: [8192]u8, // TODO align(@alignOf(os.dirent)),\n            index: usize,\n            end_index: usize,\n\n            const Self = @This();\n\n            pub const Error = IteratorError;\n\n            /// Memory such as file names referenced in this returned entry becomes invalid\n            /// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.\n            pub fn next(self: *Self) Error!?Entry {\n                switch (builtin.os.tag) {\n                    .macos, .ios => return self.nextDarwin(),\n                    .freebsd, .netbsd, .dragonfly, .openbsd => return self.nextBsd(),\n                    else => @compileError(\"unimplemented\"),\n                }\n            }\n\n            fn nextDarwin(self: *Self) !?Entry {\n                start_over: while (true) {\n                    if (self.index >= self.end_index) {\n                        const rc = os.system.__getdirentries64(\n                            self.dir.fd,\n                            &self.buf,\n                            self.buf.len,\n                            &self.seek,\n                        );\n                        if (rc == 0) return null;\n                        if (rc < 0) {\n                            switch (os.errno(rc)) {\n                                os.EBADF => unreachable, // Dir is invalid or was opened without iteration ability\n                                os.EFAULT => unreachable,\n                                os.ENOTDIR => unreachable,\n                                os.EINVAL => unreachable,\n                                else => |err| return os.unexpectedErrno(err),\n                            }\n                        }\n                        self.index = 0;\n                        self.end_index = @intCast(usize, rc);\n                    }\n                    const darwin_entry = @ptrCast(*align(1) os.dirent, &self.buf[self.index]);\n                    const next_index = self.index + darwin_entry.reclen();\n                    self.index = next_index;\n\n                    const name = @ptrCast([*]u8, &darwin_entry.d_name)[0..darwin_entry.d_namlen];\n\n                    if (mem.eql(u8, name, \".\") or mem.eql(u8, name, \"..\") or (darwin_entry.d_ino == 0)) {\n                        continue :start_over;\n                    }\n\n                    const entry_kind = switch (darwin_entry.d_type) {\n                        os.DT_BLK => Entry.Kind.BlockDevice,\n                        os.DT_CHR => Entry.Kind.CharacterDevice,\n                        os.DT_DIR => Entry.Kind.Directory,\n                        os.DT_FIFO => Entry.Kind.NamedPipe,\n                        os.DT_LNK => Entry.Kind.SymLink,\n                        os.DT_REG => Entry.Kind.File,\n                        os.DT_SOCK => Entry.Kind.UnixDomainSocket,\n                        os.DT_WHT => Entry.Kind.Whiteout,\n                        else => Entry.Kind.Unknown,\n                    };\n                    return Entry{\n                        .name = name,\n                        .kind = entry_kind,\n                    };\n                }\n            }\n\n            fn nextBsd(self: *Self) !?Entry {\n                start_over: while (true) {\n                    if (self.index >= self.end_index) {\n                        const rc = if (builtin.os.tag == .netbsd)\n                            os.system.__getdents30(self.dir.fd, &self.buf, self.buf.len)\n                        else\n                            os.system.getdents(self.dir.fd, &self.buf, self.buf.len);\n                        switch (os.errno(rc)) {\n                            0 => {},\n                            os.EBADF => unreachable, // Dir is invalid or was opened without iteration ability\n                            os.EFAULT => unreachable,\n                            os.ENOTDIR => unreachable,\n                            os.EINVAL => unreachable,\n                            else => |err| return os.unexpectedErrno(err),\n                        }\n                        if (rc == 0) return null;\n                        self.index = 0;\n                        self.end_index = @intCast(usize, rc);\n                    }\n                    const bsd_entry = @ptrCast(*align(1) os.dirent, &self.buf[self.index]);\n                    const next_index = self.index + bsd_entry.reclen();\n                    self.index = next_index;\n\n                    const name = @ptrCast([*]u8, &bsd_entry.d_name)[0..bsd_entry.d_namlen];\n\n                    const skip_zero_fileno = switch (builtin.os.tag) {\n                        // d_fileno=0 is used to mark invalid entries or deleted files.\n                        .openbsd, .netbsd => true,\n                        else => false,\n                    };\n                    if (mem.eql(u8, name, \".\") or mem.eql(u8, name, \"..\") or\n                        (skip_zero_fileno and bsd_entry.d_fileno == 0))\n                    {\n                        continue :start_over;\n                    }\n\n                    const entry_kind = switch (bsd_entry.d_type) {\n                        os.DT_BLK => Entry.Kind.BlockDevice,\n                        os.DT_CHR => Entry.Kind.CharacterDevice,\n                        os.DT_DIR => Entry.Kind.Directory,\n                        os.DT_FIFO => Entry.Kind.NamedPipe,\n                        os.DT_LNK => Entry.Kind.SymLink,\n                        os.DT_REG => Entry.Kind.File,\n                        os.DT_SOCK => Entry.Kind.UnixDomainSocket,\n                        os.DT_WHT => Entry.Kind.Whiteout,\n                        else => Entry.Kind.Unknown,\n                    };\n                    return Entry{\n                        .name = name,\n                        .kind = entry_kind,\n                    };\n                }\n            }\n        },\n        .haiku => struct {\n            dir: Dir,\n            buf: [8192]u8, // TODO align(@alignOf(os.dirent64)),\n            index: usize,\n            end_index: usize,\n\n            const Self = @This();\n\n            pub const Error = IteratorError;\n\n            /// Memory such as file names referenced in this returned entry becomes invalid\n            /// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.\n            pub fn next(self: *Self) Error!?Entry {\n                start_over: while (true) {\n                    // TODO: find a better max\n                    const HAIKU_MAX_COUNT = 10000;\n                    if (self.index >= self.end_index) {\n                        const rc = os.system._kern_read_dir(\n                            self.dir.fd,\n                            &self.buf,\n                            self.buf.len,\n                            HAIKU_MAX_COUNT,\n                        );\n                        if (rc == 0) return null;\n                        if (rc < 0) {\n                            switch (os.errno(rc)) {\n                                os.EBADF => unreachable, // Dir is invalid or was opened without iteration ability\n                                os.EFAULT => unreachable,\n                                os.ENOTDIR => unreachable,\n                                os.EINVAL => unreachable,\n                                else => |err| return os.unexpectedErrno(err),\n                            }\n                        }\n                        self.index = 0;\n                        self.end_index = @intCast(usize, rc);\n                    }\n                    const haiku_entry = @ptrCast(*align(1) os.dirent, &self.buf[self.index]);\n                    const next_index = self.index + haiku_entry.reclen();\n                    self.index = next_index;\n                    const name = mem.spanZ(@ptrCast([*:0]u8, &haiku_entry.d_name));\n\n                    if (mem.eql(u8, name, \".\") or mem.eql(u8, name, \"..\") or (haiku_entry.d_ino == 0)) {\n                        continue :start_over;\n                    }\n\n                    var stat_info: os.libc_stat = undefined;\n                    const rc2 = os.system._kern_read_stat(\n                        self.dir.fd,\n                        &haiku_entry.d_name,\n                        false,\n                        &stat_info,\n                        0,\n                    );\n                    const statmode = stat_info.mode & os.S_IFMT;\n\n                    const entry_kind = switch (statmode) {\n                        os.S_IFDIR => Entry.Kind.Directory,\n                        os.S_IFBLK => Entry.Kind.BlockDevice,\n                        os.S_IFCHR => Entry.Kind.CharacterDevice,\n                        os.S_IFLNK => Entry.Kind.SymLink,\n                        os.S_IFREG => Entry.Kind.File,\n                        os.S_IFIFO => Entry.Kind.NamedPipe,\n                        else => Entry.Kind.Unknown,\n                    };\n\n                    return Entry{\n                        .name = name,\n                        .kind = entry_kind,\n                    };\n                }\n            }\n        },\n        .linux => struct {\n            dir: Dir,\n            buf: [8192]u8, // TODO align(@alignOf(os.dirent64)),\n            index: usize,\n            end_index: usize,\n\n            const Self = @This();\n\n            pub const Error = IteratorError;\n\n            /// Memory such as file names referenced in this returned entry becomes invalid\n            /// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.\n            pub fn next(self: *Self) Error!?Entry {\n                start_over: while (true) {\n                    if (self.index >= self.end_index) {\n                        const rc = os.linux.getdents64(self.dir.fd, &self.buf, self.buf.len);\n                        switch (os.linux.getErrno(rc)) {\n                            0 => {},\n                            os.EBADF => unreachable, // Dir is invalid or was opened without iteration ability\n                            os.EFAULT => unreachable,\n                            os.ENOTDIR => unreachable,\n                            os.EINVAL => unreachable,\n                            else => |err| return os.unexpectedErrno(err),\n                        }\n                        if (rc == 0) return null;\n                        self.index = 0;\n                        self.end_index = rc;\n                    }\n                    const linux_entry = @ptrCast(*align(1) os.dirent64, &self.buf[self.index]);\n                    const next_index = self.index + linux_entry.reclen();\n                    self.index = next_index;\n\n                    const name = mem.spanZ(@ptrCast([*:0]u8, &linux_entry.d_name));\n\n                    // skip . and .. entries\n                    if (mem.eql(u8, name, \".\") or mem.eql(u8, name, \"..\")) {\n                        continue :start_over;\n                    }\n\n                    const entry_kind = switch (linux_entry.d_type) {\n                        os.DT_BLK => Entry.Kind.BlockDevice,\n                        os.DT_CHR => Entry.Kind.CharacterDevice,\n                        os.DT_DIR => Entry.Kind.Directory,\n                        os.DT_FIFO => Entry.Kind.NamedPipe,\n                        os.DT_LNK => Entry.Kind.SymLink,\n                        os.DT_REG => Entry.Kind.File,\n                        os.DT_SOCK => Entry.Kind.UnixDomainSocket,\n                        else => Entry.Kind.Unknown,\n                    };\n                    return Entry{\n                        .name = name,\n                        .kind = entry_kind,\n                    };\n                }\n            }\n        },\n        .windows => struct {\n            dir: Dir,\n            buf: [8192]u8 align(@alignOf(os.windows.FILE_BOTH_DIR_INFORMATION)),\n            index: usize,\n            end_index: usize,\n            first: bool,\n            name_data: [256]u8,\n\n            const Self = @This();\n\n            pub const Error = IteratorError;\n\n            /// Memory such as file names referenced in this returned entry becomes invalid\n            /// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.\n            pub fn next(self: *Self) Error!?Entry {\n                start_over: while (true) {\n                    const w = os.windows;\n                    if (self.index >= self.end_index) {\n                        var io: w.IO_STATUS_BLOCK = undefined;\n                        const rc = w.ntdll.NtQueryDirectoryFile(\n                            self.dir.fd,\n                            null,\n                            null,\n                            null,\n                            &io,\n                            &self.buf,\n                            self.buf.len,\n                            .FileBothDirectoryInformation,\n                            w.FALSE,\n                            null,\n                            if (self.first) @as(w.BOOLEAN, w.TRUE) else @as(w.BOOLEAN, w.FALSE),\n                        );\n                        self.first = false;\n                        if (io.Information == 0) return null;\n                        self.index = 0;\n                        self.end_index = io.Information;\n                        switch (rc) {\n                            .SUCCESS => {},\n                            .ACCESS_DENIED => return error.AccessDenied, // Double-check that the Dir was opened with iteration ability\n\n                            else => return w.unexpectedStatus(rc),\n                        }\n                    }\n\n                    const aligned_ptr = @alignCast(@alignOf(w.FILE_BOTH_DIR_INFORMATION), &self.buf[self.index]);\n                    const dir_info = @ptrCast(*w.FILE_BOTH_DIR_INFORMATION, aligned_ptr);\n                    if (dir_info.NextEntryOffset != 0) {\n                        self.index += dir_info.NextEntryOffset;\n                    } else {\n                        self.index = self.buf.len;\n                    }\n\n                    const name_utf16le = @ptrCast([*]u16, &dir_info.FileName)[0 .. dir_info.FileNameLength / 2];\n\n                    if (mem.eql(u16, name_utf16le, &[_]u16{'.'}) or mem.eql(u16, name_utf16le, &[_]u16{ '.', '.' }))\n                        continue;\n                    // Trust that Windows gives us valid UTF-16LE\n                    const name_utf8_len = std.unicode.utf16leToUtf8(self.name_data[0..], name_utf16le) catch unreachable;\n                    const name_utf8 = self.name_data[0..name_utf8_len];\n                    const kind = blk: {\n                        const attrs = dir_info.FileAttributes;\n                        if (attrs & w.FILE_ATTRIBUTE_DIRECTORY != 0) break :blk Entry.Kind.Directory;\n                        if (attrs & w.FILE_ATTRIBUTE_REPARSE_POINT != 0) break :blk Entry.Kind.SymLink;\n                        break :blk Entry.Kind.File;\n                    };\n                    return Entry{\n                        .name = name_utf8,\n                        .kind = kind,\n                    };\n                }\n            }\n        },\n        .wasi => struct {\n            dir: Dir,\n            buf: [8192]u8, // TODO align(@alignOf(os.wasi.dirent_t)),\n            cookie: u64,\n            index: usize,\n            end_index: usize,\n\n            const Self = @This();\n\n            pub const Error = IteratorError;\n\n            /// Memory such as file names referenced in this returned entry becomes invalid\n            /// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.\n            pub fn next(self: *Self) Error!?Entry {\n                const w = os.wasi;\n                start_over: while (true) {\n                    if (self.index >= self.end_index) {\n                        var bufused: usize = undefined;\n                        switch (w.fd_readdir(self.dir.fd, &self.buf, self.buf.len, self.cookie, &bufused)) {\n                            w.ESUCCESS => {},\n                            w.EBADF => unreachable, // Dir is invalid or was opened without iteration ability\n                            w.EFAULT => unreachable,\n                            w.ENOTDIR => unreachable,\n                            w.EINVAL => unreachable,\n                            w.ENOTCAPABLE => return error.AccessDenied,\n                            else => |err| return os.unexpectedErrno(err),\n                        }\n                        if (bufused == 0) return null;\n                        self.index = 0;\n                        self.end_index = bufused;\n                    }\n                    const entry = @ptrCast(*align(1) w.dirent_t, &self.buf[self.index]);\n                    const entry_size = @sizeOf(w.dirent_t);\n                    const name_index = self.index + entry_size;\n                    const name = mem.span(self.buf[name_index .. name_index + entry.d_namlen]);\n\n                    const next_index = name_index + entry.d_namlen;\n                    self.index = next_index;\n                    self.cookie = entry.d_next;\n\n                    // skip . and .. entries\n                    if (mem.eql(u8, name, \".\") or mem.eql(u8, name, \"..\")) {\n                        continue :start_over;\n                    }\n\n                    const entry_kind = switch (entry.d_type) {\n                        w.FILETYPE_BLOCK_DEVICE => Entry.Kind.BlockDevice,\n                        w.FILETYPE_CHARACTER_DEVICE => Entry.Kind.CharacterDevice,\n                        w.FILETYPE_DIRECTORY => Entry.Kind.Directory,\n                        w.FILETYPE_SYMBOLIC_LINK => Entry.Kind.SymLink,\n                        w.FILETYPE_REGULAR_FILE => Entry.Kind.File,\n                        w.FILETYPE_SOCKET_STREAM, wasi.FILETYPE_SOCKET_DGRAM => Entry.Kind.UnixDomainSocket,\n                        else => Entry.Kind.Unknown,\n                    };\n                    return Entry{\n                        .name = name,\n                        .kind = entry_kind,\n                    };\n                }\n            }\n        },\n        else => @compileError(\"unimplemented\"),\n    }","src":303,"more_decls":null}{"pl":"const OpenError = error{\n        FileNotFound,\n        NotDir,\n        AccessDenied,\n        SymLinkLoop,\n        ProcessFdQuotaExceeded,\n        NameTooLong,\n        SystemFdQuotaExceeded,\n        NoDevice,\n        SystemResources,\n        InvalidUtf8,\n        BadPathName,\n        DeviceBusy,\n    } || os.UnexpectedError","src":733,"more_decls":null}{"pl":"const openFileC = @compileError(\"deprecated: renamed to openFileZ\")","src":798,"more_decls":null}{"pl":"const createFileC = @compileError(\"deprecated: renamed to createFileZ\")","src":914,"more_decls":null}{"pl":"const openRead = @compileError(\"deprecated in favor of openFile\")","src":1038,"more_decls":null}{"pl":"const openReadC = @compileError(\"deprecated in favor of openFileZ\")","src":1039,"more_decls":null}{"pl":"const openReadW = @compileError(\"deprecated in favor of openFileW\")","src":1040,"more_decls":null}{"pl":"const openDirC = @compileError(\"deprecated: renamed to openDirZ\")","src":1258,"more_decls":null}{"pl":"const DeleteFileError = os.UnlinkError","src":1400,"more_decls":null}{"pl":"const deleteFileC = @compileError(\"deprecated: renamed to deleteFileZ\")","src":1419,"more_decls":null}{"pl":"const DeleteDirError = error{\n        DirNotEmpty,\n        FileNotFound,\n        AccessDenied,\n        FileBusy,\n        FileSystem,\n        SymLinkLoop,\n        NameTooLong,\n        NotDir,\n        SystemResources,\n        ReadOnlyFileSystem,\n        InvalidUtf8,\n        BadPathName,\n        Unexpected,\n    }","src":1448,"more_decls":null}{"pl":"const RenameError = os.RenameError","src":1499,"more_decls":null}{"pl":"const readLinkC = @compileError(\"deprecated: renamed to readLinkZ\")","src":1594,"more_decls":null}{"pl":"const DeleteTreeError = error{\n        AccessDenied,\n        FileTooBig,\n        SymLinkLoop,\n        ProcessFdQuotaExceeded,\n        NameTooLong,\n        SystemFdQuotaExceeded,\n        NoDevice,\n        SystemResources,\n        ReadOnlyFileSystem,\n        FileSystem,\n        FileBusy,\n        DeviceBusy,\n\n        /// One of the path components was not a directory.\n        /// This error is unreachable if `sub_path` does not contain a path separator.\n        NotDir,\n\n        /// On Windows, file paths must be valid Unicode.\n        InvalidUtf8,\n\n        /// On Windows, file paths cannot contain these characters:\n        /// '/', '*', '?', '\"', '<', '>', '|'\n        BadPathName,\n    } || os.UnexpectedError","src":1660,"more_decls":null}{"pl":"const AccessError = os.AccessError","src":1845,"more_decls":null}{"pl":"const Stat = File.Stat","src":1983,"more_decls":null}{"pl":"const StatError = File.StatError","src":1984,"more_decls":null}}{"doc_comment":"Use with `Dir.symLink` and `symLinkAbsolute` to specify whether the symlink\nwill point to a file or a directory. This value is ignored on all hosts\nexcept Windows where creating symlinks to different resource types, requires\ndifferent flags. By default, `symLinkAbsolute` is assumed to point to a file.","pl":"pub const SymLinkFlags = struct ","src":2186,"more_decls":{"pl":"is_directory: bool = false","src":2187,"more_decls":null}}{"pl":"pub const Walker = struct ","src":2235,"more_decls":{"pl":"stack: std.ArrayList(StackItem)","src":2236,"more_decls":null}{"pl":"name_buffer: std.ArrayList(u8)","src":2237,"more_decls":null}{"pl":"pub const Entry = struct ","src":2239,"more_decls":{"doc_comment":"The containing directory. This can be used to operate directly on `basename`\nrather than `path`, avoiding `error.NameTooLong` for deeply nested paths.\nThe directory remains open until `next` or `deinit` is called.","pl":"dir: Dir","src":2243,"more_decls":null}{"doc_comment":"TODO make this null terminated for API convenience","pl":"basename: []const u8","src":2245,"more_decls":null}{"pl":"path: []const u8","src":2247,"more_decls":null}{"pl":"kind: Dir.Entry.Kind","src":2248,"more_decls":null}}{"doc_comment":"After each call to this function, and on deinit(), the memory returned\nfrom this function becomes invalid. A copy must be made in order to keep\na reference to the path.","pl":"fn next(self: *Walker) !?Entry","src":2259,"more_decls":null}{"pl":"pub fn deinit(self: *Walker) void {\n    while (self.stack.popOrNull()) |*item| item.dir_it.dir.close();\n    self.stack.deinit();\n    self.name_buffer.deinit();\n}","src":2295,"more_decls":null}}{"doc_comment":"TODO remove the allocator requirement from this API","pl":"fn atomicSymLink(allocator: *Allocator, existing_path: []const u8, new_path: []const u8) !void","src":68,"more_decls":null}{"doc_comment":"Same as `Dir.updateFile`, except asserts that both `source_path` and `dest_path`\nare absolute. See `Dir.updateFile` for a function that operates on both\nabsolute and relative paths.","pl":"fn updateFileAbsolute(\n    source_path: []const u8,\n    dest_path: []const u8,\n    args: CopyFileOptions,\n) !PrevStatus","src":109,"more_decls":null}{"doc_comment":"Same as `Dir.copyFile`, except asserts that both `source_path` and `dest_path`\nare absolute. See `Dir.copyFile` for a function that operates on both\nabsolute and relative paths.","pl":"pub fn copyFileAbsolute(source_path: []const u8, dest_path: []const u8, args: CopyFileOptions) !void {\n    assert(path.isAbsolute(source_path));\n    assert(path.isAbsolute(dest_path));\n    const my_cwd = cwd();\n    return Dir.copyFile(my_cwd, source_path, my_cwd, dest_path, args);\n}","src":123,"more_decls":null}{"doc_comment":"Create a new directory, based on an absolute path.\nAsserts that the path is absolute. See `Dir.makeDir` for a function that operates\non both absolute and relative paths.","pl":"pub fn makeDirAbsolute(absolute_path: []const u8) !void {\n    assert(path.isAbsolute(absolute_path));\n    return os.mkdir(absolute_path, default_new_dir_mode);\n}","src":213,"more_decls":null}{"doc_comment":"Same as `makeDirAbsolute` except the parameter is a null-terminated UTF8-encoded string.","pl":"pub fn makeDirAbsoluteZ(absolute_path_z: [*:0]const u8) !void {\n    assert(path.isAbsoluteZ(absolute_path_z));\n    return os.mkdirZ(absolute_path_z, default_new_dir_mode);\n}","src":219,"more_decls":null}{"doc_comment":"Same as `makeDirAbsolute` except the parameter is a null-terminated WTF-16 encoded string.","pl":"pub fn makeDirAbsoluteW(absolute_path_w: [*:0]const u16) !void {\n    assert(path.isAbsoluteWindowsW(absolute_path_w));\n    return os.mkdirW(absolute_path_w, default_new_dir_mode);\n}","src":225,"more_decls":null}{"doc_comment":"Same as `Dir.deleteDir` except the path is absolute.","pl":"pub fn deleteDirAbsolute(dir_path: []const u8) !void {\n    assert(path.isAbsolute(dir_path));\n    return os.rmdir(dir_path);\n}","src":235,"more_decls":null}{"doc_comment":"Same as `deleteDirAbsolute` except the path parameter is null-terminated.","pl":"pub fn deleteDirAbsoluteZ(dir_path: [*:0]const u8) !void {\n    assert(path.isAbsoluteZ(dir_path));\n    return os.rmdirZ(dir_path);\n}","src":241,"more_decls":null}{"doc_comment":"Same as `deleteDirAbsolute` except the path parameter is WTF-16 and target OS is assumed Windows.","pl":"pub fn deleteDirAbsoluteW(dir_path: [*:0]const u16) !void {\n    assert(path.isAbsoluteWindowsW(dir_path));\n    return os.rmdirW(dir_path);\n}","src":247,"more_decls":null}{"doc_comment":"Same as `Dir.rename` except the paths are absolute.","pl":"pub fn renameAbsolute(old_path: []const u8, new_path: []const u8) !void {\n    assert(path.isAbsolute(old_path));\n    assert(path.isAbsolute(new_path));\n    return os.rename(old_path, new_path);\n}","src":255,"more_decls":null}{"doc_comment":"Same as `renameAbsolute` except the path parameters are null-terminated.","pl":"pub fn renameAbsoluteZ(old_path: [*:0]const u8, new_path: [*:0]const u8) !void {\n    assert(path.isAbsoluteZ(old_path));\n    assert(path.isAbsoluteZ(new_path));\n    return os.renameZ(old_path, new_path);\n}","src":262,"more_decls":null}{"doc_comment":"Same as `renameAbsolute` except the path parameters are WTF-16 and target OS is assumed Windows.","pl":"pub fn renameAbsoluteW(old_path: [*:0]const u16, new_path: [*:0]const u16) !void {\n    assert(path.isAbsoluteWindowsW(old_path));\n    assert(path.isAbsoluteWindowsW(new_path));\n    return os.renameW(old_path, new_path);\n}","src":269,"more_decls":null}{"doc_comment":"Same as `Dir.rename`, except `new_sub_path` is relative to `new_dir`","pl":"pub fn rename(old_dir: Dir, old_sub_path: []const u8, new_dir: Dir, new_sub_path: []const u8) !void {\n    return os.renameat(old_dir.fd, old_sub_path, new_dir.fd, new_sub_path);\n}","src":276,"more_decls":null}{"doc_comment":"Same as `rename` except the parameters are null-terminated.","pl":"pub fn renameZ(old_dir: Dir, old_sub_path_z: [*:0]const u8, new_dir: Dir, new_sub_path_z: [*:0]const u8) !void {\n    return os.renameatZ(old_dir.fd, old_sub_path_z, new_dir.fd, new_sub_path_z);\n}","src":281,"more_decls":null}{"doc_comment":"Same as `rename` except the parameters are UTF16LE, NT prefixed.\nThis function is Windows-only.","pl":"pub fn renameW(old_dir: Dir, old_sub_path_w: []const u16, new_dir: Dir, new_sub_path_w: []const u16) !void {\n    return os.renameatW(old_dir.fd, old_sub_path_w, new_dir.fd, new_sub_path_w);\n}","src":287,"more_decls":null}{"doc_comment":"Returns a handle to the current working directory. It is not opened with iteration capability.\nClosing the returned `Dir` is checked illegal behavior. Iterating over the result is illegal behavior.\nOn POSIX targets, this function is comptime-callable.","pl":"fn cwd() Dir","src":1998,"more_decls":null}{"doc_comment":"Opens a directory at the given path. The directory is a system resource that remains\nopen until `close` is called on the result.\nSee `openDirAbsoluteZ` for a function that accepts a null-terminated path.\n\nAsserts that the path parameter has no null bytes.","pl":"fn openDirAbsolute(absolute_path: []const u8, flags: Dir.OpenDirOptions) File.OpenError!Dir","src":2013,"more_decls":null}{"doc_comment":"Same as `openDirAbsolute` but the path parameter is null-terminated.","pl":"fn openDirAbsoluteZ(absolute_path_c: [*:0]const u8, flags: Dir.OpenDirOptions) File.OpenError!Dir","src":2022,"more_decls":null}{"doc_comment":"Same as `openDirAbsolute` but the path parameter is null-terminated.","pl":"fn openDirAbsoluteW(absolute_path_c: [*:0]const u16, flags: Dir.OpenDirOptions) File.OpenError!Dir","src":2030,"more_decls":null}{"doc_comment":"Opens a file for reading or writing, without attempting to create a new file, based on an absolute path.\nCall `File.close` to release the resource.\nAsserts that the path is absolute. See `Dir.openFile` for a function that\noperates on both absolute and relative paths.\nAsserts that the path parameter has no null bytes. See `openFileAbsoluteZ` for a function\nthat accepts a null-terminated path.","pl":"pub fn openFileAbsolute(absolute_path: []const u8, flags: File.OpenFlags) File.OpenError!File {\n    assert(path.isAbsolute(absolute_path));\n    return cwd().openFile(absolute_path, flags);\n}","src":2044,"more_decls":null}{"doc_comment":"Same as `openFileAbsolute` but the path parameter is null-terminated.","pl":"pub fn openFileAbsoluteZ(absolute_path_c: [*:0]const u8, flags: File.OpenFlags) File.OpenError!File {\n    assert(path.isAbsoluteZ(absolute_path_c));\n    return cwd().openFileZ(absolute_path_c, flags);\n}","src":2052,"more_decls":null}{"doc_comment":"Same as `openFileAbsolute` but the path parameter is WTF-16 encoded.","pl":"pub fn openFileAbsoluteW(absolute_path_w: []const u16, flags: File.OpenFlags) File.OpenError!File {\n    assert(path.isAbsoluteWindowsWTF16(absolute_path_w));\n    return cwd().openFileW(absolute_path_w, flags);\n}","src":2058,"more_decls":null}{"doc_comment":"Test accessing `path`.\n`path` is UTF8-encoded.\nBe careful of Time-Of-Check-Time-Of-Use race conditions when using this function.\nFor example, instead of testing if a file exists and then opening it, just\nopen it and handle the error for file not found.\nSee `accessAbsoluteZ` for a function that accepts a null-terminated path.","pl":"fn accessAbsolute(absolute_path: []const u8, flags: File.OpenFlags) Dir.AccessError!void","src":2069,"more_decls":null}{"doc_comment":"Same as `accessAbsolute` but the path parameter is null-terminated.","pl":"fn accessAbsoluteZ(absolute_path: [*:0]const u8, flags: File.OpenFlags) Dir.AccessError!void","src":2077,"more_decls":null}{"doc_comment":"Same as `accessAbsolute` but the path parameter is WTF-16 encoded.","pl":"fn accessAbsoluteW(absolute_path: [*:0]const 16, flags: File.OpenFlags) Dir.AccessError!void","src":2085,"more_decls":null}{"doc_comment":"Creates, opens, or overwrites a file with write access, based on an absolute path.\nCall `File.close` to release the resource.\nAsserts that the path is absolute. See `Dir.createFile` for a function that\noperates on both absolute and relative paths.\nAsserts that the path parameter has no null bytes. See `createFileAbsoluteC` for a function\nthat accepts a null-terminated path.","pl":"pub fn createFileAbsolute(absolute_path: []const u8, flags: File.CreateFlags) File.OpenError!File {\n    assert(path.isAbsolute(absolute_path));\n    return cwd().createFile(absolute_path, flags);\n}","src":2099,"more_decls":null}{"doc_comment":"Same as `createFileAbsolute` but the path parameter is null-terminated.","pl":"pub fn createFileAbsoluteZ(absolute_path_c: [*:0]const u8, flags: File.CreateFlags) File.OpenError!File {\n    assert(path.isAbsoluteZ(absolute_path_c));\n    return cwd().createFileZ(absolute_path_c, flags);\n}","src":2107,"more_decls":null}{"doc_comment":"Same as `createFileAbsolute` but the path parameter is WTF-16 encoded.","pl":"pub fn createFileAbsoluteW(absolute_path_w: [*:0]const u16, flags: File.CreateFlags) File.OpenError!File {\n    assert(path.isAbsoluteWindowsW(absolute_path_w));\n    return cwd().createFileW(absolute_path_w, flags);\n}","src":2113,"more_decls":null}{"doc_comment":"Delete a file name and possibly the file it refers to, based on an absolute path.\nAsserts that the path is absolute. See `Dir.deleteFile` for a function that\noperates on both absolute and relative paths.\nAsserts that the path parameter has no null bytes.","pl":"pub fn deleteFileAbsolute(absolute_path: []const u8) Dir.DeleteFileError!void {\n    assert(path.isAbsolute(absolute_path));\n    return cwd().deleteFile(absolute_path);\n}","src":2122,"more_decls":null}{"doc_comment":"Same as `deleteFileAbsolute` except the parameter is null-terminated.","pl":"pub fn deleteFileAbsoluteZ(absolute_path_c: [*:0]const u8) Dir.DeleteFileError!void {\n    assert(path.isAbsoluteZ(absolute_path_c));\n    return cwd().deleteFileZ(absolute_path_c);\n}","src":2130,"more_decls":null}{"doc_comment":"Same as `deleteFileAbsolute` except the parameter is WTF-16 encoded.","pl":"pub fn deleteFileAbsoluteW(absolute_path_w: [*:0]const u16) Dir.DeleteFileError!void {\n    assert(path.isAbsoluteWindowsW(absolute_path_w));\n    return cwd().deleteFileW(absolute_path_w);\n}","src":2136,"more_decls":null}{"doc_comment":"Removes a symlink, file, or directory.\nThis is equivalent to `Dir.deleteTree` with the base directory.\nAsserts that the path is absolute. See `Dir.deleteTree` for a function that\noperates on both absolute and relative paths.\nAsserts that the path parameter has no null bytes.","pl":"fn deleteTreeAbsolute(absolute_path: []const u8) !void","src":2146,"more_decls":null}{"doc_comment":"Same as `Dir.readLink`, except it asserts the path is absolute.","pl":"pub fn readLinkAbsolute(pathname: []const u8, buffer: *[MAX_PATH_BYTES]u8) ![]u8 {\n    assert(path.isAbsolute(pathname));\n    return os.readlink(pathname, buffer);\n}","src":2161,"more_decls":null}{"doc_comment":"Windows-only. Same as `readlinkW`, except the path parameter is null-terminated, WTF16\nencoded.","pl":"pub fn readlinkAbsoluteW(pathname_w: [*:0]const u16, buffer: *[MAX_PATH_BYTES]u8) ![]u8 {\n    assert(path.isAbsoluteWindowsW(pathname_w));\n    return os.readlinkW(pathname_w, buffer);\n}","src":2168,"more_decls":null}{"doc_comment":"Same as `readLink`, except the path parameter is null-terminated.","pl":"pub fn readLinkAbsoluteZ(pathname_c: [*:0]const u8, buffer: *[MAX_PATH_BYTES]u8) ![]u8 {\n    assert(path.isAbsoluteZ(pathname_c));\n    return os.readlinkZ(pathname_c, buffer);\n}","src":2174,"more_decls":null}{"doc_comment":"Creates a symbolic link named `sym_link_path` which contains the string `target_path`.\nA symbolic link (also known as a soft link) may point to an existing file or to a nonexistent\none; the latter case is known as a dangling link.\nIf `sym_link_path` exists, it will not be overwritten.\nSee also `symLinkAbsoluteZ` and `symLinkAbsoluteW`.","pl":"fn symLinkAbsolute(target_path: []const u8, sym_link_path: []const u8, flags: SymLinkFlags) !void","src":2195,"more_decls":null}{"doc_comment":"Windows-only. Same as `symLinkAbsolute` except the parameters are null-terminated, WTF16 encoded.\nNote that this function will by default try creating a symbolic link to a file. If you would\nlike to create a symbolic link to a directory, specify this with `SymLinkFlags{ .is_directory = true }`.\nSee also `symLinkAbsolute`, `symLinkAbsoluteZ`.","pl":"pub fn symLinkAbsoluteW(target_path_w: []const u16, sym_link_path_w: []const u16, flags: SymLinkFlags) !void {\n    assert(path.isAbsoluteWindowsWTF16(target_path_w));\n    assert(path.isAbsoluteWindowsWTF16(sym_link_path_w));\n    return os.windows.CreateSymbolicLink(null, sym_link_path_w, target_path_w, flags.is_directory);\n}","src":2213,"more_decls":null}{"doc_comment":"Same as `symLinkAbsolute` except the parameters are null-terminated pointers.\nSee also `symLinkAbsolute`.","pl":"fn symLinkAbsoluteZ(target_path_c: [*:0]const u8, sym_link_path_c: [*:0]const u8, flags: SymLinkFlags) !void","src":2221,"more_decls":null}{"doc_comment":"Recursively iterates over a directory.\nMust call `Walker.deinit` when done.\n`dir_path` must not end in a path separator.\nThe order of returned file system entries is undefined.","pl":"fn walkPath(allocator: *Allocator, dir_path: []const u8) !Walker","src":2306,"more_decls":null}{"pl":"fn openSelfExe(flags: File.OpenFlags) OpenSelfExeError!File","src":2345,"more_decls":null}{"doc_comment":"`selfExePath` except allocates the result on the heap.\nCaller owns returned memory.","pl":"fn selfExePathAlloc(allocator: *Allocator) ![]u8","src":2366,"more_decls":null}{"doc_comment":"Get the path to the current executable.\nIf you only need the directory, use selfExeDirPath.\nIf you only want an open file handle, use openSelfExe.\nThis function may return an error if the current executable\nwas deleted after spawning.\nReturned value is a slice of out_buffer.\n\nOn Linux, depends on procfs being mounted. If the currently executing binary has\nbeen deleted, the file path looks something like `/a/b/c/exe (deleted)`.\nTODO make the return type of this a null terminated pointer","pl":"fn selfExePath(out_buffer: []u8) SelfExePathError![]u8","src":2388,"more_decls":null}{"doc_comment":"The result is UTF16LE-encoded.","pl":"pub fn selfExePathW() [:0]const u16 {\n    const image_path_name = &os.windows.peb().ProcessParameters.ImagePathName;\n    return mem.spanZ(std.meta.assumeSentinel(image_path_name.Buffer, 0));\n}","src":2467,"more_decls":null}{"doc_comment":"`selfExeDirPath` except allocates the result on the heap.\nCaller owns returned memory.","pl":"fn selfExeDirPathAlloc(allocator: *Allocator) ![]u8","src":2474,"more_decls":null}{"doc_comment":"Get the directory path that contains the current executable.\nReturned value is a slice of out_buffer.","pl":"pub fn selfExeDirPath(out_buffer: []u8) SelfExePathError![]const u8 {\n    const self_exe_path = try selfExePath(out_buffer);\n    // Assume that the OS APIs return absolute paths, and therefore dirname\n    // will not return null.\n    return path.dirname(self_exe_path).?;\n}","src":2488,"more_decls":null}{"doc_comment":"`realpath`, except caller must free the returned memory.\nSee also `Dir.realpath`.","pl":"fn realpathAlloc(allocator: *Allocator, pathname: []const u8) ![]u8","src":2497,"more_decls":null}{"pl":"const path = @import(\"fs/path.zig\")","src":17,"more_decls":null}{"pl":"const File = @import(\"fs/file.zig\").File","src":18,"more_decls":null}{"pl":"const wasi = @import(\"fs/wasi.zig\")","src":19,"more_decls":null}{"pl":"const realpath = os.realpath","src":23,"more_decls":null}{"pl":"const realpathZ = os.realpathZ","src":24,"more_decls":null}{"pl":"const realpathC = @compileError(\"deprecated: renamed to realpathZ\")","src":25,"more_decls":null}{"pl":"const realpathW = os.realpathW","src":26,"more_decls":null}{"pl":"const getAppDataDir = @import(\"fs/get_app_data_dir.zig\").getAppDataDir","src":28,"more_decls":null}{"pl":"const GetAppDataDirError = @import(\"fs/get_app_data_dir.zig\").GetAppDataDirError","src":29,"more_decls":null}{"pl":"const Watch = @import(\"fs/watch.zig\").Watch","src":31,"more_decls":null}{"doc_comment":"This represents the maximum size of a UTF-8 encoded file path that the\noperating system will accept. Paths, including those returned from file\nsystem operations, may be longer than this length, but such paths cannot\nbe successfully passed back in other file system operations. However,\nall path components returned by file system operations are assumed to\nfit into a UTF-8 encoded array of this length.\nThe byte count includes room for a null sentinel byte.","pl":"const MAX_PATH_BYTES = switch (builtin.os.tag) {\n    .linux, .macos, .ios, .freebsd, .netbsd, .dragonfly, .openbsd, .haiku => os.PATH_MAX,\n    // Each UTF-16LE character may be expanded to 3 UTF-8 bytes.\n    // If it would require 4 UTF-8 bytes, then there would be a surrogate\n    // pair in the UTF-16LE, and we (over)account 3 bytes for it that way.\n    // +1 for the null byte at the end, which can be encoded in 1 byte.\n    .windows => os.windows.PATH_MAX_WIDE * 3 + 1,\n    // TODO work out what a reasonable value we should use here\n    .wasi => 4096,\n    else => @compileError(\"Unsupported OS\"),\n}","src":40,"more_decls":null}{"pl":"const base64_alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\".*","src":52,"more_decls":null}{"doc_comment":"Base64 encoder, replacing the standard `+/` with `-_` so that it can be used in a file name on any filesystem.","pl":"const base64_encoder = base64.Base64Encoder.init(base64_alphabet, null)","src":55,"more_decls":null}{"doc_comment":"Base64 decoder, replacing the standard `+/` with `-_` so that it can be used in a file name on any filesystem.","pl":"const base64_decoder = base64.Base64Decoder.init(base64_alphabet, null)","src":58,"more_decls":null}{"doc_comment":"Whether or not async file system syscalls need a dedicated thread because the operating\nsystem does not support non-blocking I/O on the file system.","pl":"const need_async_thread = std.io.is_async and switch (builtin.os.tag) {\n    .windows, .other => false,\n    else => true,\n}","src":62,"more_decls":null}{"pl":"const deleteDir = @compileError(\"deprecated; use dir.deleteDir or deleteDirAbsolute\")","src":230,"more_decls":null}{"pl":"const deleteDirC = @compileError(\"deprecated; use dir.deleteDirZ or deleteDirAbsoluteZ\")","src":231,"more_decls":null}{"pl":"const deleteDirW = @compileError(\"deprecated; use dir.deleteDirW or deleteDirAbsoluteW\")","src":232,"more_decls":null}{"pl":"const renameC = @compileError(\"deprecated: use renameZ, dir.renameZ, or renameAbsoluteZ\")","src":252,"more_decls":null}{"pl":"const openFileAbsoluteC = @compileError(\"deprecated: renamed to openFileAbsoluteZ\")","src":2049,"more_decls":null}{"pl":"const createFileAbsoluteC = @compileError(\"deprecated: renamed to createFileAbsoluteZ\")","src":2104,"more_decls":null}{"pl":"const deleteFileAbsoluteC = @compileError(\"deprecated: renamed to deleteFileAbsoluteZ\")","src":2127,"more_decls":null}{"pl":"const readLink = @compileError(\"deprecated; use Dir.readLink or readLinkAbsolute\")","src":2179,"more_decls":null}{"pl":"const readLinkC = @compileError(\"deprecated; use Dir.readLinkZ or readLinkAbsoluteZ\")","src":2180,"more_decls":null}{"pl":"const symLink = @compileError(\"deprecated: use Dir.symLink or symLinkAbsolute\")","src":2232,"more_decls":null}{"pl":"const symLinkC = @compileError(\"deprecated: use Dir.symLinkZ or symLinkAbsoluteZ\")","src":2233,"more_decls":null}{"pl":"const OpenSelfExeError = error{\n    SharingViolation,\n    PathAlreadyExists,\n    FileNotFound,\n    AccessDenied,\n    PipeBusy,\n    NameTooLong,\n    /// On Windows, file paths must be valid Unicode.\n    InvalidUtf8,\n    /// On Windows, file paths cannot contain these characters:\n    /// '/', '*', '?', '\"', '<', '>', '|'\n    BadPathName,\n    Unexpected,\n} || os.OpenError || SelfExePathError || os.FlockError","src":2330,"more_decls":null}{"pl":"const SelfExePathError = os.ReadLinkError || os.SysCtlError || os.RealPathError","src":2362,"more_decls":null}]