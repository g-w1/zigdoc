[{"pl":"pub const ChildProcess = struct ","src":23,"more_decls":{"pl":"pid: if (builtin.os.tag == .windows) void else i32","src":24,"more_decls":null}{"pl":"handle: if (builtin.os.tag == .windows) windows.HANDLE else void","src":25,"more_decls":null}{"pl":"thread_handle: if (builtin.os.tag == .windows) windows.HANDLE else void","src":26,"more_decls":null}{"pl":"allocator: *mem.Allocator","src":28,"more_decls":null}{"pl":"stdin: ?File","src":30,"more_decls":null}{"pl":"stdout: ?File","src":31,"more_decls":null}{"pl":"stderr: ?File","src":32,"more_decls":null}{"pl":"term: ?(SpawnError!Term)","src":34,"more_decls":null}{"pl":"argv: []const []const u8","src":36,"more_decls":null}{"doc_comment":"Leave as null to use the current env map using the supplied allocator.","pl":"env_map: ?*const BufMap","src":39,"more_decls":null}{"pl":"stdin_behavior: StdIo","src":41,"more_decls":null}{"pl":"stdout_behavior: StdIo","src":42,"more_decls":null}{"pl":"stderr_behavior: StdIo","src":43,"more_decls":null}{"doc_comment":"Set to change the user id when spawning the child process.","pl":"uid: if (builtin.os.tag == .windows or builtin.os.tag == .wasi) void else ?os.uid_t","src":46,"more_decls":null}{"doc_comment":"Set to change the group id when spawning the child process.","pl":"gid: if (builtin.os.tag == .windows or builtin.os.tag == .wasi) void else ?os.gid_t","src":49,"more_decls":null}{"doc_comment":"Set to change the current working directory when spawning the child process.","pl":"cwd: ?[]const u8","src":52,"more_decls":null}{"doc_comment":"Set to change the current working directory when spawning the child process.\nThis is not yet implemented for Windows. See https://github.com/ziglang/zig/issues/5190\nOnce that is done, `cwd` will be deprecated in favor of this field.","pl":"cwd_dir: ?fs.Dir = null","src":56,"more_decls":null}{"pl":"err_pipe: if (builtin.os.tag == .windows) void else [2]os.fd_t","src":58,"more_decls":null}{"pl":"expand_arg0: Arg0Expand","src":60,"more_decls":null}{"pl":"pub const Term = union(enum) ","src":79,"more_decls":{"pl":"Exited: u32","src":80,"more_decls":null}{"pl":"Signal: u32","src":81,"more_decls":null}{"pl":"Stopped: u32","src":82,"more_decls":null}{"pl":"Unknown: u32","src":83,"more_decls":null}}{"pl":"pub const StdIo = enum ","src":86,"more_decls":{"pl":"Inherit","src":87,"more_decls":null}{"pl":"Ignore","src":88,"more_decls":null}{"pl":"Pipe","src":89,"more_decls":null}{"pl":"Close","src":90,"more_decls":null}}{"pl":"pub const ExecResult = struct ","src":180,"more_decls":{"pl":"term: Term","src":181,"more_decls":null}{"pl":"stdout: []u8","src":182,"more_decls":null}{"pl":"stderr: []u8","src":183,"more_decls":null}}{"doc_comment":"First argument in argv is the executable.\nOn success must call deinit.","pl":"fn init(argv: []const []const u8, allocator: *mem.Allocator) !*ChildProcess","src":95,"more_decls":null}{"pl":"pub fn setUserName(self: *ChildProcess, name: []const u8) !void {\n    const user_info = try os.getUserInfo(name);\n    self.uid = user_info.uid;\n    self.gid = user_info.gid;\n}","src":121,"more_decls":null}{"doc_comment":"On success must call `kill` or `wait`.","pl":"fn spawn(self: *ChildProcess) SpawnError!void","src":128,"more_decls":null}{"pl":"pub fn spawnAndWait(self: *ChildProcess) SpawnError!Term {\n    try self.spawn();\n    return self.wait();\n}","src":136,"more_decls":null}{"doc_comment":"Forcibly terminates child process and then cleans up all resources.","pl":"fn kill(self: *ChildProcess) !Term","src":142,"more_decls":null}{"pl":"fn killWindows(self: *ChildProcess, exit_code: windows.UINT) !Term","src":150,"more_decls":null}{"pl":"fn killPosix(self: *ChildProcess) !Term","src":161,"more_decls":null}{"doc_comment":"Blocks until child process terminates and then cleans up all resources.","pl":"fn wait(self: *ChildProcess) !Term","src":172,"more_decls":null}{"doc_comment":"Spawns a child process, waits for it, collecting stdout and stderr, and then returns.\nIf it succeeds, the caller owns result.stdout and result.stderr memory.","pl":"fn exec(args: struct {\n    allocator: *mem.Allocator,\n    argv: []const []const u8,\n    cwd: ?[]const u8 = null,\n    cwd_dir: ?fs.Dir = null,\n    env_map: ?*const BufMap = null,\n    max_output_bytes: usize = 50 * 1024,\n    expand_arg0: Arg0Expand = .no_expand,\n}) !ExecResult","src":242,"more_decls":null}{"pl":"pub fn deinit(self: *ChildProcess) void {\n    self.allocator.destroy(self);\n}","src":314,"more_decls":null}{"pl":"const Arg0Expand = os.Arg0Expand","src":62,"more_decls":null}{"pl":"const SpawnError = error{\n        OutOfMemory,\n\n        /// POSIX-only. `StdIo.Ignore` was selected and opening `/dev/null` returned ENODEV.\n        NoDevice,\n\n        /// Windows-only. One of:\n        /// * `cwd` was provided and it could not be re-encoded into UTF16LE, or\n        /// * The `PATH` or `PATHEXT` environment variable contained invalid UTF-8.\n        InvalidUtf8,\n\n        /// Windows-only. `cwd` was provided, but the path did not exist when spawning the child process.\n        CurrentWorkingDirectoryUnlinked,\n    } || os.ExecveError || os.SetIdError || os.ChangeCurDirError || windows.CreateProcessError || windows.WaitForSingleObjectError","src":64,"more_decls":null}{"pl":"const exec2 = @compileError(\"deprecated: exec2 is renamed to exec\")","src":186,"more_decls":null}}{"doc_comment":"Caller must free result.","pl":"fn createWindowsEnvBlock(allocator: *mem.Allocator, env_map: *const BufMap) ![]u16","src":937,"more_decls":null}{"pl":"fn createNullDelimitedEnvMap(arena: *mem.Allocator, env_map: *const std.BufMap) ![:null]?[*:0]u8","src":973,"more_decls":null}]