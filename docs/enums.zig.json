[{"doc_comment":"Returns a struct with a field matching each unique named enum element.\nIf the enum is extern and has multiple names for the same value, only\nthe first name is used.  Each field is of type Data and has the provided\ndefault, which may be undefined.","pl":"fn EnumFieldStruct(comptime E: type, comptime Data: type, comptime field_default: ?Data) type","src":17,"more_decls":null}{"doc_comment":"Looks up the supplied fields in the given enum type.\nUses only the field names, field values are ignored.\nThe result array is in the same order as the input.","pl":"fn valuesFromFields(comptime E: type, comptime fields: []const EnumField) []const E","src":40,"more_decls":null}{"doc_comment":"Returns the set of all named values in the given enum, in\ndeclaration order.","pl":"pub fn values(comptime E: type) []const E {\n    return comptime valuesFromFields(E, @typeInfo(E).Enum.fields);\n}","src":66,"more_decls":null}{"doc_comment":"Returns the set of all unique named values in the given enum, in\ndeclaration order.  For repeated values in extern enums, only the\nfirst name for each value is included.","pl":"pub fn uniqueValues(comptime E: type) []const E {\n    return comptime valuesFromFields(E, uniqueFields(E));\n}","src":78,"more_decls":null}{"doc_comment":"Returns the set of all unique field values in the given enum, in\ndeclaration order.  For repeated values in extern enums, only the\nfirst name for each value is included.","pl":"fn uniqueFields(comptime E: type) []const EnumField","src":93,"more_decls":null}{"doc_comment":"Initializes an array of Data which can be indexed by\n@intCast(usize, @enumToInt(enum_value)).\nIf the enum is non-exhaustive, the resulting array will only be large enough\nto hold all explicit fields.\nIf the enum contains any fields with values that cannot be represented\nby usize, a compile error is issued.  The max_unused_slots parameter limits\nthe total number of items which have no matching enum key (holes in the enum\nnumbering).  So for example, if an enum has values 1, 2, 5, and 6, max_unused_slots\nmust be at least 3, to allow unused slots 0, 3, and 4.\nThe init_values parameter must be a struct with field names that match the enum values.\nIf the enum has multiple fields with the same value, the name of the first one must\nbe used.","pl":"fn directEnumArray(\n    comptime E: type,\n    comptime Data: type,\n    comptime max_unused_slots: comptime_int,\n    init_values: EnumFieldStruct(E, Data, null),\n) [directEnumArrayLen(E, max_unused_slots)]Data","src":163,"more_decls":null}{"doc_comment":"Initializes an array of Data which can be indexed by\n@intCast(usize, @enumToInt(enum_value)).  The enum must be exhaustive.\nIf the enum contains any fields with values that cannot be represented\nby usize, a compile error is issued.  The max_unused_slots parameter limits\nthe total number of items which have no matching enum key (holes in the enum\nnumbering).  So for example, if an enum has values 1, 2, 5, and 6, max_unused_slots\nmust be at least 3, to allow unused slots 0, 3, and 4.\nThe init_values parameter must be a struct with field names that match the enum values.\nIf the enum has multiple fields with the same value, the name of the first one must\nbe used.","pl":"fn directEnumArrayDefault(\n    comptime E: type,\n    comptime Data: type,\n    comptime default: ?Data,\n    comptime max_unused_slots: comptime_int,\n    init_values: EnumFieldStruct(E, Data, default),\n) [directEnumArrayLen(E, max_unused_slots)]Data","src":197,"more_decls":null}{"doc_comment":"Cast an enum literal, value, or string to the enum value of type E\nwith the same name.","pl":"fn nameCast(comptime E: type, comptime value: anytype) E","src":230,"more_decls":null}{"doc_comment":"A set of enum elements, backed by a bitfield.  If the enum\nis not dense, a mapping will be constructed from enum values\nto dense indices.  This type does no dynamic allocation and\ncan be copied by value.","pl":"fn EnumSet(comptime E: type) type","src":275,"more_decls":null}{"doc_comment":"A map keyed by an enum, backed by a bitfield and a dense array.\nIf the enum is not dense, a mapping will be constructed from\nenum values to dense indices.  This type does no dynamic\nallocation and can be copied by value.","pl":"fn EnumMap(comptime E: type, comptime V: type) type","src":303,"more_decls":null}{"doc_comment":"An array keyed by an enum, backed by a dense array.\nIf the enum is not dense, a mapping will be constructed from\nenum values to dense indices.  This type does no dynamic\nallocation and can be copied by value.","pl":"fn EnumArray(comptime E: type, comptime V: type) type","src":362,"more_decls":null}{"doc_comment":"Pass this function as the Ext parameter to Indexed* if you\ndo not want to attach any extensions.  This parameter was\noriginally an optional, but optional generic functions\nseem to be broken at the moment.\nTODO: Once #8169 is fixed, consider switching this param\nback to an optional.","pl":"pub fn NoExtension(comptime Self: type) type {\n    return NoExt;\n}","src":395,"more_decls":null}{"doc_comment":"A set type with an Indexer mapping from keys to indices.\nPresence or absence is stored as a dense bitfield.  This\ntype does no allocation and can be copied by value.","pl":"fn IndexedSet(comptime I: type, comptime Ext: fn (type) type) type","sub_container_type":"struct ","src":403,"more_decls":{"pl":"bits: BitSet = BitSet.initEmpty()","src":420,"more_decls":null}{"pl":"pub const Iterator = struct ","src":486,"more_decls":{"pl":"inner: BitSet.Iterator(.{})","src":487,"more_decls":null}{"pl":"pub fn next(self: *Iterator) ?Key {\n    return if (self.inner.next()) |index|\n        Indexer.keyForIndex(index)\n    else\n        null;\n}","src":489,"more_decls":null}}{"doc_comment":"Returns a set containing all possible keys.","pl":"pub fn initFull() Self {\n    return .{ .bits = BitSet.initFull() };\n}","src":423,"more_decls":null}{"doc_comment":"Returns the number of keys in the set.","pl":"pub fn count(self: Self) usize {\n    return self.bits.count();\n}","src":428,"more_decls":null}{"doc_comment":"Checks if a key is in the set.","pl":"pub fn contains(self: Self, key: Key) bool {\n    return self.bits.isSet(Indexer.indexOf(key));\n}","src":433,"more_decls":null}{"doc_comment":"Puts a key in the set.","pl":"pub fn insert(self: *Self, key: Key) void {\n    self.bits.set(Indexer.indexOf(key));\n}","src":438,"more_decls":null}{"doc_comment":"Removes a key from the set.","pl":"pub fn remove(self: *Self, key: Key) void {\n    self.bits.unset(Indexer.indexOf(key));\n}","src":443,"more_decls":null}{"doc_comment":"Changes the presence of a key in the set to match the passed bool.","pl":"pub fn setPresent(self: *Self, key: Key, present: bool) void {\n    self.bits.setValue(Indexer.indexOf(key), present);\n}","src":448,"more_decls":null}{"doc_comment":"Toggles the presence of a key in the set.  If the key is in\nthe set, removes it.  Otherwise adds it.","pl":"pub fn toggle(self: *Self, key: Key) void {\n    self.bits.toggle(Indexer.indexOf(key));\n}","src":454,"more_decls":null}{"doc_comment":"Toggles the presence of all keys in the passed set.","pl":"pub fn toggleSet(self: *Self, other: Self) void {\n    self.bits.toggleSet(other.bits);\n}","src":459,"more_decls":null}{"doc_comment":"Toggles all possible keys in the set.","pl":"pub fn toggleAll(self: *Self) void {\n    self.bits.toggleAll();\n}","src":464,"more_decls":null}{"doc_comment":"Adds all keys in the passed set to this set.","pl":"pub fn setUnion(self: *Self, other: Self) void {\n    self.bits.setUnion(other.bits);\n}","src":469,"more_decls":null}{"doc_comment":"Removes all keys which are not in the passed set.","pl":"pub fn setIntersection(self: *Self, other: Self) void {\n    self.bits.setIntersection(other.bits);\n}","src":474,"more_decls":null}{"doc_comment":"Returns an iterator over this set, which iterates in\nindex order.  Modifications to the set during iteration\nmay or may not be observed by the iterator, but will\nnot invalidate it.","pl":"pub fn iterator(self: *Self) Iterator {\n    return .{ .inner = self.bits.iterator(.{}) };\n}","src":482,"more_decls":null}{"doc_comment":"The indexing rules for converting between keys and indices.","pl":"const Indexer = I","src":411,"more_decls":null}{"doc_comment":"The element type for this set.","pl":"const Key = Indexer.Key","src":413,"more_decls":null}{"doc_comment":"The maximum number of items in this set.","pl":"const len = Indexer.count","src":418,"more_decls":null}}{"doc_comment":"A map from keys to values, using an index lookup.  Uses a\nbitfield to track presence and a dense array of values.\nThis type does no allocation and can be copied by value.","pl":"fn IndexedMap(comptime I: type, comptime V: type, comptime Ext: fn (type) type) type","sub_container_type":"struct ","src":502,"more_decls":{"doc_comment":"Bits determining whether items are in the map","pl":"bits: BitSet = BitSet.initEmpty()","src":521,"more_decls":null}{"doc_comment":"Values of items in the map.  If the associated\nbit is zero, the value is undefined.","pl":"values: [Indexer.count]Value = undefined","src":524,"more_decls":null}{"doc_comment":"An entry in the map.","pl":"pub const Entry = struct ","src":632,"more_decls":{"doc_comment":"The key associated with this entry.\nModifying this key will not change the map.","pl":"key: Key","src":635,"more_decls":null}{"doc_comment":"A pointer to the value in the map associated\nwith this key.  Modifications through this\npointer will modify the underlying data.","pl":"value: *Value","src":640,"more_decls":null}}{"pl":"pub const Iterator = struct ","src":643,"more_decls":{"pl":"inner: BitSet.Iterator(.{})","src":644,"more_decls":null}{"pl":"values: *[Indexer.count]Value","src":645,"more_decls":null}{"pl":"fn next(self: *Iterator) ?Entry","src":647,"more_decls":null}}{"doc_comment":"The number of items in the map.","pl":"pub fn count(self: Self) usize {\n    return self.bits.count();\n}","src":527,"more_decls":null}{"doc_comment":"Checks if the map contains an item.","pl":"pub fn contains(self: Self, key: Key) bool {\n    return self.bits.isSet(Indexer.indexOf(key));\n}","src":532,"more_decls":null}{"doc_comment":"Gets the value associated with a key.\nIf the key is not in the map, returns null.","pl":"pub fn get(self: Self, key: Key) ?Value {\n    const index = Indexer.indexOf(key);\n    return if (self.bits.isSet(index)) self.values[index] else null;\n}","src":538,"more_decls":null}{"doc_comment":"Gets the value associated with a key, which must\nexist in the map.","pl":"pub fn getAssertContains(self: Self, key: Key) Value {\n    const index = Indexer.indexOf(key);\n    assert(self.bits.isSet(index));\n    return self.values[index];\n}","src":545,"more_decls":null}{"doc_comment":"Gets the address of the value associated with a key.\nIf the key is not in the map, returns null.","pl":"pub fn getPtr(self: *Self, key: Key) ?*Value {\n    const index = Indexer.indexOf(key);\n    return if (self.bits.isSet(index)) &self.values[index] else null;\n}","src":553,"more_decls":null}{"doc_comment":"Gets the address of the const value associated with a key.\nIf the key is not in the map, returns null.","pl":"pub fn getPtrConst(self: *const Self, key: Key) ?*const Value {\n    const index = Indexer.indexOf(key);\n    return if (self.bits.isSet(index)) &self.values[index] else null;\n}","src":560,"more_decls":null}{"doc_comment":"Gets the address of the value associated with a key.\nThe key must be present in the map.","pl":"pub fn getPtrAssertContains(self: *Self, key: Key) *Value {\n    const index = Indexer.indexOf(key);\n    assert(self.bits.isSet(index));\n    return &self.values[index];\n}","src":567,"more_decls":null}{"doc_comment":"Adds the key to the map with the supplied value.\nIf the key is already in the map, overwrites the value.","pl":"pub fn put(self: *Self, key: Key, value: Value) void {\n    const index = Indexer.indexOf(key);\n    self.bits.set(index);\n    self.values[index] = value;\n}","src":575,"more_decls":null}{"doc_comment":"Adds the key to the map with an undefined value.\nIf the key is already in the map, the value becomes undefined.\nA pointer to the value is returned, which should be\nused to initialize the value.","pl":"pub fn putUninitialized(self: *Self, key: Key) *Value {\n    const index = Indexer.indexOf(key);\n    self.bits.set(index);\n    self.values[index] = undefined;\n    return &self.values[index];\n}","src":585,"more_decls":null}{"doc_comment":"Sets the value associated with the key in the map,\nand returns the old value.  If the key was not in\nthe map, returns null.","pl":"fn fetchPut(self: *Self, key: Key, value: Value) ?Value","src":595,"more_decls":null}{"doc_comment":"Removes a key from the map.  If the key was not in the map,\ndoes nothing.","pl":"pub fn remove(self: *Self, key: Key) void {\n    const index = Indexer.indexOf(key);\n    self.bits.unset(index);\n    self.values[index] = undefined;\n}","src":605,"more_decls":null}{"doc_comment":"Removes a key from the map, and returns the old value.\nIf the key was not in the map, returns null.","pl":"fn fetchRemove(self: *Self, key: Key) ?Value","src":613,"more_decls":null}{"doc_comment":"Returns an iterator over the map, which visits items in index order.\nModifications to the underlying map may or may not be observed by\nthe iterator, but will not invalidate it.","pl":"pub fn iterator(self: *Self) Iterator {\n    return .{\n        .inner = self.bits.iterator(.{}),\n        .values = &self.values,\n    };\n}","src":624,"more_decls":null}{"doc_comment":"The index mapping for this map","pl":"const Indexer = I","src":510,"more_decls":null}{"doc_comment":"The key type used to index this map","pl":"const Key = Indexer.Key","src":512,"more_decls":null}{"doc_comment":"The value type stored in this map","pl":"const Value = V","src":514,"more_decls":null}{"doc_comment":"The number of possible keys in the map","pl":"const len = Indexer.count","src":516,"more_decls":null}}{"doc_comment":"A dense array of values, using an indexed lookup.\nThis type does no allocation and can be copied by value.","pl":"fn IndexedArray(comptime I: type, comptime V: type, comptime Ext: fn (type) type) type","sub_container_type":"struct ","src":662,"more_decls":{"pl":"values: [Indexer.count]Value","src":678,"more_decls":null}{"doc_comment":"An entry in the array.","pl":"pub const Entry = struct ","src":718,"more_decls":{"doc_comment":"The key associated with this entry.\nModifying this key will not change the array.","pl":"key: Key","src":721,"more_decls":null}{"doc_comment":"A pointer to the value in the array associated\nwith this key.  Modifications through this\npointer will modify the underlying data.","pl":"value: *Value","src":726,"more_decls":null}}{"pl":"pub const Iterator = struct ","src":729,"more_decls":{"pl":"index: usize = 0","src":730,"more_decls":null}{"pl":"values: *[Indexer.count]Value","src":731,"more_decls":null}{"pl":"fn next(self: *Iterator) ?Entry","src":733,"more_decls":null}}{"pl":"pub fn initUndefined() Self {\n    return Self{ .values = undefined };\n}","src":680,"more_decls":null}{"pl":"pub fn initFill(v: Value) Self {\n    var self: Self = undefined;\n    std.mem.set(Value, &self.values, v);\n    return self;\n}","src":684,"more_decls":null}{"doc_comment":"Returns the value in the array associated with a key.","pl":"pub fn get(self: Self, key: Key) Value {\n    return self.values[Indexer.indexOf(key)];\n}","src":691,"more_decls":null}{"doc_comment":"Returns a pointer to the slot in the array associated with a key.","pl":"pub fn getPtr(self: *Self, key: Key) *Value {\n    return &self.values[Indexer.indexOf(key)];\n}","src":696,"more_decls":null}{"doc_comment":"Returns a const pointer to the slot in the array associated with a key.","pl":"pub fn getPtrConst(self: *const Self, key: Key) *const Value {\n    return &self.values[Indexer.indexOf(key)];\n}","src":701,"more_decls":null}{"doc_comment":"Sets the value in the slot associated with a key.","pl":"pub fn set(self: *Self, key: Key, value: Value) void {\n    self.values[Indexer.indexOf(key)] = value;\n}","src":706,"more_decls":null}{"doc_comment":"Iterates over the items in the array, in index order.","pl":"pub fn iterator(self: *Self) Iterator {\n    return .{\n        .values = &self.values,\n    };\n}","src":711,"more_decls":null}{"doc_comment":"The index mapping for this map","pl":"const Indexer = I","src":670,"more_decls":null}{"doc_comment":"The key type used to index this map","pl":"const Key = Indexer.Key","src":672,"more_decls":null}{"doc_comment":"The value type stored in this map","pl":"const Value = V","src":674,"more_decls":null}{"doc_comment":"The number of possible keys in the map","pl":"const len = Indexer.count","src":676,"more_decls":null}}{"doc_comment":"Verifies that a type is a valid Indexer, providing a helpful\ncompile error if not.  An Indexer maps a comptime known set\nof keys to a dense set of zero-based indices.\nThe indexer interface must look like this:\n```\nstruct {\n/// The key type which this indexer converts to indices\npub const Key: type,\n/// The number of indexes in the dense mapping\npub const count: usize,\n/// Converts from a key to an index\npub fn indexOf(Key) usize;\n/// Converts from an index to a key\npub fn keyForIndex(usize) Key;\n}\n```","pl":"fn ensureIndexer(comptime T: type) void","src":764,"more_decls":null}{"pl":"fn EnumIndexer(comptime E: type) type","sub_container_type":"struct ","src":793,"more_decls":{"pl":"pub fn indexOf(e: E) usize {\n    for (keys) |k, i| {\n        if (k == e) return i;\n    }\n    unreachable;\n}","src":837,"more_decls":null}{"pl":"pub fn keyForIndex(i: usize) E {\n    return keys[i];\n}","src":843,"more_decls":null}{"pl":"const Key = E","src":835,"more_decls":null}{"pl":"const count = fields.len","src":836,"more_decls":null}}]